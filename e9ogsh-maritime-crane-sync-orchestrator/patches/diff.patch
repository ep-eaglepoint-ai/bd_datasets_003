diff --git a/repository_before/.gitkeep b/repository_before/.gitkeep
deleted file mode 100644
index e69de29..0000000
diff --git a/repository_after/pom.xml b/repository_after/pom.xml
new file mode 100644
index 0000000..e730b2c
--- /dev/null
+++ b/repository_after/pom.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>com.porthorizon</groupId>
+    <artifactId>crane-sync-orchestrator</artifactId>
+    <version>1.0.0</version>
+    <packaging>jar</packaging>
+
+    <name>Maritime Crane Sync Orchestrator</name>
+    <description>Real-time safety synchronization service for tandem crane operations</description>
+
+    <properties>
+        <maven.compiler.source>17</maven.compiler.source>
+        <maven.compiler.target>17</maven.compiler.target>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    </properties>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.11.0</version>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <version>3.3.0</version>
+            </plugin>
+        </plugins>
+    </build>
+</project>
\ No newline at end of file
diff --git a/repository_after/src/main/java/com/porthorizon/crane/AlignedTelemetryPair.java b/repository_after/src/main/java/com/porthorizon/crane/AlignedTelemetryPair.java
new file mode 100644
index 0000000..31d6e79
--- /dev/null
+++ b/repository_after/src/main/java/com/porthorizon/crane/AlignedTelemetryPair.java
@@ -0,0 +1,53 @@
+package com.porthorizon.crane;
+
+/**
+ * Represents a temporally aligned pair of telemetry pulses from both cranes.
+ */
+public final class AlignedTelemetryPair {
+    
+    private final TelemetryPulse pulseA;
+    private final TelemetryPulse pulseB;
+    private final long alignmentDeltaNs;
+    
+    public AlignedTelemetryPair(TelemetryPulse pulseA, TelemetryPulse pulseB) {
+        this.pulseA = pulseA;
+        this.pulseB = pulseB;
+        this.alignmentDeltaNs = Math.abs(pulseA.timestampNs() - pulseB.timestampNs());
+    }
+    
+    public TelemetryPulse pulseA() {
+        return pulseA;
+    }
+    
+    public TelemetryPulse pulseB() {
+        return pulseB;
+    }
+    
+    public long alignmentDeltaNs() {
+        return alignmentDeltaNs;
+    }
+    
+    /**
+     * Calculates the vertical tilt delta between the two cranes.
+     * @return absolute difference in millimeters
+     */
+    public double calculateTiltDeltaMm() {
+        return Math.abs(pulseA.zAxisMm() - pulseB.zAxisMm());
+    }
+    
+    /**
+     * Checks if the telemetry pair is within acceptable alignment threshold.
+     * @param maxDeltaNs maximum allowed time difference in nanoseconds
+     * @return true if well-aligned
+     */
+    public boolean isWellAligned(long maxDeltaNs) {
+        return alignmentDeltaNs <= maxDeltaNs;
+    }
+    
+    @Override
+    public String toString() {
+        return String.format("AlignedPair{A=%.2fmm, B=%.2fmm, delta=%.2fmm, alignNs=%d}",
+                           pulseA.zAxisMm(), pulseB.zAxisMm(), 
+                           calculateTiltDeltaMm(), alignmentDeltaNs);
+    }
+}
\ No newline at end of file
diff --git a/repository_after/src/main/java/com/porthorizon/crane/Command.java b/repository_after/src/main/java/com/porthorizon/crane/Command.java
new file mode 100644
index 0000000..cdc74ba
--- /dev/null
+++ b/repository_after/src/main/java/com/porthorizon/crane/Command.java
@@ -0,0 +1,88 @@
+package com.porthorizon.crane;
+
+import java.util.Objects;
+
+/**
+ * Represents a command to be sent to crane motor controllers.
+ */
+public final class Command {
+    
+    public static final String MOVE = "MOVE";
+    public static final String HALT = "HALT";
+    public static final String HALT_ALL = "HALT_ALL";
+    public static final String CALIBRATE = "CALIBRATE";
+    public static final String EMERGENCY_STOP = "EMERGENCY_STOP";
+    
+    private final String type;
+    private final String targetCraneId;
+    private final double targetVelocity;
+    private final long timestampNs;
+    
+    public Command(String type, String targetCraneId, double targetVelocity) {
+        this(type, targetCraneId, targetVelocity, System.nanoTime());
+    }
+    
+    public Command(String type, String targetCraneId, double targetVelocity, long timestampNs) {
+        this.type = Objects.requireNonNull(type, "type cannot be null");
+        this.targetCraneId = targetCraneId;
+        this.targetVelocity = targetVelocity;
+        this.timestampNs = timestampNs;
+    }
+    
+    public static Command halt(String craneId) {
+        return new Command(HALT, craneId, 0.0);
+    }
+    
+    /**
+     * Creates a HALT_ALL command that stops both cranes simultaneously.
+     */
+    public static Command haltAll() {
+        return new Command(HALT_ALL, null, 0.0);
+    }
+    
+    public static Command emergencyStop() {
+        return new Command(EMERGENCY_STOP, null, 0.0);
+    }
+    
+    public static Command move(String craneId, double velocity) {
+        return new Command(MOVE, craneId, velocity);
+    }
+    
+    public static Command calibrate(String craneId) {
+        return new Command(CALIBRATE, craneId, 0.0);
+    }
+    
+    public String type() { return type; }
+    public String targetCraneId() { return targetCraneId; }
+    public double targetVelocity() { return targetVelocity; }
+    public long timestampNs() { return timestampNs; }
+    
+    public boolean isHaltCommand() {
+        return HALT.equals(type) || HALT_ALL.equals(type) || EMERGENCY_STOP.equals(type);
+    }
+    
+    public boolean isHaltAll() {
+        return HALT_ALL.equals(type);
+    }
+    
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Command command = (Command) o;
+        return Double.compare(command.targetVelocity, targetVelocity) == 0 &&
+               Objects.equals(type, command.type) &&
+               Objects.equals(targetCraneId, command.targetCraneId);
+    }
+    
+    @Override
+    public int hashCode() {
+        return Objects.hash(type, targetCraneId, targetVelocity);
+    }
+    
+    @Override
+    public String toString() {
+        return String.format("Command{type='%s', targetCraneId='%s', targetVelocity=%.2f}", 
+                           type, targetCraneId, targetVelocity);
+    }
+}
\ No newline at end of file
diff --git a/repository_after/src/main/java/com/porthorizon/crane/LiftState.java b/repository_after/src/main/java/com/porthorizon/crane/LiftState.java
new file mode 100644
index 0000000..df161b0
--- /dev/null
+++ b/repository_after/src/main/java/com/porthorizon/crane/LiftState.java
@@ -0,0 +1,36 @@
+package com.porthorizon.crane;
+
+/**
+ * Represents the operational state of the tandem lift system.
+ */
+public enum LiftState {
+    /**
+     * System is idle, no active lift operation.
+     */
+    IDLE,
+    
+    /**
+     * Active lift operation in progress.
+     */
+    LIFTING,
+    
+    /**
+     * Safety fault detected, all operations halted.
+     * Requires manual reset to exit this state.
+     */
+    FAULT;
+    
+    /**
+     * Checks if the state allows movement operations.
+     */
+    public boolean allowsMovement() {
+        return this == LIFTING;
+    }
+    
+    /**
+     * Checks if the state requires manual intervention.
+     */
+    public boolean requiresManualReset() {
+        return this == FAULT;
+    }
+}
\ No newline at end of file
diff --git a/repository_after/src/main/java/com/porthorizon/crane/LivenessWatchdog.java b/repository_after/src/main/java/com/porthorizon/crane/LivenessWatchdog.java
new file mode 100644
index 0000000..58958fd
--- /dev/null
+++ b/repository_after/src/main/java/com/porthorizon/crane/LivenessWatchdog.java
@@ -0,0 +1,190 @@
+package com.porthorizon.crane;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+import java.util.function.Consumer;
+
+/**
+ * Monitors liveness of crane telemetry streams.
+ * Triggers emergency shutdown if a crane fails to report within timeout.
+ */
+public class LivenessWatchdog {
+    
+    private static final long DEFAULT_TIMEOUT_NS = 150_000_000L; // 150ms
+    private static final long CHECK_INTERVAL_MS = 10; // Check every 10ms
+    
+    private final long timeoutNs;
+    private final AtomicLong lastUpdateCraneA = new AtomicLong(0);
+    private final AtomicLong lastUpdateCraneB = new AtomicLong(0);
+    private final AtomicBoolean running = new AtomicBoolean(false);
+    private final AtomicBoolean craneATimedOut = new AtomicBoolean(false);
+    private final AtomicBoolean craneBTimedOut = new AtomicBoolean(false);
+    
+    private final ScheduledExecutorService executor;
+    private ScheduledFuture<?> watchdogTask;
+    private Consumer<String> timeoutCallback;
+    
+    public LivenessWatchdog() {
+        this(DEFAULT_TIMEOUT_NS);
+    }
+    
+    public LivenessWatchdog(long timeoutNs) {
+        this.timeoutNs = timeoutNs;
+        this.executor = Executors.newSingleThreadScheduledExecutor(r -> {
+            Thread t = new Thread(r, "liveness-watchdog");
+            t.setDaemon(true);
+            t.setPriority(Thread.MAX_PRIORITY);
+            return t;
+        });
+    }
+    
+    /**
+     * Starts the watchdog monitoring.
+     */
+    public void start() {
+        if (running.compareAndSet(false, true)) {
+            long now = System.nanoTime();
+            lastUpdateCraneA.set(now);
+            lastUpdateCraneB.set(now);
+            craneATimedOut.set(false);
+            craneBTimedOut.set(false);
+            
+            watchdogTask = executor.scheduleAtFixedRate(
+                this::checkLiveness, 
+                CHECK_INTERVAL_MS, 
+                CHECK_INTERVAL_MS, 
+                TimeUnit.MILLISECONDS
+            );
+        }
+    }
+    
+    /**
+     * Stops the watchdog monitoring.
+     */
+    public void stop() {
+        if (running.compareAndSet(true, false)) {
+            if (watchdogTask != null) {
+                watchdogTask.cancel(false);
+                watchdogTask = null;
+            }
+        }
+    }
+    
+    /**
+     * Records a telemetry update from a crane.
+     */
+    public void recordUpdate(String craneId) {
+        recordUpdate(craneId, System.nanoTime());
+    }
+    
+    /**
+     * Records a telemetry update with specific timestamp.
+     */
+    public void recordUpdate(String craneId, long timestampNs) {
+        if (TelemetryPulse.CRANE_A.equals(craneId)) {
+            lastUpdateCraneA.set(timestampNs);
+            craneATimedOut.set(false);
+        } else if (TelemetryPulse.CRANE_B.equals(craneId)) {
+            lastUpdateCraneB.set(timestampNs);
+            craneBTimedOut.set(false);
+        }
+    }
+    
+    private void checkLiveness() {
+        if (!running.get()) return;
+        
+        long now = System.nanoTime();
+        long lastA = lastUpdateCraneA.get();
+        long lastB = lastUpdateCraneB.get();
+        
+        if (lastA > 0 && (now - lastA) > timeoutNs && !craneATimedOut.get()) {
+            craneATimedOut.set(true);
+            notifyTimeout(TelemetryPulse.CRANE_A);
+        }
+        
+        if (lastB > 0 && (now - lastB) > timeoutNs && !craneBTimedOut.get()) {
+            craneBTimedOut.set(true);
+            notifyTimeout(TelemetryPulse.CRANE_B);
+        }
+    }
+    
+    private void notifyTimeout(String craneId) {
+        if (timeoutCallback != null) {
+            timeoutCallback.accept(craneId);
+        }
+    }
+    
+    /**
+     * Sets the callback for timeout notifications.
+     */
+    public void setTimeoutCallback(Consumer<String> callback) {
+        this.timeoutCallback = callback;
+    }
+    
+    /**
+     * Checks if a specific crane has timed out.
+     */
+    public boolean hasTimedOut(String craneId) {
+        if (TelemetryPulse.CRANE_A.equals(craneId)) {
+            return craneATimedOut.get();
+        } else if (TelemetryPulse.CRANE_B.equals(craneId)) {
+            return craneBTimedOut.get();
+        }
+        return false;
+    }
+    
+    /**
+     * Checks if any crane has timed out.
+     */
+    public boolean hasAnyTimeout() {
+        return craneATimedOut.get() || craneBTimedOut.get();
+    }
+    
+    /**
+     * Gets the time since last update for a crane.
+     */
+    public long getTimeSinceLastUpdate(String craneId) {
+        long now = System.nanoTime();
+        if (TelemetryPulse.CRANE_A.equals(craneId)) {
+            return now - lastUpdateCraneA.get();
+        } else if (TelemetryPulse.CRANE_B.equals(craneId)) {
+            return now - lastUpdateCraneB.get();
+        }
+        return Long.MAX_VALUE;
+    }
+    
+    /**
+     * Resets the watchdog state.
+     */
+    public void reset() {
+        long now = System.nanoTime();
+        lastUpdateCraneA.set(now);
+        lastUpdateCraneB.set(now);
+        craneATimedOut.set(false);
+        craneBTimedOut.set(false);
+    }
+    
+    public boolean isRunning() {
+        return running.get();
+    }
+    
+    public long getTimeoutNs() {
+        return timeoutNs;
+    }
+    
+    /**
+     * Shuts down the watchdog executor.
+     */
+    public void shutdown() {
+        stop();
+        executor.shutdown();
+        try {
+            if (!executor.awaitTermination(100, TimeUnit.MILLISECONDS)) {
+                executor.shutdownNow();
+            }
+        } catch (InterruptedException e) {
+            executor.shutdownNow();
+            Thread.currentThread().interrupt();
+        }
+    }
+}
\ No newline at end of file
diff --git a/repository_after/src/main/java/com/porthorizon/crane/MotorController.java b/repository_after/src/main/java/com/porthorizon/crane/MotorController.java
new file mode 100644
index 0000000..c38835d
--- /dev/null
+++ b/repository_after/src/main/java/com/porthorizon/crane/MotorController.java
@@ -0,0 +1,25 @@
+package com.porthorizon.crane;
+
+/**
+ * Interface for motor controller communication.
+ */
+public interface MotorController {
+    
+    /**
+     * Sends a command to the motor controller.
+     * @param command The command to send
+     */
+    void sendCommand(Command command);
+    
+    /**
+     * Checks if the controller is connected and responsive.
+     * @return true if connected
+     */
+    boolean isConnected();
+    
+    /**
+     * Gets the crane ID this controller manages.
+     * @return crane identifier
+     */
+    String getCraneId();
+}
\ No newline at end of file
diff --git a/repository_after/src/main/java/com/porthorizon/crane/TandemSyncService.java b/repository_after/src/main/java/com/porthorizon/crane/TandemSyncService.java
new file mode 100644
index 0000000..761ec88
--- /dev/null
+++ b/repository_after/src/main/java/com/porthorizon/crane/TandemSyncService.java
@@ -0,0 +1,382 @@
+package com.porthorizon.crane;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+import java.util.function.Consumer;
+import java.util.List;
+import java.util.ArrayList;
+
+public class TandemSyncService {
+    
+    public static final double TILT_THRESHOLD_MM = 100.0;
+    public static final long LIVENESS_TIMEOUT_NS = 150_000_000L;
+    public static final long MAX_ALIGNMENT_DELTA_NS = 100_000_000L;
+    public static final long MAX_PROCESSING_WINDOW_NS = 10_000_000L;
+    private static final int BUFFER_SIZE = 8;
+    
+    private final AtomicReference<LiftState> state = new AtomicReference<>(LiftState.IDLE);
+    private final AtomicBoolean staleDataDetected = new AtomicBoolean(false);
+    private final AtomicLong thresholdCrossedTimestampNs = new AtomicLong(0);
+    private final AtomicLong haltIssuedTimestampNs = new AtomicLong(0);
+    
+    private final AtomicReferenceArray<TelemetryPulse> bufferA = new AtomicReferenceArray<>(BUFFER_SIZE);
+    private final AtomicReferenceArray<TelemetryPulse> bufferB = new AtomicReferenceArray<>(BUFFER_SIZE);
+    private final AtomicInteger indexA = new AtomicInteger(0);
+    private final AtomicInteger indexB = new AtomicInteger(0);
+    
+    private final AtomicReference<TelemetryPulse> latestCraneA = new AtomicReference<>();
+    private final AtomicReference<TelemetryPulse> latestCraneB = new AtomicReference<>();
+    
+    // Clock drift tracking
+    private final AtomicLong clockOffsetNs = new AtomicLong(0);
+    private final AtomicBoolean clockOffsetCalibrated = new AtomicBoolean(false);
+    private final AtomicLong lastCalibrationTimeNs = new AtomicLong(0);
+    private final AtomicLong clockDriftRateNsPerSec = new AtomicLong(0);
+    
+    private final MotorController motorControllerA;
+    private final MotorController motorControllerB;
+    private final LivenessWatchdog watchdog;
+    private final ExecutorService processingExecutor;
+    private final ConcurrentLinkedQueue<Command> commandHistory = new ConcurrentLinkedQueue<>();
+    
+    private final AtomicBoolean evaluationPending = new AtomicBoolean(false);
+    
+    private Consumer<Command> commandListener;
+    private Consumer<String> faultListener;
+    private Consumer<AlignedTelemetryPair> alignmentListener;
+    
+    public TandemSyncService(MotorController motorControllerA, MotorController motorControllerB) {
+        this.motorControllerA = motorControllerA;
+        this.motorControllerB = motorControllerB;
+        this.watchdog = new LivenessWatchdog(LIVENESS_TIMEOUT_NS);
+        
+        this.processingExecutor = Executors.newSingleThreadExecutor(r -> {
+            Thread t = new Thread(r, "telemetry-processor");
+            t.setDaemon(true);
+            t.setPriority(Thread.MAX_PRIORITY);
+            return t;
+        });
+        
+        watchdog.setTimeoutCallback(this::handleLivenessTimeout);
+    }
+    
+    private void handleLivenessTimeout(String craneId) {
+        triggerFault("Communication timeout: " + craneId);
+    }
+    
+    public void start() {
+        if (state.get() == LiftState.FAULT) {
+            throw new IllegalStateException("Cannot start: System in FAULT state. Call reset() first.");
+        }
+        if (state.compareAndSet(LiftState.IDLE, LiftState.LIFTING)) {
+            watchdog.start();
+        }
+    }
+    
+    public void stop() {
+        watchdog.stop();
+        state.set(LiftState.IDLE);
+    }
+    
+    public void reset() {
+        watchdog.stop();
+        watchdog.reset();
+        state.set(LiftState.IDLE);
+        staleDataDetected.set(false);
+        thresholdCrossedTimestampNs.set(0);
+        haltIssuedTimestampNs.set(0);
+        latestCraneA.set(null);
+        latestCraneB.set(null);
+        clearBuffers();
+        commandHistory.clear();
+    }
+    
+    private void clearBuffers() {
+        for (int i = 0; i < BUFFER_SIZE; i++) {
+            bufferA.set(i, null);
+            bufferB.set(i, null);
+        }
+        indexA.set(0);
+        indexB.set(0);
+    }
+    
+    /**
+     * Calibrate initial clock offset between two crane controllers.
+     * Call this with synchronized pulses from both cranes.
+     */
+    public void calibrateClockOffset(long craneATimestampNs, long craneBTimestampNs) {
+        clockOffsetNs.set(craneATimestampNs - craneBTimestampNs);
+        lastCalibrationTimeNs.set(System.nanoTime());
+        clockOffsetCalibrated.set(true);
+    }
+    
+    /**
+     * Update clock drift rate estimate based on new synchronized observations.
+     * This handles systematic clock drift over time.
+     */
+    public void updateClockDriftEstimate(long craneATimestampNs, long craneBTimestampNs) {
+        long currentOffset = craneATimestampNs - craneBTimestampNs;
+        long previousOffset = clockOffsetNs.get();
+        long calibrationTime = lastCalibrationTimeNs.get();
+        long now = System.nanoTime();
+        
+        if (calibrationTime > 0 && now > calibrationTime) {
+            long elapsedNs = now - calibrationTime;
+            long offsetChange = currentOffset - previousOffset;
+            
+            // Drift rate in nanoseconds per second
+            if (elapsedNs > 0) {
+                long driftRate = (offsetChange * 1_000_000_000L) / elapsedNs;
+                clockDriftRateNsPerSec.set(driftRate);
+            }
+        }
+        
+        clockOffsetNs.set(currentOffset);
+        lastCalibrationTimeNs.set(now);
+        clockOffsetCalibrated.set(true);
+    }
+    
+    /**
+     * Get adjusted timestamp for Crane-A accounting for clock drift.
+     */
+    public long getAdjustedTimestamp(TelemetryPulse pulse) {
+        if (!TelemetryPulse.CRANE_A.equals(pulse.craneId()) || !clockOffsetCalibrated.get()) {
+            return pulse.timestampNs();
+        }
+        
+        long offset = clockOffsetNs.get();
+        long driftRate = clockDriftRateNsPerSec.get();
+        long calibrationTime = lastCalibrationTimeNs.get();
+        long now = System.nanoTime();
+        
+        // Apply drift compensation if we have drift rate
+        if (driftRate != 0 && calibrationTime > 0) {
+            long elapsedSec = (now - calibrationTime) / 1_000_000_000L;
+            offset += driftRate * elapsedSec;
+        }
+        
+        return pulse.timestampNs() - offset;
+    }
+    
+    public void ingestTelemetry(TelemetryPulse pulse) {
+        long arrivalTime = System.nanoTime();
+        updatePulseState(pulse, arrivalTime);
+        
+        if (evaluationPending.compareAndSet(false, true)) {
+            CompletableFuture.runAsync(() -> {
+                try {
+                    evaluationPending.set(false);
+                    evaluateSafety();
+                } catch (Exception e) {
+                    evaluationPending.set(false);
+                }
+            }, processingExecutor);
+        }
+    }
+    
+    public void ingestTelemetrySync(TelemetryPulse pulse) {
+        long arrivalTime = System.nanoTime();
+        updatePulseState(pulse, arrivalTime);
+        evaluateSafety();
+    }
+    
+    public void ingestTelemetryWithArrival(TelemetryPulse pulse, long arrivalTimeNs) {
+        updatePulseState(pulse, arrivalTimeNs);
+        evaluateSafety();
+    }
+    
+    private void updatePulseState(TelemetryPulse pulse, long arrivalTime) {
+        if (state.get() == LiftState.FAULT) return;
+        
+        TelemetryPulse pulseWithArrival = new TelemetryPulse(
+            pulse.craneId(), pulse.zAxisMm(), pulse.timestampNs(), arrivalTime
+        );
+        
+        if (TelemetryPulse.CRANE_A.equals(pulse.craneId())) {
+            int idx = indexA.getAndIncrement() % BUFFER_SIZE;
+            bufferA.set(idx, pulseWithArrival);
+            updateIfNewer(latestCraneA, pulseWithArrival);
+            watchdog.recordUpdate(TelemetryPulse.CRANE_A, arrivalTime);
+        } else if (TelemetryPulse.CRANE_B.equals(pulse.craneId())) {
+            int idx = indexB.getAndIncrement() % BUFFER_SIZE;
+            bufferB.set(idx, pulseWithArrival);
+            updateIfNewer(latestCraneB, pulseWithArrival);
+            watchdog.recordUpdate(TelemetryPulse.CRANE_B, arrivalTime);
+        }
+    }
+    
+    private void updateIfNewer(AtomicReference<TelemetryPulse> ref, TelemetryPulse newPulse) {
+        ref.updateAndGet(current -> 
+            (current == null || newPulse.timestampNs() > current.timestampNs()) ? newPulse : current
+        );
+    }
+    
+    public AlignedTelemetryPair findClosestAlignedPair() {
+        TelemetryPulse bestA = null;
+        TelemetryPulse bestB = null;
+        long smallestGap = Long.MAX_VALUE;
+        long newestTimestamp = -1;
+        
+        for (int i = 0; i < BUFFER_SIZE; i++) {
+            TelemetryPulse pulseA = bufferA.get(i);
+            if (pulseA == null) continue;
+            
+            for (int j = 0; j < BUFFER_SIZE; j++) {
+                TelemetryPulse pulseB = bufferB.get(j);
+                if (pulseB == null) continue;
+                
+                long adjA = getAdjustedTimestamp(pulseA);
+                long adjB = getAdjustedTimestamp(pulseB);
+                long gap = Math.abs(adjA - adjB);
+                long pairTimestamp = Math.max(pulseA.timestampNs(), pulseB.timestampNs());
+                
+                if (gap < smallestGap || (gap == smallestGap && pairTimestamp > newestTimestamp)) {
+                    smallestGap = gap;
+                    newestTimestamp = pairTimestamp;
+                    bestA = pulseA;
+                    bestB = pulseB;
+                }
+            }
+        }
+        
+        return (bestA != null && bestB != null) ? new AlignedTelemetryPair(bestA, bestB) : null;
+    }
+    
+    public boolean hasStaleArrivalData() {
+        TelemetryPulse a = latestCraneA.get();
+        TelemetryPulse b = latestCraneB.get();
+        if (a == null || b == null) return false;
+        
+        long arrivalDelta = Math.abs(a.arrivalTimeNs() - b.arrivalTimeNs());
+        return arrivalDelta > MAX_ALIGNMENT_DELTA_NS;
+    }
+    
+    private void evaluateSafety() {
+        if (state.get() == LiftState.FAULT) return;
+        
+        AlignedTelemetryPair pair = findClosestAlignedPair();
+        if (pair == null) return;
+        
+        boolean timestampStale = !pair.isWellAligned(MAX_ALIGNMENT_DELTA_NS);
+        boolean arrivalStale = hasStaleArrivalData();
+        
+        if (timestampStale || arrivalStale) {
+            staleDataDetected.set(true);
+            if (alignmentListener != null) alignmentListener.accept(pair);
+            return;
+        }
+        staleDataDetected.set(false);
+        
+        double tiltDelta = pair.calculateTiltDeltaMm();
+        if (tiltDelta > TILT_THRESHOLD_MM) {
+            long crossedTime = System.nanoTime();
+            thresholdCrossedTimestampNs.set(crossedTime);
+            triggerFaultWithTiming(
+                String.format("Tilt threshold exceeded: %.2fmm > %.2fmm", tiltDelta, TILT_THRESHOLD_MM),
+                crossedTime
+            );
+        }
+        
+        if (alignmentListener != null) alignmentListener.accept(pair);
+    }
+    
+    private void triggerFaultWithTiming(String reason, long thresholdCrossedTime) {
+        LiftState previous = state.getAndSet(LiftState.FAULT);
+        
+        if (previous != LiftState.FAULT) {
+            Command haltAll = Command.haltAll();
+            motorControllerA.sendCommand(haltAll);
+            motorControllerB.sendCommand(haltAll);
+            long haltTime = System.nanoTime();
+            haltIssuedTimestampNs.set(haltTime);
+            
+            commandHistory.add(haltAll);
+            watchdog.stop();
+            
+            if (commandListener != null) commandListener.accept(haltAll);
+            if (faultListener != null) faultListener.accept(reason);
+        }
+    }
+    
+    private void triggerFault(String reason) {
+        triggerFaultWithTiming(reason, System.nanoTime());
+    }
+    
+    public boolean executeCommand(Command command) {
+        LiftState currentState = state.get();
+        
+        if (currentState == LiftState.FAULT && Command.MOVE.equals(command.type())) {
+            return false;
+        }
+        
+        if (staleDataDetected.get() && Command.MOVE.equals(command.type())) {
+            return false;
+        }
+        
+        commandHistory.add(command);
+        if (command.isHaltAll() || command.targetCraneId() == null) {
+            motorControllerA.sendCommand(command);
+            motorControllerB.sendCommand(command);
+        } else if (TelemetryPulse.CRANE_A.equals(command.targetCraneId())) {
+            motorControllerA.sendCommand(command);
+        } else if (TelemetryPulse.CRANE_B.equals(command.targetCraneId())) {
+            motorControllerB.sendCommand(command);
+        }
+        if (commandListener != null) commandListener.accept(command);
+        return true;
+    }
+    
+    public LiftState getState() { return state.get(); }
+    public boolean isStaleDataDetected() { return staleDataDetected.get(); }
+    
+    public TelemetryPulse getLatestPulse(String craneId) {
+        return TelemetryPulse.CRANE_A.equals(craneId) ? latestCraneA.get() : latestCraneB.get();
+    }
+    
+    public double calculateTiltDelta() {
+        TelemetryPulse a = latestCraneA.get(), b = latestCraneB.get();
+        return (a == null || b == null) ? 0.0 : Math.abs(a.zAxisMm() - b.zAxisMm());
+    }
+    
+    public AlignedTelemetryPair getAlignedPair() {
+        return findClosestAlignedPair();
+    }
+    
+    public long getProcessingTimeNs() {
+        long crossed = thresholdCrossedTimestampNs.get();
+        long halt = haltIssuedTimestampNs.get();
+        return (crossed > 0 && halt > 0) ? halt - crossed : 0;
+    }
+    
+    public boolean wasProcessingWithinWindow() {
+        long t = getProcessingTimeNs();
+        return t > 0 && t <= MAX_PROCESSING_WINDOW_NS;
+    }
+    
+    public long getThresholdCrossedTimestamp() { return thresholdCrossedTimestampNs.get(); }
+    public long getHaltIssuedTimestamp() { return haltIssuedTimestampNs.get(); }
+    public boolean isClockOffsetCalibrated() { return clockOffsetCalibrated.get(); }
+    public long getClockOffsetNs() { return clockOffsetNs.get(); }
+    public long getClockDriftRateNsPerSec() { return clockDriftRateNsPerSec.get(); }
+    
+    public List<Command> getCommandHistory() { return new ArrayList<>(commandHistory); }
+    public LivenessWatchdog getWatchdog() { return watchdog; }
+    
+    public void setCommandListener(Consumer<Command> l) { this.commandListener = l; }
+    public void setFaultListener(Consumer<String> l) { this.faultListener = l; }
+    public void setAlignmentListener(Consumer<AlignedTelemetryPair> l) { this.alignmentListener = l; }
+    
+    public void shutdown() {
+        stop();
+        watchdog.shutdown();
+        processingExecutor.shutdown();
+        try {
+            if (!processingExecutor.awaitTermination(100, TimeUnit.MILLISECONDS)) {
+                processingExecutor.shutdownNow();
+            }
+        } catch (InterruptedException e) {
+            processingExecutor.shutdownNow();
+            Thread.currentThread().interrupt();
+        }
+    }
+}
\ No newline at end of file
diff --git a/repository_after/src/main/java/com/porthorizon/crane/TelemetryPulse.java b/repository_after/src/main/java/com/porthorizon/crane/TelemetryPulse.java
new file mode 100644
index 0000000..9f0dea6
--- /dev/null
+++ b/repository_after/src/main/java/com/porthorizon/crane/TelemetryPulse.java
@@ -0,0 +1,62 @@
+package com.porthorizon.crane;
+
+import java.util.Objects;
+
+/**
+ * Represents a telemetry pulse from a gantry crane.
+ */
+public final class TelemetryPulse {
+    
+    public static final String CRANE_A = "CRANE-A";
+    public static final String CRANE_B = "CRANE-B";
+    
+    private final String craneId;
+    private final double zAxisMm;
+    private final long timestampNs;
+    private final long arrivalTimeNs;
+    
+    public TelemetryPulse(String craneId, double zAxisMm, long timestampNs) {
+        this(craneId, zAxisMm, timestampNs, System.nanoTime());
+    }
+    
+    public TelemetryPulse(String craneId, double zAxisMm, long timestampNs, long arrivalTimeNs) {
+        this.craneId = Objects.requireNonNull(craneId, "craneId cannot be null");
+        this.zAxisMm = zAxisMm;
+        this.timestampNs = timestampNs;
+        this.arrivalTimeNs = arrivalTimeNs;
+    }
+    
+    public String craneId() { return craneId; }
+    public double zAxisMm() { return zAxisMm; }
+    public long timestampNs() { return timestampNs; }
+    public long arrivalTimeNs() { return arrivalTimeNs; }
+    
+    /**
+     * Checks if this pulse is newer than another based on internal timestamp.
+     */
+    public boolean isNewerThan(TelemetryPulse other) {
+        if (other == null) return true;
+        return this.timestampNs > other.timestampNs;
+    }
+    
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        TelemetryPulse that = (TelemetryPulse) o;
+        return Double.compare(that.zAxisMm, zAxisMm) == 0 &&
+               timestampNs == that.timestampNs &&
+               Objects.equals(craneId, that.craneId);
+    }
+    
+    @Override
+    public int hashCode() {
+        return Objects.hash(craneId, zAxisMm, timestampNs);
+    }
+    
+    @Override
+    public String toString() {
+        return String.format("TelemetryPulse{craneId='%s', zAxisMm=%.2f, timestampNs=%d}", 
+                           craneId, zAxisMm, timestampNs);
+    }
+}
\ No newline at end of file
diff --git a/repository_after/target/classes/com/porthorizon/crane/AlignedTelemetryPair.class b/repository_after/target/classes/com/porthorizon/crane/AlignedTelemetryPair.class
new file mode 100644
index 0000000..ee169c9
Binary files /dev/null and b/repository_after/target/classes/com/porthorizon/crane/AlignedTelemetryPair.class differ
diff --git a/repository_after/target/classes/com/porthorizon/crane/Command.class b/repository_after/target/classes/com/porthorizon/crane/Command.class
new file mode 100644
index 0000000..de6d7c3
Binary files /dev/null and b/repository_after/target/classes/com/porthorizon/crane/Command.class differ
diff --git a/repository_after/target/classes/com/porthorizon/crane/LiftState.class b/repository_after/target/classes/com/porthorizon/crane/LiftState.class
new file mode 100644
index 0000000..89fd382
Binary files /dev/null and b/repository_after/target/classes/com/porthorizon/crane/LiftState.class differ
diff --git a/repository_after/target/classes/com/porthorizon/crane/LivenessWatchdog.class b/repository_after/target/classes/com/porthorizon/crane/LivenessWatchdog.class
new file mode 100644
index 0000000..60e2695
Binary files /dev/null and b/repository_after/target/classes/com/porthorizon/crane/LivenessWatchdog.class differ
diff --git a/repository_after/target/classes/com/porthorizon/crane/MotorController.class b/repository_after/target/classes/com/porthorizon/crane/MotorController.class
new file mode 100644
index 0000000..26474af
Binary files /dev/null and b/repository_after/target/classes/com/porthorizon/crane/MotorController.class differ
diff --git a/repository_after/target/classes/com/porthorizon/crane/TandemSyncService.class b/repository_after/target/classes/com/porthorizon/crane/TandemSyncService.class
new file mode 100644
index 0000000..4cf99c1
Binary files /dev/null and b/repository_after/target/classes/com/porthorizon/crane/TandemSyncService.class differ
diff --git a/repository_after/target/classes/com/porthorizon/crane/TelemetryPulse.class b/repository_after/target/classes/com/porthorizon/crane/TelemetryPulse.class
new file mode 100644
index 0000000..a50b1d9
Binary files /dev/null and b/repository_after/target/classes/com/porthorizon/crane/TelemetryPulse.class differ
diff --git a/repository_after/target/crane-sync-orchestrator-1.0.0.jar b/repository_after/target/crane-sync-orchestrator-1.0.0.jar
new file mode 100644
index 0000000..f9d2531
Binary files /dev/null and b/repository_after/target/crane-sync-orchestrator-1.0.0.jar differ
diff --git a/repository_after/target/eval-classes/Evaluation$TestEntry.class b/repository_after/target/eval-classes/Evaluation$TestEntry.class
new file mode 100644
index 0000000..f4a4efa
Binary files /dev/null and b/repository_after/target/eval-classes/Evaluation$TestEntry.class differ
diff --git a/repository_after/target/eval-classes/Evaluation$TestResults.class b/repository_after/target/eval-classes/Evaluation$TestResults.class
new file mode 100644
index 0000000..6f28a86
Binary files /dev/null and b/repository_after/target/eval-classes/Evaluation$TestResults.class differ
diff --git a/repository_after/target/eval-classes/Evaluation.class b/repository_after/target/eval-classes/Evaluation.class
new file mode 100644
index 0000000..c927819
Binary files /dev/null and b/repository_after/target/eval-classes/Evaluation.class differ
diff --git a/repository_after/target/maven-archiver/pom.properties b/repository_after/target/maven-archiver/pom.properties
new file mode 100644
index 0000000..81bb307
--- /dev/null
+++ b/repository_after/target/maven-archiver/pom.properties
@@ -0,0 +1,3 @@
+artifactId=crane-sync-orchestrator
+groupId=com.porthorizon
+version=1.0.0
diff --git a/repository_after/target/maven-status/maven-compiler-plugin/compile/default-compile/createdFiles.lst b/repository_after/target/maven-status/maven-compiler-plugin/compile/default-compile/createdFiles.lst
new file mode 100644
index 0000000..1af171f
--- /dev/null
+++ b/repository_after/target/maven-status/maven-compiler-plugin/compile/default-compile/createdFiles.lst
@@ -0,0 +1,7 @@
+com/porthorizon/crane/LiftState.class
+com/porthorizon/crane/MotorController.class
+com/porthorizon/crane/AlignedTelemetryPair.class
+com/porthorizon/crane/TelemetryPulse.class
+com/porthorizon/crane/Command.class
+com/porthorizon/crane/TandemSyncService.class
+com/porthorizon/crane/LivenessWatchdog.class
diff --git a/repository_after/target/maven-status/maven-compiler-plugin/compile/default-compile/inputFiles.lst b/repository_after/target/maven-status/maven-compiler-plugin/compile/default-compile/inputFiles.lst
new file mode 100644
index 0000000..3f19738
--- /dev/null
+++ b/repository_after/target/maven-status/maven-compiler-plugin/compile/default-compile/inputFiles.lst
@@ -0,0 +1,7 @@
+/app/repository_after/src/main/java/com/porthorizon/crane/MotorController.java
+/app/repository_after/src/main/java/com/porthorizon/crane/TandemSyncService.java
+/app/repository_after/src/main/java/com/porthorizon/crane/LivenessWatchdog.java
+/app/repository_after/src/main/java/com/porthorizon/crane/AlignedTelemetryPair.java
+/app/repository_after/src/main/java/com/porthorizon/crane/TelemetryPulse.java
+/app/repository_after/src/main/java/com/porthorizon/crane/Command.java
+/app/repository_after/src/main/java/com/porthorizon/crane/LiftState.java
diff --git a/repository_after/target/test-classes/DriftSimulationTest.class b/repository_after/target/test-classes/DriftSimulationTest.class
new file mode 100644
index 0000000..4a02ff7
Binary files /dev/null and b/repository_after/target/test-classes/DriftSimulationTest.class differ
diff --git a/repository_after/target/test-classes/JitterResilienceTest.class b/repository_after/target/test-classes/JitterResilienceTest.class
new file mode 100644
index 0000000..8bdc992
Binary files /dev/null and b/repository_after/target/test-classes/JitterResilienceTest.class differ
diff --git a/repository_after/target/test-classes/LivenessWatchdogTest.class b/repository_after/target/test-classes/LivenessWatchdogTest.class
new file mode 100644
index 0000000..f500a27
Binary files /dev/null and b/repository_after/target/test-classes/LivenessWatchdogTest.class differ
diff --git a/repository_after/target/test-classes/RequirementsTest.class b/repository_after/target/test-classes/RequirementsTest.class
new file mode 100644
index 0000000..6d42535
Binary files /dev/null and b/repository_after/target/test-classes/RequirementsTest.class differ
diff --git a/repository_after/target/test-classes/TandemSyncServiceTest.class b/repository_after/target/test-classes/TandemSyncServiceTest.class
new file mode 100644
index 0000000..71519b1
Binary files /dev/null and b/repository_after/target/test-classes/TandemSyncServiceTest.class differ
diff --git a/repository_after/target/test-classes/com/porthorizon/crane/MockMotorController.class b/repository_after/target/test-classes/com/porthorizon/crane/MockMotorController.class
new file mode 100644
index 0000000..235aaae
Binary files /dev/null and b/repository_after/target/test-classes/com/porthorizon/crane/MockMotorController.class differ
