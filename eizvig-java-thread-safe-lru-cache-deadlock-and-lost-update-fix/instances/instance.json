{
    "instance_id": "EIZVIG",
    "problem_statement": "Load testing revealed the LRU cache throws ConcurrentModificationException intermittently under high concurrency. QA found cases where cache.get() returned null immediately after a successful put() for the same key. Memory monitoring shows the cache sometimes holds more entries than its configured maximum of 10,000. The application deadlocked twice during overnight stress tests, with thread dumps showing threads blocked on cache operations in opposite lock order. Debug logging revealed the internal size counter went negative after a burst of concurrent removes. The cache implementation is in LRUCache.java with node structure in CacheEntry.java.",
    "base_commit": "repository_before/",
    "test_patch": "tests/",
    "github_url": "https://github.com/ep-eaglepoint-ai/bd_datasets_003/tree/main/eizvig-java-thread-safe-lru-cache-deadlock-and-lost-update-fix",
    "environment_setup": "Dockerfile",
    "FAIL_TO_PASS": [
        "com.example.cache.LRUCacheTest::testConcurrentAccess",
        "com.example.cache.LRUCacheTest::testConcurrentGetPutRemoveDeadlock",
        "com.example.cache.LRUCacheTest::testInternalConsistency"
    ],
    "PASS_TO_PASS": [
        "com.example.cache.LRUCacheTest::testPutAndGet",
        "com.example.cache.LRUCacheTest::testGetNonExistent",
        "com.example.cache.LRUCacheTest::testEviction",
        "com.example.cache.LRUCacheTest::testUpdateMovesToFront",
        "com.example.cache.LRUCacheTest::testRemove",
        "com.example.cache.LRUCacheTest::testRemoveNonExistent",
        "com.example.cache.LRUCacheTest::testClear",
        "com.example.cache.LRUCacheTest::testSizeLimit",
        "com.example.cache.LRUCacheTest::testPointersClearedAfterRemoval",
        "com.example.cache.LRUCacheTest::testConcurrentClear"
    ]
}