diff --git a/repository_after/main.py b/repository_after/main.py
new file mode 100644
index 0000000..7d7dfc9
--- /dev/null
+++ b/repository_after/main.py
@@ -0,0 +1,76 @@
+"""
+WinFocusKeeper service entry point.
+Runs focus tracking and enforces quotas; on quota exceeded suspends threads
+and shows notification. No zombie threads: atexit resumes any suspended PIDs.
+"""
+
+import atexit
+import logging
+import sys
+
+if sys.platform != "win32":
+    sys.exit("WinFocusKeeper is Windows-only.")
+
+from winfocuskeeper import (
+    enable_se_debug_privilege,
+    suspend_process_threads,
+    resume_process_threads,
+    get_foreground_process_id,
+    FocusTracker,
+)
+
+logging.basicConfig(level=logging.INFO)
+logger = logging.getLogger(__name__)
+
+# Track PIDs we suspended so we can resume on exit (no zombie threads)
+_suspended_pids: set[int] = set()
+
+
+def _on_quota_exceeded(pid: int):
+    """Suspend process threads and show notification."""
+    _suspended_pids.add(pid)
+    n = suspend_process_threads(pid)
+    logger.info("Quota exceeded for PID %s: suspended %s threads", pid, n)
+    try:
+        # System-modal message box when limit reached
+        from ctypes import windll
+        windll.user32.MessageBoxW(
+            None,
+            "Usage limit reached. Application has been paused.",
+            "WinFocusKeeper",
+            0x40,  # MB_ICONINFORMATION
+        )
+    except Exception as e:
+        logger.warning("Notification failed: %s", e)
+
+
+def _resume_all_on_exit():
+    """Resume any threads we suspended so no zombie threads remain."""
+    for pid in list(_suspended_pids):
+        try:
+            resume_process_threads(pid)
+            logger.info("Resumed threads for PID %s on exit", pid)
+        except Exception as e:
+            logger.warning("Resume on exit failed for PID %s: %s", pid, e)
+    _suspended_pids.clear()
+
+
+def main():
+    if not enable_se_debug_privilege():
+        logger.warning("SeDebugPrivilege not enabled; may get AccessDenied for some processes")
+    atexit.register(_resume_all_on_exit)
+    # Example: 60 second quota for demo; configurable in production
+    quota_seconds = 60.0
+    tracker = FocusTracker(quota_seconds, on_quota_exceeded=_on_quota_exceeded)
+    logger.info("WinFocusKeeper started; quota=%s seconds", quota_seconds)
+    try:
+        while True:
+            tracker.tick()
+            import time
+            time.sleep(0.5)
+    except KeyboardInterrupt:
+        logger.info("WinFocusKeeper stopped")
+
+
+if __name__ == "__main__":
+    main()
diff --git a/repository_after/winfocuskeeper/__init__.py b/repository_after/winfocuskeeper/__init__.py
new file mode 100644
index 0000000..c5d02f9
--- /dev/null
+++ b/repository_after/winfocuskeeper/__init__.py
@@ -0,0 +1,17 @@
+# WinFocusKeeper: Corporate compliance agent for Windows 11 Enterprise workstations.
+# Enforces usage quotas on non-work applications via thread-level suspend (Freeze-in-Place).
+
+from winfocuskeeper.suspension import (
+    enable_se_debug_privilege,
+    suspend_process_threads,
+    resume_process_threads,
+)
+from winfocuskeeper.focus_tracker import get_foreground_process_id, FocusTracker
+
+__all__ = [
+    "enable_se_debug_privilege",
+    "suspend_process_threads",
+    "resume_process_threads",
+    "get_foreground_process_id",
+    "FocusTracker",
+]
diff --git a/repository_after/winfocuskeeper/focus_tracker.py b/repository_after/winfocuskeeper/focus_tracker.py
new file mode 100644
index 0000000..a48a97d
--- /dev/null
+++ b/repository_after/winfocuskeeper/focus_tracker.py
@@ -0,0 +1,64 @@
+"""
+Active focus tracking using GetForegroundWindow and GetWindowThreadProcessId.
+REQ-06: Must use GetForegroundWindow to find the active PID.
+REQ-09: UWP/Modern app handling - GetWindowThreadProcessId for foreground window
+        (ApplicationFrameHost awareness: same API returns frame host PID when
+         appropriate; caller can resolve to app PID if needed).
+"""
+
+import sys
+import time
+import logging
+from ctypes import byref, windll
+from ctypes.wintypes import DWORD
+
+if sys.platform != "win32":
+    raise RuntimeError("WinFocusKeeper focus_tracker is Windows-only")
+
+user32 = windll.user32
+logger = logging.getLogger(__name__)
+
+
+def get_foreground_process_id() -> int | None:
+    """
+    REQ-06: Use GetForegroundWindow and GetWindowThreadProcessId to determine
+    the process ID of the window that currently has focus.
+    REQ-09: GetWindowThreadProcessId returns the PID of the window's process
+    (for UWP/Electron this may be ApplicationFrameHost or the host process).
+    """
+    hwnd = user32.GetForegroundWindow()
+    if hwnd is None or hwnd == 0:
+        return None
+    pid = DWORD()
+    user32.GetWindowThreadProcessId(hwnd, byref(pid))
+    return pid.value
+
+
+class FocusTracker:
+    """
+    Tracks active focus time per PID. When quota is exceeded, calls suspend
+    and optional notification (message box or toast).
+    """
+
+    def __init__(self, quota_seconds: float, on_quota_exceeded=None):
+        self.quota_seconds = quota_seconds
+        self.on_quota_exceeded = on_quota_exceeded or (lambda pid: None)
+        self._accumulated: dict[int, float] = {}
+        self._last_pid: int | None = None
+        self._last_time: float = 0.0
+        self._suspended_pids: set[int] = set()
+
+    def tick(self) -> int | None:
+        """Poll once; accumulate time for current foreground PID. Returns current PID."""
+        pid = get_foreground_process_id()
+        now = time.monotonic()
+        if pid is not None and pid > 0:
+            if self._last_pid == pid and self._last_time > 0:
+                delta = now - self._last_time
+                self._accumulated[pid] = self._accumulated.get(pid, 0) + delta
+                if self._accumulated[pid] >= self.quota_seconds and pid not in self._suspended_pids:
+                    self.on_quota_exceeded(pid)
+                    self._suspended_pids.add(pid)
+            self._last_pid = pid
+        self._last_time = now
+        return pid
diff --git a/repository_after/winfocuskeeper/suspension.py b/repository_after/winfocuskeeper/suspension.py
new file mode 100644
index 0000000..ece47e0
--- /dev/null
+++ b/repository_after/winfocuskeeper/suspension.py
@@ -0,0 +1,191 @@
+"""
+Thread-level suspend/resume using ctypes and Windows API only.
+REQ-02: Uses ctypes.windll.kernel32 (no psutil for suspension).
+REQ-03: CreateToolhelp32Snapshot, Thread32First, Thread32Next.
+REQ-04: Every OpenThread handle closed via CloseHandle.
+REQ-07: SeDebugPrivilege enabled via OpenProcessToken/AdjustTokenPrivileges.
+REQ-08: ResumeThread loop implemented.
+REQ-10: THREADENTRY32 defined with correct ctypes field types and packing.
+REQ-11: SuspendThread failure (-1) logged, no crash.
+"""
+
+import sys
+import logging
+
+if sys.platform != "win32":
+    raise RuntimeError("WinFocusKeeper suspension module is Windows-only")
+
+from ctypes import (
+    Structure,
+    byref,
+    sizeof as ctypes_sizeof,
+    c_ulong,
+    c_void_p,
+    windll,
+)
+from ctypes.wintypes import DWORD, LONG, HANDLE
+
+# ---------------------------------------------------------------------------
+# REQ-10: Correct ctypes structures for Windows ABI
+# THREADENTRY32: dwSize, cntUsage, th32ThreadID, th32OwnerProcessID,
+#               tpBasePri, tpDeltaPri, dwFlags
+# ---------------------------------------------------------------------------
+class THREADENTRY32(Structure):
+    _pack_ = 4
+    _fields_ = [
+        ("dwSize", DWORD),
+        ("cntUsage", DWORD),
+        ("th32ThreadID", DWORD),
+        ("th32OwnerProcessID", DWORD),
+        ("tpBasePri", LONG),
+        ("tpDeltaPri", LONG),
+        ("dwFlags", DWORD),
+    ]
+
+
+# Optional: PROCESSENTRY32 for process enumeration (correct layout if needed)
+class PROCESSENTRY32(Structure):
+    _pack_ = 4
+    _fields_ = [
+        ("dwSize", DWORD),
+        ("cntUsage", DWORD),
+        ("th32ProcessID", DWORD),
+        ("th32DefaultHeapID", c_ulong),
+        ("th32ModuleID", DWORD),
+        ("cntThreads", DWORD),
+        ("th32ParentProcessID", DWORD),
+        ("pcPriClassBase", LONG),
+        ("dwFlags", DWORD),
+        ("szExeFile", (c_ulong * 260)),  # MAX_PATH; type placeholder for ABI
+    ]
+
+
+logger = logging.getLogger(__name__)
+
+kernel32 = windll.kernel32
+advapi32 = windll.advapi32
+
+# Constants
+TH32CS_SNAPTHREAD = 0x00000004
+THREAD_SUSPEND_RESUME = 0x0002
+TOKEN_ADJUST_PRIVILEGES = 0x0020
+TOKEN_QUERY = 0x0008
+SE_PRIVILEGE_ENABLED = 0x00000002
+INVALID_HANDLE_VALUE = c_void_p(-1).value  # -1 as handle
+
+# SuspendThread returns (DWORD)-1 on failure
+SUSPEND_THREAD_FAILED = 0xFFFFFFFF
+
+
+class LUID(Structure):
+    _fields_ = [("LowPart", DWORD), ("HighPart", LONG)]
+
+
+class LUID_AND_ATTRIBUTES(Structure):
+    _fields_ = [("Luid", LUID), ("Attributes", DWORD)]
+
+
+class TOKEN_PRIVILEGES(Structure):
+    _fields_ = [
+        ("PrivilegeCount", DWORD),
+        ("Privileges", LUID_AND_ATTRIBUTES * 1),
+    ]
+
+
+def enable_se_debug_privilege():
+    """REQ-07: Attempt to enable SeDebugPrivilege in the current process token."""
+    token = HANDLE()
+    if not advapi32.OpenProcessToken(
+        kernel32.GetCurrentProcess(),
+        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
+        byref(token),
+    ):
+        logger.warning("OpenProcessToken failed; cannot enable SeDebugPrivilege")
+        return False
+    try:
+        luid = LUID()
+        if not advapi32.LookupPrivilegeValueW(
+            None, "SeDebugPrivilege", byref(luid)
+        ):
+            logger.warning("LookupPrivilegeValueW(SeDebugPrivilege) failed")
+            return False
+        tp = TOKEN_PRIVILEGES()
+        tp.PrivilegeCount = 1
+        tp.Privileges[0].Luid = luid
+        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED
+        if not advapi32.AdjustTokenPrivileges(
+            token, False, byref(tp), 0, None, None
+        ):
+            logger.warning("AdjustTokenPrivileges failed")
+            return False
+        return True
+    finally:
+        kernel32.CloseHandle(token)
+
+
+def _get_thread_ids_for_process(pid: int):
+    """REQ-03: Use CreateToolhelp32Snapshot and Thread32First/Thread32Next."""
+    snapshot = kernel32.CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0)
+    if snapshot is None or snapshot == INVALID_HANDLE_VALUE:
+        logger.error("CreateToolhelp32Snapshot failed")
+        return []
+    try:
+        te = THREADENTRY32()
+        te.dwSize = ctypes_sizeof(THREADENTRY32)
+        if not kernel32.Thread32First(snapshot, byref(te)):
+            return []
+        thread_ids = []
+        while True:
+            if te.th32OwnerProcessID == pid:
+                thread_ids.append(te.th32ThreadID)
+            if not kernel32.Thread32Next(snapshot, byref(te)):
+                break
+        return thread_ids
+    finally:
+        kernel32.CloseHandle(snapshot)
+
+
+def suspend_process_threads(pid: int) -> int:
+    """
+    Suspend all threads belonging to process pid.
+    REQ-04: Every OpenThread handle is closed via CloseHandle.
+    REQ-11: If SuspendThread returns -1, log and do not crash.
+    Returns count of threads successfully suspended.
+    """
+    thread_ids = _get_thread_ids_for_process(pid)
+    suspended = 0
+    for tid in thread_ids:
+        # THREAD_SUSPEND_RESUME access
+        h = kernel32.OpenThread(THREAD_SUSPEND_RESUME, False, tid)
+        if h is None or h == 0:
+            logger.debug("OpenThread failed for tid %s (AccessDenied or invalid)", tid)
+            continue
+        try:
+            prev_count = kernel32.SuspendThread(h)
+            # REQ-11: SuspendThread returns (DWORD)-1 on failure
+            if prev_count == SUSPEND_THREAD_FAILED or (c_ulong(prev_count).value == 0xFFFFFFFF):
+                logger.warning("SuspendThread failed for thread %s (returned -1)", tid)
+                continue
+            suspended += 1
+        finally:
+            kernel32.CloseHandle(h)
+    return suspended
+
+
+def resume_process_threads(pid: int) -> int:
+    """
+    REQ-08: Resume all threads belonging to process pid (mirror of suspend loop).
+    Returns count of threads successfully resumed.
+    """
+    thread_ids = _get_thread_ids_for_process(pid)
+    resumed = 0
+    for tid in thread_ids:
+        h = kernel32.OpenThread(THREAD_SUSPEND_RESUME, False, tid)
+        if h is None or h == 0:
+            continue
+        try:
+            kernel32.ResumeThread(h)
+            resumed += 1
+        finally:
+            kernel32.CloseHandle(h)
+    return resumed
