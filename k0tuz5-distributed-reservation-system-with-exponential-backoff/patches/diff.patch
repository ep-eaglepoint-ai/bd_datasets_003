diff --git a/repository_after/client/client.go b/repository_after/client/client.go
new file mode 100644
index 0000000..68113fb
--- /dev/null
+++ b/repository_after/client/client.go
@@ -0,0 +1,109 @@
+package main
+
+import (
+	"bytes"
+	"encoding/json"
+	"log"
+	"math/rand"
+	"net/http"
+	"os"
+	"reservation-system/repository_after/model"
+	"sync"
+	"time"
+)
+
+const (
+	defaultServerURL = "http://localhost:8080"
+	maxRetries       = 5
+	baseBackoff      = 100 * time.Millisecond
+)
+
+func main() {
+	RunClient()
+}
+
+func RunClient() {
+	rand.New(rand.NewSource(time.Now().UnixNano()))
+
+	var wg sync.WaitGroup
+	httpClient := &http.Client{
+		Timeout: 2 * time.Second,
+	}
+
+	for i := 0; i < 50; i++ {
+		wg.Add(1)
+		go func(workerID int) {
+			defer wg.Done()
+			AttemptReserve(httpClient, workerID)
+		}(i)
+	}
+
+	wg.Wait()
+	log.Println("Client finished all requests")
+}
+
+func getServerUrl() string {
+	if url := os.Getenv("SERVER_URL"); url != "" {
+		return url
+	}
+	return defaultServerURL
+}
+
+func AttemptReserve(client *http.Client, workerID int) {
+	payload := model.ReserveRequest{
+		ResourceID: "item-1",
+		Quantity:   1,
+	}
+
+	body, err := json.Marshal(payload)
+	if err != nil {
+		log.Printf("[worker %d] JSON marshal error: %v", workerID, err)
+		return
+	}
+
+	for attempt := 0; attempt < maxRetries; attempt++ {
+		url := getServerUrl()
+		req, err := http.NewRequest(http.MethodPost, url+"/reserve", bytes.NewBuffer(body))
+		if err != nil {
+			log.Printf("[worker %d] request creation error: %v", workerID, err)
+			return
+		}
+		req.Header.Set("Content-Type", "application/json")
+
+		resp, err := client.Do(req)
+		if err != nil {
+			log.Printf("[worker %d] connection error: %v", workerID, err)
+			Backoff(attempt)
+			continue
+		}
+
+		resp.Body.Close()
+
+		if resp.StatusCode == http.StatusOK {
+			log.Printf("[worker %d] reservation successful", workerID)
+			return
+		}
+
+		if resp.StatusCode == http.StatusConflict {
+			log.Printf("[worker %d] stock exhausted (409)", workerID)
+			return
+		}
+
+		if resp.StatusCode == http.StatusTooManyRequests || resp.StatusCode >= 500 {
+			log.Printf("[worker %d] retryable error %d", workerID, resp.StatusCode)
+			Backoff(attempt)
+			continue
+		}
+
+		log.Printf("[worker %d] unexpected status %d", workerID, resp.StatusCode)
+		return
+	}
+
+	log.Printf("[worker %d] failed after %d attempts", workerID, maxRetries)
+}
+
+func Backoff(attempt int) {
+	exp := baseBackoff * time.Duration(1<<attempt)
+	jitter := time.Duration(rand.Int63n(int64(exp / 2)))
+	time.Sleep(exp + jitter)
+}
diff --git a/repository_after/model/inventory.go b/repository_after/model/inventory.go
new file mode 100644
index 0000000..16ed1af
--- /dev/null
+++ b/repository_after/model/inventory.go
@@ -0,0 +1,48 @@
+package model
+
+import (
+	"sync"
+	"time"
+)
+
+type ReserveRequest struct {
+	ResourceID string `json:"resource_id"`
+	Quantity   int    `json:"quantity"`
+}
+
+type Inventory struct {
+	Mu    sync.Mutex
+	Items map[string]int
+}
+
+type RateLimiter struct {
+	Mu        sync.Mutex
+	Count     int
+	LastReset time.Time
+	Limit     int
+}
+
+func NewRateLimiter(limit int) *RateLimiter {
+	return &RateLimiter{
+		Limit:     limit,
+		LastReset: time.Now(),
+	}
+}
+
+func (r *RateLimiter) Allow() bool {
+	r.Mu.Lock()
+	defer r.Mu.Unlock()
+
+	now := time.Now()
+	if now.Sub(r.LastReset) >= time.Second {
+		r.Count = 0
+		r.LastReset = now
+	}
+
+	if r.Count >= r.Limit {
+		return false
+	}
+
+	r.Count++
+	return true
+}
diff --git a/repository_after/server/main.go b/repository_after/server/main.go
new file mode 100644
index 0000000..7a15162
--- /dev/null
+++ b/repository_after/server/main.go
@@ -0,0 +1,62 @@
+package main
+
+import (
+	"encoding/json"
+	"log"
+	"net/http"
+
+	"reservation-system/repository_after/model"
+)
+
+func main() {
+	inventory := &model.Inventory{
+		Items: map[string]int{
+			"item-1": 50,
+		},
+	}
+
+	rateLimiter := model.NewRateLimiter(50)
+
+	http.HandleFunc("/reserve", func(w http.ResponseWriter, r *http.Request) {
+		if r.Method != http.MethodPost {
+			w.WriteHeader(http.StatusMethodNotAllowed)
+			return
+		}
+
+		if !rateLimiter.Allow() {
+			http.Error(w, "rate limit exceeded", http.StatusTooManyRequests)
+			return
+		}
+
+		defer r.Body.Close()
+
+		var req model.ReserveRequest
+		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
+			http.Error(w, "invalid json payload", http.StatusBadRequest)
+			return
+		}
+
+		if req.Quantity <= 0 {
+			http.Error(w, "quantity must be positive", http.StatusBadRequest)
+			return
+		}
+
+		inventory.Mu.Lock()
+		defer inventory.Mu.Unlock()
+
+		current := inventory.Items[req.ResourceID]
+		if current < req.Quantity {
+			http.Error(w, "insufficient stock", http.StatusConflict)
+			return
+		}
+
+		inventory.Items[req.ResourceID] -= req.Quantity
+		log.Printf("Stock after: %d", inventory.Items[req.ResourceID])
+
+		w.WriteHeader(http.StatusOK)
+		w.Write([]byte("reservation successful"))
+	})
+
+	log.Println("Server listening on :8080")
+	log.Fatal(http.ListenAndServe(":8080", nil))
+}
