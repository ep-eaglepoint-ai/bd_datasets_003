Trajectory Template
â€‹
Trajectory (Thinking Process for Refactoring)
1.â€‹ Audit the Original Code (Identify Scaling Problems)â€‹
I audited the original code. It loaded full tables into memory for
filtering and sorting, applied pagination too late, repeatedly
recalculated deal values, and used N+1 queries â€” all of which would not
scale.â€‹
Learn about the N+1 query problem and why itâ€™s bad:â€‹
https://youtu.be/lptxhwzJK1gâ€‹
â€‹
Practical article explaining N+1 and how to fix it: Optimizing Database
Queries: Avoiding the N+1 Query Problem
Link:
https://michaelkasingye.medium.com/optimizing-database-queries-avoiding-the-n-
1-query-problem-438476198983
2.â€‹ Define a Performance Contract Firstâ€‹
I defined performance conditions: filtering and ordering must remain in
the database, ordering must be stable, use keyset pagination, forbid N+1
patterns, avoid per-request aggregations.â€‹
https://youtu.be/o25GCdzw8hsâ€‹
3.â€‹ Rework the Data Model for Efficiencyâ€‹
I introduced a new ContactMetrics table storing precomputed cached
values like deal value and interaction count. This prevents expensive
joins on heavy tables.â€‹
â€‹
You can see more about SQL optimization basics here: Practical
strategies for SQL refactoring, joins, indexes and ORM best practices
Link:
https://horkan.com/2024/08/19/practical-strategies-for-optimising-sql-refactoring-indexing-and-orm-best-practices?utmâ€‹
4.â€‹ Rebuild the Search as a Projection-First Pipelineâ€‹
The pipeline now selects only essential fields into lightweight shapes,
reducing expensive ORM entity materialization.â€‹
5.â€‹ Move Filters to the Database (Server-Side)â€‹
All filters (city, date, deal stage, minimum value) now translate into
SQL predicates that benefit from existing indexes.â€‹
6.â€‹ Use EXISTS Instead of Cartesian Joins / Heavy Tag Filteringâ€‹
Tag filtering now uses an EXISTS subquery instead of eager collection
loads to prevent exploding result sets.â€‹
7.â€‹ Stable Ordering + Keyset Paginationâ€‹
I implemented stable ordering and keyset pagination.â€‹
Learn why OFFSET hurts performance and how keyset pagination
drastically improves efficiency:â€‹
â€‹
https://youtu.be/rhOVF82KY7Eâ€‹
8.â€‹ Eliminate N+1 Queries for Enrichmentâ€‹
I eliminated N+1 patterns by batching related fetches. For a page of
contacts, tags are loaded in one follow-up query rather than one per
contact.â€‹
â€‹
Detailed strategies for spotting and fixing N+1 (ORM or SQL based) are
covered here: How to efficiently solve the N+1 query problem
Link:
https://www.pingcap.com/article/how-to-efficiently-solve-the-n1-query-pr
oblem/?utmâ€‹
9.â€‹ Normalize for Case-Insensitive Searchesâ€‹
Added a normalized version (e.g., NormalizedName) for tags to ensure
consistent case-insensitive filtering without function calls that kill
indexes.â€‹10.â€‹Result: Measurable Performance Gains + Predictable Signalsâ€‹
The solution consistently uses two queries per request, never touches
heavy tables during search, stays index-friendly, and exhibits
measurable performance improvements (fewer query scans, fast keyset
pagination, no N+1 patterns).
Trajectory Transferability Notes
The above trajectory is designed for Refactoring. The steps outlined in it
represent reusable thinking nodes (audit, contract definition, structural
changes, execution, and verification).
The same nodes can be reused to transfer this trajectory to other hard-work
categories (such as full-stack development, performance optimization, testing,
and code generation) by changing the focus of each node, not the structure.
Below are the nodes extracted from this trajectory. These nodes act as a
template that can be mapped to other categories by adapting the inputs,
constraints, and validation signals specific to each task type.
ğŸ”¹ Refactoring â†’ Full-Stack Development
â—â€‹ Replace code audit with system & product flow auditâ€‹
â—â€‹ Performance contract becomes API, UX, and data contractsâ€‹
â—â€‹ Data model refactor extends to DTOs and frontend state shapeâ€‹
â—â€‹ Query optimization maps to API payload shapingâ€‹
â—â€‹ Pagination applies to backend + UI (cursor / infinite scroll)â€‹
â—â€‹ Add API schemas, frontend data flow, and latency budgetsâ€‹ğŸ”¹ Refactoring â†’ Performance Optimization
â—â€‹ Code audit becomes runtime profiling & bottleneck detectionâ€‹
â—â€‹ Performance contract expands to SLOs, SLAs, latency budgetsâ€‹
â—â€‹ Data model changes include indexes, caches, async pathsâ€‹
â—â€‹ Query refactors focus on hot pathsâ€‹
â—â€‹ Verification uses metrics, benchmarks, and load testsâ€‹
â—â€‹ Add observability tools and before/after measurementsâ€‹
ğŸ”¹ Refactoring â†’ Testing
â—â€‹ Code audit becomes test coverage & risk auditâ€‹
â—â€‹ Performance contract becomes test strategy & guaranteesâ€‹
â—â€‹ Data assumptions convert to fixtures and factoriesâ€‹
â—â€‹ Stable ordering maps to deterministic testsâ€‹
â—â€‹ Final verification becomes assertions & invariantsâ€‹
â—â€‹ Add test pyramid placement and edge-case coverageâ€‹
ğŸ”¹ Refactoring â†’ Code Generation
â—â€‹ Code audit becomes requirements & input analysisâ€‹
â—â€‹ Performance contract becomes generation constraintsâ€‹
â—â€‹ Data model refactor becomes domain model scaffoldingâ€‹â—â€‹ Projection-first thinking becomes minimal, composable outputâ€‹
â—â€‹ Verification ensures style, correctness, and maintainabilityâ€‹
â—â€‹ Add input/output specs and post-generation validationâ€‹
Core Principle (Applies to All)
â—â€‹ The trajectory structure stays the sameâ€‹
â—â€‹ Only the focus and artifacts changeâ€‹
â—â€‹ Audit â†’ Contract â†’ Design â†’ Execute â†’ Verify remains constant