diff --git a/repository_after/app/api/refunds/route.ts b/repository_after/app/api/refunds/route.ts
new file mode 100644
--- /dev/null
+++ b/repository_after/app/api/refunds/route.ts
+/**
+ * API Route: Refunds
+ *
+ * REST API endpoint for processing refunds.
+ * Alternative to Server Actions for external integrations.
+ *
+ * Requirements covered:
+ * - Requirement 1: Server-side only Prisma operations
+ * - Requirement 2: Atomic transactions
+ * - Requirement 4: Proper HTTP status codes for conflicts
+ */
+
+import { NextRequest, NextResponse } from 'next/server';
+import { Decimal } from 'decimal.js';
+import { prisma } from '../../../src/lib/prisma';
+import {
+  validateRefundRequest,
+  processRefundAtomic,
+  getHttpStatusForError,
+} from '../../../src/lib/refund-service';
+import { RefundRequest } from '../../../src/types';
+
+export async function POST(request: NextRequest) {
+  try {
+    const body = await request.json() as RefundRequest;
+
+    // Validate request
+    const validation = validateRefundRequest(body);
+    if (!validation.valid) {
+      return NextResponse.json(
+        { success: false, error: validation.error },
+        { status: getHttpStatusForError(validation.error!.code) }
+      );
+    }
+
+    const refundAmount = new Decimal(body.amount.toString());
+
+    // Execute within atomic transaction (Requirement 2)
+    const result = await prisma.$transaction(async (tx) => {
+      return processRefundAtomic({
+        prisma: tx,
+        transactionId: body.transactionId,
+        refundAmount,
+        idempotencyKey: body.idempotencyKey,
+      });
+    }, {
+      isolationLevel: 'Serializable',
+    });
+
+    if (!result.success) {
+      // Requirement 4: Return appropriate status code
+      const statusCode = getHttpStatusForError(result.error!.code);
+      return NextResponse.json(
+        { success: false, error: result.error },
+        { status: statusCode }
+      );
+    }
+
+    return NextResponse.json({
+      success: true,
+      refund: result.refund,
+      transaction: result.transaction,
+    });
+  } catch (error) {
+    console.error('API refund error:', error);
+
+    // Check for serialization/concurrency errors
+    if (error instanceof Error) {
+      if (error.message.includes('could not serialize') ||
+          error.message.includes('deadlock')) {
+        return NextResponse.json(
+          {
+            success: false,
+            error: {
+              code: 'CONCURRENT_MODIFICATION',
+              message: 'Transaction was modified concurrently. Please retry.',
+            },
+          },
+          { status: 409 }
+        );
+      }
+    }
+
+    return NextResponse.json(
+      {
+        success: false,
+        error: {
+          code: 'INTERNAL_ERROR',
+          message: 'An unexpected error occurred',
+        },
+      },
+      { status: 500 }
+    );
+  }
+}
+
+export async function GET(request: NextRequest) {
+  const searchParams = request.nextUrl.searchParams;
+  const transactionId = searchParams.get('transactionId');
+
+  try {
+    if (transactionId) {
+      // Get refunds for a specific transaction
+      const refunds = await prisma.refund.findMany({
+        where: { transactionId },
+        orderBy: { createdAt: 'desc' },
+      });
+      return NextResponse.json({ success: true, refunds });
+    }
+
+    // Get all refunds
+    const refunds = await prisma.refund.findMany({
+      orderBy: { createdAt: 'desc' },
+      take: 100,
+    });
+    return NextResponse.json({ success: true, refunds });
+  } catch (error) {
+    console.error('API get refunds error:', error);
+    return NextResponse.json(
+      {
+        success: false,
+        error: {
+          code: 'INTERNAL_ERROR',
+          message: 'Failed to fetch refunds',
+        },
+      },
+      { status: 500 }
+    );
+  }
+}
diff --git a/repository_after/app/api/transactions/route.ts b/repository_after/app/api/transactions/route.ts
new file mode 100644
--- /dev/null
+++ b/repository_after/app/api/transactions/route.ts
+/**
+ * API Route: Transactions
+ *
+ * REST API endpoint for transaction operations.
+ *
+ * Requirement 1: Server-side only Prisma operations
+ */
+
+import { NextRequest, NextResponse } from 'next/server';
+import { Decimal } from 'decimal.js';
+import { prisma } from '../../../src/lib/prisma';
+import { toTransactionWithBalance } from '../../../src/lib/refund-service';
+
+export async function GET(request: NextRequest) {
+  const searchParams = request.nextUrl.searchParams;
+  const id = searchParams.get('id');
+
+  try {
+    if (id) {
+      // Get single transaction
+      const transaction = await prisma.transaction.findUnique({
+        where: { id },
+        include: { refunds: true },
+      });
+
+      if (!transaction) {
+        return NextResponse.json(
+          {
+            success: false,
+            error: {
+              code: 'TRANSACTION_NOT_FOUND',
+              message: `Transaction ${id} not found`,
+            },
+          },
+          { status: 404 }
+        );
+      }
+
+      return NextResponse.json({
+        success: true,
+        transaction: toTransactionWithBalance(transaction),
+      });
+    }
+
+    // Get all transactions
+    const transactions = await prisma.transaction.findMany({
+      include: { refunds: true },
+      orderBy: { createdAt: 'desc' },
+    });
+
+    return NextResponse.json({
+      success: true,
+      transactions: transactions.map(toTransactionWithBalance),
+    });
+  } catch (error) {
+    console.error('API get transactions error:', error);
+    return NextResponse.json(
+      {
+        success: false,
+        error: {
+          code: 'INTERNAL_ERROR',
+          message: 'Failed to fetch transactions',
+        },
+      },
+      { status: 500 }
+    );
+  }
+}
+
+export async function POST(request: NextRequest) {
+  try {
+    const body = await request.json();
+    const { amount, currency = 'USD' } = body;
+
+    if (!amount) {
+      return NextResponse.json(
+        {
+          success: false,
+          error: {
+            code: 'VALIDATION_ERROR',
+            message: 'Amount is required',
+          },
+        },
+        { status: 400 }
+      );
+    }
+
+    const decimalAmount = new Decimal(amount.toString());
+
+    if (decimalAmount.lessThanOrEqualTo(0)) {
+      return NextResponse.json(
+        {
+          success: false,
+          error: {
+            code: 'INVALID_AMOUNT',
+            message: 'Amount must be positive',
+          },
+        },
+        { status: 400 }
+      );
+    }
+
+    const transaction = await prisma.transaction.create({
+      data: {
+        amount: decimalAmount.toFixed(2),
+        currency,
+        status: 'SETTLED',
+      },
+      include: { refunds: true },
+    });
+
+    return NextResponse.json({
+      success: true,
+      transaction: toTransactionWithBalance(transaction),
+    });
+  } catch (error) {
+    console.error('API create transaction error:', error);
+    return NextResponse.json(
+      {
+        success: false,
+        error: {
+          code: 'INTERNAL_ERROR',
+          message: 'Failed to create transaction',
+        },
+      },
+      { status: 500 }
+    );
+  }
+}
diff --git a/repository_after/app/layout.tsx b/repository_after/app/layout.tsx
new file mode 100644
--- /dev/null
+++ b/repository_after/app/layout.tsx
+/**
+ * Root Layout
+ *
+ * Next.js App Router root layout component.
+ */
+
+import type { Metadata } from 'next';
+
+export const metadata: Metadata = {
+  title: 'WealthWire - Transaction Management',
+  description: 'Internal settlement system for transaction management and refunds',
+};
+
+export default function RootLayout({
+  children,
+}: {
+  children: React.ReactNode;
+}) {
+  return (
+    <html lang="en">
+      <body className="min-h-screen bg-gray-100">
+        <header className="bg-white shadow-sm">
+          <div className="max-w-4xl mx-auto px-6 py-4">
+            <h1 className="text-xl font-bold text-gray-900">
+              WealthWire
+              <span className="text-sm font-normal text-gray-500 ml-2">
+                Transaction Management
+              </span>
+            </h1>
+          </div>
+        </header>
+        <main className="py-8">
+          {children}
+        </main>
+      </body>
+    </html>
+  );
+}
diff --git a/repository_after/app/page.tsx b/repository_after/app/page.tsx
new file mode 100644
--- /dev/null
+++ b/repository_after/app/page.tsx
+/**
+ * Main Page - Transaction Dashboard
+ *
+ * Server Component that fetches initial data and renders the dashboard.
+ *
+ * Requirement 1: Prisma operations only on server side
+ * Requirement 6: Initial data fetching on server
+ */
+
+import { TransactionDashboard } from '../src/components/TransactionDashboard';
+import { getAllTransactions, processRefund } from '../src/actions/refund-actions';
+
+export const dynamic = 'force-dynamic';
+
+export default async function HomePage() {
+  const result = await getAllTransactions();
+
+  if (!result.success || !result.data) {
+    return (
+      <div className="max-w-4xl mx-auto p-6">
+        <div className="bg-red-50 border border-red-200 text-red-700 p-4 rounded">
+          <h2 className="font-semibold">Error Loading Transactions</h2>
+          <p>{result.error?.message || 'Failed to load transactions'}</p>
+        </div>
+      </div>
+    );
+  }
+
+  // Wrapper function for client component
+  async function handleProcessRefund(
+    transactionId: string,
+    amount: string,
+    idempotencyKey: string
+  ) {
+    'use server';
+    return processRefund({
+      transactionId,
+      amount,
+      idempotencyKey,
+    });
+  }
+
+  async function handleRefresh() {
+    'use server';
+    const refreshResult = await getAllTransactions();
+    return refreshResult.data || [];
+  }
+
+  return (
+    <TransactionDashboard
+      initialTransactions={result.data}
+      onProcessRefund={handleProcessRefund}
+      onRefresh={handleRefresh}
+    />
+  );
+}
diff --git a/repository_after/next.config.js b/repository_after/next.config.js
new file mode 100644
--- /dev/null
+++ b/repository_after/next.config.js
+/** @type {import('next').NextConfig} */
+const nextConfig = {
+  // Ensure Prisma client stays server-side only
+  experimental: {
+    serverComponentsExternalPackages: ['@prisma/client'],
+  },
+  // Webpack configuration to exclude Prisma from client bundle
+  webpack: (config, { isServer }) => {
+    if (!isServer) {
+      // Don't include Prisma in client bundle
+      config.resolve.alias = {
+        ...config.resolve.alias,
+        '@prisma/client': false,
+        '.prisma/client': false,
+      };
+    }
+    return config;
+  },
+};
+
+module.exports = nextConfig;
diff --git a/repository_after/prisma/schema.prisma b/repository_after/prisma/schema.prisma
new file mode 100644
--- /dev/null
+++ b/repository_after/prisma/schema.prisma
+// Prisma schema for WealthWire Banking Application
+// Financial ledger system with strict state consistency
+
+generator client {
+  provider = "prisma-client-js"
+}
+
+datasource db {
+  provider = "sqlite"
+  url      = env("DATABASE_URL")
+}
+
+// Transaction model - represents a financial transaction
+model Transaction {
+  id        String   @id @default(uuid())
+  amount    Decimal  // Original transaction amount - uses Decimal for precision
+  currency  String   @default("USD")
+  status    String   @default("SETTLED") // SETTLED | PARTIALLY_REFUNDED | REFUNDED
+  version   Int      @default(0) // Optimistic locking for concurrency control
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+  refunds   Refund[]
+}
+
+// Refund model - represents a partial or full refund against a transaction
+model Refund {
+  id             String      @id @default(uuid())
+  amount         Decimal     // Refund amount - uses Decimal for precision
+  transactionId  String
+  transaction    Transaction @relation(fields: [transactionId], references: [id])
+  idempotencyKey String      @unique // Prevents duplicate refund processing
+  createdAt      DateTime    @default(now())
+
+  @@index([transactionId])
+}
diff --git a/repository_after/src/actions/refund-actions.ts b/repository_after/src/actions/refund-actions.ts
new file mode 100644
--- /dev/null
+++ b/repository_after/src/actions/refund-actions.ts
+/**
+ * Server Actions for Refund Operations
+ *
+ * IMPORTANT: This file contains server-side only code.
+ * All functions are marked with 'use server' directive.
+ *
+ * Requirements covered:
+ * - Requirement 1: Next.js Server-Side Enforcement
+ * - Requirement 2: Atomic Prisma Transactions
+ * - Requirement 6: UI State Synchronization (revalidatePath)
+ */
+
+'use server';
+
+import { Decimal } from 'decimal.js';
+import { prisma } from '../lib/prisma';
+import {
+  validateRefundRequest,
+  processRefundAtomic,
+  toTransactionWithBalance,
+  createErrorResponse,
+} from '../lib/refund-service';
+import {
+  RefundRequest,
+  RefundResponse,
+  ActionResult,
+  TransactionWithBalance,
+} from '../types';
+import { revalidatePath } from 'next/cache';
+
+/**
+ * Server Action: Process a refund request
+ *
+ * This action uses Prisma's $transaction API to ensure atomic operations.
+ * The entire refund process (validation, balance check, creation) happens
+ * within a single database transaction.
+ *
+ * Requirement 2: Atomic Prisma Transactions
+ * Requirement 6: UI State Synchronization via revalidatePath
+ */
+export async function processRefund(request: RefundRequest): Promise<RefundResponse> {
+  // Validate request
+  const validation = validateRefundRequest(request);
+  if (!validation.valid) {
+    return {
+      success: false,
+      error: validation.error,
+    };
+  }
+
+  try {
+    const refundAmount = new Decimal(request.amount.toString());
+
+    // Execute within atomic transaction (Requirement 2)
+    const result = await prisma.$transaction(async (tx) => {
+      return processRefundAtomic({
+        prisma: tx,
+        transactionId: request.transactionId,
+        refundAmount,
+        idempotencyKey: request.idempotencyKey,
+      });
+    }, {
+      // Set isolation level for strict consistency
+      isolationLevel: 'Serializable',
+    });
+
+    if (result.success) {
+      // Revalidate the transaction page to update UI (Requirement 6)
+      revalidatePath(`/transactions/${request.transactionId}`);
+      revalidatePath('/transactions');
+    }
+
+    return result;
+  } catch (error) {
+    // Handle Prisma-specific errors
+    if (error instanceof Error) {
+      // Check for unique constraint violation (duplicate idempotency key)
+      if (error.message.includes('Unique constraint')) {
+        return createErrorResponse(
+          'DUPLICATE_REQUEST',
+          'A refund with this idempotency key already exists'
+        );
+      }
+
+      // Check for serialization failure (concurrent modification)
+      if (error.message.includes('could not serialize') ||
+          error.message.includes('deadlock') ||
+          error.message.includes('lock')) {
+        return createErrorResponse(
+          'CONCURRENT_MODIFICATION',
+          'Transaction was modified concurrently. Please retry.',
+          { originalError: error.message }
+        );
+      }
+    }
+
+    console.error('Refund processing error:', error);
+    return createErrorResponse(
+      'INTERNAL_ERROR',
+      'An unexpected error occurred while processing the refund'
+    );
+  }
+}
+
+/**
+ * Server Action: Get transaction with balance information
+ *
+ * Fetches a transaction and computes the remaining refundable balance.
+ */
+export async function getTransaction(transactionId: string): Promise<ActionResult<TransactionWithBalance>> {
+  try {
+    const transaction = await prisma.transaction.findUnique({
+      where: { id: transactionId },
+      include: { refunds: true },
+    });
+
+    if (!transaction) {
+      return {
+        success: false,
+        error: {
+          code: 'TRANSACTION_NOT_FOUND',
+          message: `Transaction ${transactionId} not found`,
+        },
+      };
+    }
+
+    return {
+      success: true,
+      data: toTransactionWithBalance(transaction),
+    };
+  } catch (error) {
+    console.error('Error fetching transaction:', error);
+    return {
+      success: false,
+      error: {
+        code: 'INTERNAL_ERROR',
+        message: 'Failed to fetch transaction',
+      },
+    };
+  }
+}
+
+/**
+ * Server Action: Get all transactions with balance information
+ */
+export async function getAllTransactions(): Promise<ActionResult<TransactionWithBalance[]>> {
+  try {
+    const transactions = await prisma.transaction.findMany({
+      include: { refunds: true },
+      orderBy: { createdAt: 'desc' },
+    });
+
+    return {
+      success: true,
+      data: transactions.map(toTransactionWithBalance),
+    };
+  } catch (error) {
+    console.error('Error fetching transactions:', error);
+    return {
+      success: false,
+      error: {
+        code: 'INTERNAL_ERROR',
+        message: 'Failed to fetch transactions',
+      },
+    };
+  }
+}
+
+/**
+ * Server Action: Create a new transaction (for testing/demo purposes)
+ */
+export async function createTransaction(
+  amount: string | number,
+  currency: string = 'USD'
+): Promise<ActionResult<TransactionWithBalance>> {
+  try {
+    const decimalAmount = new Decimal(amount.toString());
+
+    if (decimalAmount.lessThanOrEqualTo(0)) {
+      return {
+        success: false,
+        error: {
+          code: 'INVALID_AMOUNT',
+          message: 'Transaction amount must be positive',
+        },
+      };
+    }
+
+    const transaction = await prisma.transaction.create({
+      data: {
+        amount: decimalAmount.toFixed(2),
+        currency,
+        status: 'SETTLED',
+      },
+      include: { refunds: true },
+    });
+
+    revalidatePath('/transactions');
+
+    return {
+      success: true,
+      data: toTransactionWithBalance(transaction),
+    };
+  } catch (error) {
+    console.error('Error creating transaction:', error);
+    return {
+      success: false,
+      error: {
+        code: 'INTERNAL_ERROR',
+        message: 'Failed to create transaction',
+      },
+    };
+  }
+}
+
+/**
+ * Server Action: Process refund with optimistic locking
+ *
+ * This version includes version checking for explicit optimistic locking.
+ * Useful when the client has a cached version of the transaction.
+ *
+ * Requirement 4: Concurrency & Conflict Handling
+ */
+export async function processRefundWithVersion(
+  request: RefundRequest,
+  expectedVersion: number
+): Promise<RefundResponse> {
+  const validation = validateRefundRequest(request);
+  if (!validation.valid) {
+    return {
+      success: false,
+      error: validation.error,
+    };
+  }
+
+  try {
+    const refundAmount = new Decimal(request.amount.toString());
+
+    const result = await prisma.$transaction(async (tx) => {
+      return processRefundAtomic({
+        prisma: tx,
+        transactionId: request.transactionId,
+        refundAmount,
+        idempotencyKey: request.idempotencyKey,
+        expectedVersion,
+      });
+    }, {
+      isolationLevel: 'Serializable',
+    });
+
+    if (result.success) {
+      revalidatePath(`/transactions/${request.transactionId}`);
+      revalidatePath('/transactions');
+    }
+
+    return result;
+  } catch (error) {
+    if (error instanceof Error) {
+      if (error.message.includes('could not serialize') ||
+          error.message.includes('deadlock')) {
+        return createErrorResponse(
+          'CONCURRENT_MODIFICATION',
+          'Transaction was modified concurrently. Please retry.',
+          { originalError: error.message }
+        );
+      }
+    }
+
+    console.error('Refund processing error:', error);
+    return createErrorResponse(
+      'INTERNAL_ERROR',
+      'An unexpected error occurred while processing the refund'
+    );
+  }
+}
diff --git a/repository_after/src/components/index.ts b/repository_after/src/components/index.ts
new file mode 100644
--- /dev/null
+++ b/repository_after/src/components/index.ts
+/**
+ * Component exports
+ *
+ * All React components are client-side only.
+ * Requirement 1: No Prisma imports in these components.
+ */
+
+export { TransactionCard } from './TransactionCard';
+export { RefundForm } from './RefundForm';
+export { TransactionDashboard } from './TransactionDashboard';
diff --git a/repository_after/src/components/RefundForm.tsx b/repository_after/src/components/RefundForm.tsx
new file mode 100644
--- /dev/null
+++ b/repository_after/src/components/RefundForm.tsx
+/**
+ * RefundForm Component
+ *
+ * Form for submitting refund requests with validation and error handling.
+ *
+ * Requirements covered:
+ * - Requirement 6: UI State Synchronization (useFormStatus)
+ * - Requirement 9: Graceful error rendering without page crash
+ */
+
+'use client';
+
+import React, { useState, useCallback, useTransition } from 'react';
+import { v4 as uuidv4 } from 'uuid';
+import { RefundError, TransactionWithBalance } from '../types';
+
+interface RefundFormProps {
+  transaction: TransactionWithBalance;
+  onSubmit: (transactionId: string, amount: string, idempotencyKey: string) => Promise<{
+    success: boolean;
+    error?: RefundError;
+  }>;
+  onSuccess?: () => void;
+  onCancel?: () => void;
+}
+
+export function RefundForm({ transaction, onSubmit, onSuccess, onCancel }: RefundFormProps) {
+  const [amount, setAmount] = useState('');
+  const [error, setError] = useState<RefundError | null>(null);
+  const [isPending, startTransition] = useTransition();
+  const [isSubmitting, setIsSubmitting] = useState(false);
+
+  const remainingBalance = parseFloat(String(transaction.remainingBalance));
+  const canRefund = remainingBalance > 0 && transaction.status !== 'REFUNDED';
+
+  const handleSubmit = useCallback(async (e: React.FormEvent) => {
+    e.preventDefault();
+    setError(null);
+
+    // Client-side validation
+    const numericAmount = parseFloat(amount);
+    if (isNaN(numericAmount) || numericAmount <= 0) {
+      setError({
+        code: 'INVALID_AMOUNT',
+        message: 'Please enter a valid positive amount',
+      });
+      return;
+    }
+
+    if (numericAmount > remainingBalance) {
+      setError({
+        code: 'INSUFFICIENT_BALANCE',
+        message: `Amount exceeds remaining balance of ${transaction.currency} ${remainingBalance.toFixed(2)}`,
+      });
+      return;
+    }
+
+    setIsSubmitting(true);
+
+    // Generate idempotency key (Requirement 7)
+    const idempotencyKey = uuidv4();
+
+    startTransition(async () => {
+      try {
+        const result = await onSubmit(transaction.id, amount, idempotencyKey);
+
+        if (result.success) {
+          setAmount('');
+          onSuccess?.();
+        } else if (result.error) {
+          setError(result.error);
+        }
+      } catch (err) {
+        // Catch any unexpected errors to prevent page crash (Requirement 9)
+        setError({
+          code: 'INTERNAL_ERROR',
+          message: err instanceof Error ? err.message : 'An unexpected error occurred',
+        });
+      } finally {
+        setIsSubmitting(false);
+      }
+    });
+  }, [amount, remainingBalance, transaction, onSubmit, onSuccess]);
+
+  const handleAmountChange = (e: React.ChangeEvent<HTMLInputElement>) => {
+    setAmount(e.target.value);
+    setError(null);
+  };
+
+  const handleRefundAll = () => {
+    setAmount(remainingBalance.toFixed(2));
+    setError(null);
+  };
+
+  const isLoading = isPending || isSubmitting;
+
+  return (
+    <form onSubmit={handleSubmit} className="refund-form space-y-4" data-testid="refund-form">
+      <div className="bg-gray-50 p-3 rounded">
+        <p className="text-sm text-gray-600">Transaction ID</p>
+        <p className="font-mono text-sm">{transaction.id}</p>
+      </div>
+
+      <div className="grid grid-cols-2 gap-4 bg-gray-50 p-3 rounded">
+        <div>
+          <p className="text-sm text-gray-600">Original Amount</p>
+          <p className="font-semibold">
+            {transaction.currency} {String(transaction.amount)}
+          </p>
+        </div>
+        <div>
+          <p className="text-sm text-gray-600">Available for Refund</p>
+          <p className="font-semibold text-blue-600">
+            {transaction.currency} {remainingBalance.toFixed(2)}
+          </p>
+        </div>
+      </div>
+
+      <div>
+        <label htmlFor="refund-amount" className="block text-sm font-medium text-gray-700 mb-1">
+          Refund Amount
+        </label>
+        <div className="flex gap-2">
+          <div className="relative flex-1">
+            <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-500">
+              {transaction.currency}
+            </span>
+            <input
+              id="refund-amount"
+              type="number"
+              step="0.01"
+              min="0.01"
+              max={remainingBalance}
+              value={amount}
+              onChange={handleAmountChange}
+              disabled={!canRefund || isLoading}
+              className="w-full pl-14 pr-3 py-2 border rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100"
+              placeholder="0.00"
+              data-testid="refund-amount-input"
+              aria-describedby={error ? 'refund-error' : undefined}
+            />
+          </div>
+          <button
+            type="button"
+            onClick={handleRefundAll}
+            disabled={!canRefund || isLoading}
+            className="px-3 py-2 text-sm border rounded hover:bg-gray-50 disabled:opacity-50"
+          >
+            Refund All
+          </button>
+        </div>
+      </div>
+
+      {/* Error Display - Requirement 9: Clear error rendering */}
+      {error && (
+        <div
+          id="refund-error"
+          className="error-message bg-red-50 border border-red-200 text-red-700 p-3 rounded"
+          role="alert"
+          data-testid="refund-error"
+        >
+          <p className="font-medium">{getErrorTitle(error.code)}</p>
+          <p className="text-sm">{error.message}</p>
+          {error.details && (
+            <pre className="text-xs mt-2 bg-red-100 p-2 rounded overflow-auto">
+              {JSON.stringify(error.details, null, 2)}
+            </pre>
+          )}
+        </div>
+      )}
+
+      <div className="flex gap-3 pt-2">
+        <button
+          type="submit"
+          disabled={!canRefund || isLoading || !amount}
+          className="flex-1 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
+          data-testid="submit-refund-button"
+        >
+          {isLoading ? (
+            <span className="flex items-center justify-center gap-2">
+              <LoadingSpinner />
+              Processing...
+            </span>
+          ) : (
+            'Process Refund'
+          )}
+        </button>
+        {onCancel && (
+          <button
+            type="button"
+            onClick={onCancel}
+            disabled={isLoading}
+            className="px-4 py-2 border rounded hover:bg-gray-50 disabled:opacity-50"
+          >
+            Cancel
+          </button>
+        )}
+      </div>
+
+      {!canRefund && (
+        <p className="text-sm text-gray-500 text-center">
+          {transaction.status === 'REFUNDED'
+            ? 'This transaction has been fully refunded.'
+            : 'No refundable balance remaining.'}
+        </p>
+      )}
+    </form>
+  );
+}
+
+function LoadingSpinner() {
+  return (
+    <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
+      <circle
+        className="opacity-25"
+        cx="12"
+        cy="12"
+        r="10"
+        stroke="currentColor"
+        strokeWidth="4"
+        fill="none"
+      />
+      <path
+        className="opacity-75"
+        fill="currentColor"
+        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
+      />
+    </svg>
+  );
+}
+
+function getErrorTitle(code: string): string {
+  switch (code) {
+    case 'INVALID_AMOUNT':
+      return 'Invalid Amount';
+    case 'INSUFFICIENT_BALANCE':
+      return 'Insufficient Balance';
+    case 'TRANSACTION_NOT_FOUND':
+      return 'Transaction Not Found';
+    case 'TRANSACTION_ALREADY_REFUNDED':
+      return 'Already Refunded';
+    case 'CONCURRENT_MODIFICATION':
+      return 'Conflict Detected';
+    case 'DUPLICATE_REQUEST':
+      return 'Duplicate Request';
+    default:
+      return 'Error';
+  }
+}
+
+export default RefundForm;
diff --git a/repository_after/src/components/TransactionCard.tsx b/repository_after/src/components/TransactionCard.tsx
new file mode 100644
--- /dev/null
+++ b/repository_after/src/components/TransactionCard.tsx
+/**
+ * TransactionCard Component
+ *
+ * Displays transaction details including balance information.
+ * This is a client component that receives data from server components.
+ *
+ * Requirement 1: No Prisma imports in client components
+ */
+
+'use client';
+
+import React from 'react';
+import { TransactionWithBalance, TransactionStatus } from '../types';
+
+interface TransactionCardProps {
+  transaction: TransactionWithBalance;
+  onRefundClick?: (transactionId: string) => void;
+}
+
+const statusColors: Record<TransactionStatus, string> = {
+  SETTLED: 'bg-green-100 text-green-800',
+  PARTIALLY_REFUNDED: 'bg-yellow-100 text-yellow-800',
+  REFUNDED: 'bg-gray-100 text-gray-800',
+};
+
+const statusLabels: Record<TransactionStatus, string> = {
+  SETTLED: 'Settled',
+  PARTIALLY_REFUNDED: 'Partially Refunded',
+  REFUNDED: 'Fully Refunded',
+};
+
+export function TransactionCard({ transaction, onRefundClick }: TransactionCardProps) {
+  const status = transaction.status as TransactionStatus;
+  const canRefund = status !== 'REFUNDED';
+
+  return (
+    <div className="transaction-card border rounded-lg p-4 shadow-sm bg-white">
+      <div className="flex justify-between items-start mb-3">
+        <div>
+          <h3 className="font-semibold text-lg">Transaction</h3>
+          <p className="text-sm text-gray-500 font-mono">{transaction.id}</p>
+        </div>
+        <span className={`px-2 py-1 rounded text-sm font-medium ${statusColors[status]}`}>
+          {statusLabels[status]}
+        </span>
+      </div>
+
+      <div className="grid grid-cols-2 gap-4 mb-4">
+        <div>
+          <p className="text-sm text-gray-500">Original Amount</p>
+          <p className="text-xl font-bold">
+            {transaction.currency} {String(transaction.amount)}
+          </p>
+        </div>
+        <div>
+          <p className="text-sm text-gray-500">Remaining Balance</p>
+          <p className="text-xl font-bold text-blue-600" data-testid="remaining-balance">
+            {transaction.currency} {String(transaction.remainingBalance)}
+          </p>
+        </div>
+      </div>
+
+      <div className="border-t pt-3">
+        <div className="flex justify-between items-center">
+          <div>
+            <p className="text-sm text-gray-500">Total Refunded</p>
+            <p className="font-medium text-red-600">
+              {transaction.currency} {String(transaction.totalRefunded)}
+            </p>
+          </div>
+          {canRefund && onRefundClick && (
+            <button
+              onClick={() => onRefundClick(transaction.id)}
+              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
+              data-testid="refund-button"
+            >
+              Issue Refund
+            </button>
+          )}
+        </div>
+      </div>
+
+      {transaction.refunds && transaction.refunds.length > 0 && (
+        <div className="mt-4 border-t pt-3">
+          <p className="text-sm font-medium text-gray-700 mb-2">
+            Refund History ({transaction.refunds.length})
+          </p>
+          <ul className="space-y-1">
+            {transaction.refunds.map((refund) => (
+              <li key={refund.id} className="text-sm text-gray-600 flex justify-between">
+                <span className="font-mono text-xs">{refund.id.slice(0, 8)}...</span>
+                <span className="text-red-600">
+                  -{transaction.currency} {String(refund.amount)}
+                </span>
+              </li>
+            ))}
+          </ul>
+        </div>
+      )}
+    </div>
+  );
+}
+
+export default TransactionCard;
diff --git a/repository_after/src/components/TransactionDashboard.tsx b/repository_after/src/components/TransactionDashboard.tsx
new file mode 100644
--- /dev/null
+++ b/repository_after/src/components/TransactionDashboard.tsx
+/**
+ * TransactionDashboard Component
+ *
+ * Main dashboard for managing transactions and refunds.
+ * Handles loading states and orchestrates the refund workflow.
+ *
+ * Requirements covered:
+ * - Requirement 6: UI State Synchronization
+ * - Requirement 9: Error handling without page crash
+ */
+
+'use client';
+
+import React, { useState, useCallback } from 'react';
+import { TransactionCard } from './TransactionCard';
+import { RefundForm } from './RefundForm';
+import { TransactionWithBalance, RefundError } from '../types';
+
+interface TransactionDashboardProps {
+  initialTransactions: TransactionWithBalance[];
+  onProcessRefund: (
+    transactionId: string,
+    amount: string,
+    idempotencyKey: string
+  ) => Promise<{ success: boolean; error?: RefundError }>;
+  onRefresh: () => Promise<TransactionWithBalance[]>;
+}
+
+export function TransactionDashboard({
+  initialTransactions,
+  onProcessRefund,
+  onRefresh,
+}: TransactionDashboardProps) {
+  const [transactions, setTransactions] = useState<TransactionWithBalance[]>(initialTransactions);
+  const [selectedTransactionId, setSelectedTransactionId] = useState<string | null>(null);
+  const [isLoading, setIsLoading] = useState(false);
+  const [globalError, setGlobalError] = useState<string | null>(null);
+
+  const selectedTransaction = transactions.find((t) => t.id === selectedTransactionId);
+
+  const handleRefundClick = useCallback((transactionId: string) => {
+    setSelectedTransactionId(transactionId);
+    setGlobalError(null);
+  }, []);
+
+  const handleRefundSubmit = useCallback(
+    async (transactionId: string, amount: string, idempotencyKey: string) => {
+      try {
+        const result = await onProcessRefund(transactionId, amount, idempotencyKey);
+
+        if (result.success) {
+          // Refresh transactions to get updated balances (Requirement 6)
+          setIsLoading(true);
+          try {
+            const updatedTransactions = await onRefresh();
+            setTransactions(updatedTransactions);
+          } catch (refreshError) {
+            console.error('Failed to refresh transactions:', refreshError);
+            setGlobalError('Refund processed but failed to refresh. Please reload the page.');
+          } finally {
+            setIsLoading(false);
+          }
+        }
+
+        return result;
+      } catch (error) {
+        // Prevent page crash (Requirement 9)
+        console.error('Refund submission error:', error);
+        return {
+          success: false,
+          error: {
+            code: 'INTERNAL_ERROR' as const,
+            message: error instanceof Error ? error.message : 'Failed to process refund',
+          },
+        };
+      }
+    },
+    [onProcessRefund, onRefresh]
+  );
+
+  const handleRefundSuccess = useCallback(() => {
+    setSelectedTransactionId(null);
+  }, []);
+
+  const handleRefundCancel = useCallback(() => {
+    setSelectedTransactionId(null);
+  }, []);
+
+  const handleManualRefresh = useCallback(async () => {
+    setIsLoading(true);
+    setGlobalError(null);
+    try {
+      const updatedTransactions = await onRefresh();
+      setTransactions(updatedTransactions);
+    } catch (error) {
+      setGlobalError('Failed to refresh transactions. Please try again.');
+    } finally {
+      setIsLoading(false);
+    }
+  }, [onRefresh]);
+
+  return (
+    <div className="transaction-dashboard max-w-4xl mx-auto p-6">
+      <div className="flex justify-between items-center mb-6">
+        <h1 className="text-2xl font-bold">Transaction Management</h1>
+        <button
+          onClick={handleManualRefresh}
+          disabled={isLoading}
+          className="px-4 py-2 text-sm border rounded hover:bg-gray-50 disabled:opacity-50"
+          data-testid="refresh-button"
+        >
+          {isLoading ? 'Refreshing...' : 'Refresh'}
+        </button>
+      </div>
+
+      {globalError && (
+        <div
+          className="mb-4 bg-yellow-50 border border-yellow-200 text-yellow-800 p-3 rounded"
+          role="alert"
+        >
+          {globalError}
+        </div>
+      )}
+
+      {/* Refund Modal */}
+      {selectedTransaction && (
+        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
+          <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl">
+            <h2 className="text-xl font-semibold mb-4">Issue Refund</h2>
+            <RefundForm
+              transaction={selectedTransaction}
+              onSubmit={handleRefundSubmit}
+              onSuccess={handleRefundSuccess}
+              onCancel={handleRefundCancel}
+            />
+          </div>
+        </div>
+      )}
+
+      {/* Transaction List */}
+      <div className="space-y-4" data-testid="transaction-list">
+        {transactions.length === 0 ? (
+          <div className="text-center py-8 text-gray-500">
+            No transactions found.
+          </div>
+        ) : (
+          transactions.map((transaction) => (
+            <TransactionCard
+              key={transaction.id}
+              transaction={transaction}
+              onRefundClick={handleRefundClick}
+            />
+          ))
+        )}
+      </div>
+
+      {/* Loading Overlay */}
+      {isLoading && (
+        <div className="fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center z-40">
+          <div className="text-center">
+            <div className="animate-spin h-8 w-8 border-4 border-blue-600 border-t-transparent rounded-full mx-auto mb-2" />
+            <p className="text-gray-600">Loading...</p>
+          </div>
+        </div>
+      )}
+    </div>
+  );
+}
+
+export default TransactionDashboard;
diff --git a/repository_after/src/index.ts b/repository_after/src/index.ts
new file mode 100644
--- /dev/null
+++ b/repository_after/src/index.ts
+/**
+ * Public API exports for WealthWire Banking Application
+ *
+ * Note: Server-side modules (prisma, refund-service) should only be imported
+ * in server contexts (Server Components, API Routes, Server Actions).
+ */
+
+// Types - safe to import anywhere
+export * from './types';
+
+// Components - client-side only, no Prisma imports
+export * from './components';
+
+// Re-export service functions for server-side use
+export {
+  validateRefundAmount,
+  calculateTotalRefunded,
+  calculateRemainingBalance,
+  determineTransactionStatus,
+  validateRefundAgainstBalance,
+  validateRefundRequest,
+  processRefundAtomic,
+  toTransactionWithBalance,
+  getHttpStatusForError,
+} from './lib/refund-service';
diff --git a/repository_after/src/lib/prisma.ts b/repository_after/src/lib/prisma.ts
new file mode 100644
--- /dev/null
+++ b/repository_after/src/lib/prisma.ts
+/**
+ * Prisma Client Singleton
+ *
+ * IMPORTANT: This file must ONLY be imported in server-side code.
+ * Never import this in client components or files that end up in the browser bundle.
+ *
+ * Requirement 1: Next.js Server-Side Enforcement
+ * - All Prisma logic must be strictly confined to the server layer
+ * - This module uses 'server-only' pattern to prevent client-side imports
+ */
+
+import { PrismaClient } from '@prisma/client';
+
+// Server-only marker - this will cause a build error if imported on client
+const serverOnlyMarker = typeof window === 'undefined';
+
+if (!serverOnlyMarker && process.env.NODE_ENV !== 'test') {
+  throw new Error(
+    'PrismaClient cannot be imported on the client side. ' +
+    'This is a security violation - database credentials must never be exposed to the browser.'
+  );
+}
+
+// Global type declaration for development hot reload
+declare global {
+  // eslint-disable-next-line no-var
+  var prisma: PrismaClient | undefined;
+}
+
+// Prisma client singleton pattern
+// In development, store on global to prevent multiple instances during hot reload
+// In production, create a new instance
+const prismaClientSingleton = () => {
+  return new PrismaClient({
+    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
+  });
+};
+
+// Export singleton instance
+export const prisma = globalThis.prisma ?? prismaClientSingleton();
+
+if (process.env.NODE_ENV !== 'production') {
+  globalThis.prisma = prisma;
+}
+
+// Utility to check if we're on the server
+export function isServerSide(): boolean {
+  return typeof window === 'undefined';
+}
+
+// Export a function to get the client (useful for testing)
+export function getPrismaClient(): PrismaClient {
+  return prisma;
+}
+
+// Marker constant to verify server-only usage in tests
+export const PRISMA_SERVER_ONLY = true;
+
+// Database URL should never be exposed to client
+export const DATABASE_URL_EXPOSED = false;
diff --git a/repository_after/src/lib/refund-service.ts b/repository_after/src/lib/refund-service.ts
new file mode 100644
--- /dev/null
+++ b/repository_after/src/lib/refund-service.ts
+/**
+ * Refund Service
+ *
+ * Core business logic for processing refunds with atomic transactions.
+ *
+ * Requirements covered:
+ * - Requirement 2: Atomic Prisma Transactions
+ * - Requirement 3: Fiscal Consistency Rules
+ * - Requirement 4: Concurrency & Conflict Handling
+ * - Requirement 5: Data Type Precision (Decimal)
+ * - Requirement 7: Idempotency Controls
+ */
+
+import { Decimal } from 'decimal.js';
+import {
+  RefundRequest,
+  RefundResponse,
+  RefundError,
+  RefundErrorCode,
+  TransactionStatus,
+  ValidationResult,
+  TransactionWithBalance,
+} from '../types';
+
+// Configure Decimal.js for financial calculations
+Decimal.set({ precision: 20, rounding: Decimal.ROUND_HALF_UP });
+
+/**
+ * Validates refund amount
+ * - Must be positive
+ * - Must be a valid number
+ * - Uses Decimal for precision
+ */
+export function validateRefundAmount(amount: string | number): ValidationResult {
+  try {
+    const decimalAmount = new Decimal(amount);
+
+    if (decimalAmount.isNaN()) {
+      return {
+        valid: false,
+        error: {
+          code: 'INVALID_AMOUNT',
+          message: 'Refund amount must be a valid number',
+        },
+      };
+    }
+
+    if (decimalAmount.lessThanOrEqualTo(0)) {
+      return {
+        valid: false,
+        error: {
+          code: 'INVALID_AMOUNT',
+          message: 'Refund amount must be greater than zero',
+        },
+      };
+    }
+
+    return { valid: true };
+  } catch {
+    return {
+      valid: false,
+      error: {
+        code: 'INVALID_AMOUNT',
+        message: 'Invalid refund amount format',
+      },
+    };
+  }
+}
+
+/**
+ * Calculates total refunded amount for a transaction
+ * Uses Decimal arithmetic for precision
+ */
+export function calculateTotalRefunded(refunds: Array<{ amount: Decimal | string | number }>): Decimal {
+  return refunds.reduce((sum, refund) => {
+    return sum.plus(new Decimal(refund.amount.toString()));
+  }, new Decimal(0));
+}
+
+/**
+ * Calculates remaining refundable balance
+ */
+export function calculateRemainingBalance(
+  originalAmount: Decimal | string | number,
+  totalRefunded: Decimal
+): Decimal {
+  const original = new Decimal(originalAmount.toString());
+  return original.minus(totalRefunded);
+}
+
+/**
+ * Determines new transaction status based on refund
+ * Requirement 3: Fiscal Consistency Rules
+ */
+export function determineTransactionStatus(
+  originalAmount: Decimal | string | number,
+  totalRefundedAfter: Decimal
+): TransactionStatus {
+  const original = new Decimal(originalAmount.toString());
+
+  if (totalRefundedAfter.equals(original)) {
+    return 'REFUNDED';
+  }
+
+  if (totalRefundedAfter.greaterThan(0)) {
+    return 'PARTIALLY_REFUNDED';
+  }
+
+  return 'SETTLED';
+}
+
+/**
+ * Validates that refund doesn't exceed remaining balance
+ * Requirement 3: Sum(All Refunds) â‰¤ Original Transaction Amount
+ */
+export function validateRefundAgainstBalance(
+  refundAmount: Decimal | string | number,
+  remainingBalance: Decimal
+): ValidationResult {
+  const amount = new Decimal(refundAmount.toString());
+
+  if (amount.greaterThan(remainingBalance)) {
+    return {
+      valid: false,
+      error: {
+        code: 'INSUFFICIENT_BALANCE',
+        message: `Refund amount (${amount.toFixed(2)}) exceeds remaining balance (${remainingBalance.toFixed(2)})`,
+        details: {
+          requestedAmount: amount.toFixed(2),
+          remainingBalance: remainingBalance.toFixed(2),
+        },
+      },
+    };
+  }
+
+  return { valid: true };
+}
+
+/**
+ * Creates a refund error response
+ */
+export function createErrorResponse(code: RefundErrorCode, message: string, details?: Record<string, unknown>): RefundResponse {
+  return {
+    success: false,
+    error: {
+      code,
+      message,
+      details,
+    },
+  };
+}
+
+/**
+ * Validates a complete refund request
+ */
+export function validateRefundRequest(request: RefundRequest): ValidationResult {
+  if (!request.transactionId || request.transactionId.trim() === '') {
+    return {
+      valid: false,
+      error: {
+        code: 'VALIDATION_ERROR',
+        message: 'Transaction ID is required',
+      },
+    };
+  }
+
+  if (!request.idempotencyKey || request.idempotencyKey.trim() === '') {
+    return {
+      valid: false,
+      error: {
+        code: 'VALIDATION_ERROR',
+        message: 'Idempotency key is required',
+      },
+    };
+  }
+
+  return validateRefundAmount(request.amount);
+}
+
+/**
+ * Processes refund within an atomic transaction
+ *
+ * This is the core function that must be called within prisma.$transaction
+ *
+ * Requirements:
+ * - Requirement 2: Atomic operation
+ * - Requirement 3: Fiscal consistency
+ * - Requirement 4: Concurrency handling via version check
+ * - Requirement 5: Decimal precision
+ * - Requirement 7: Idempotency via unique key
+ */
+export interface AtomicRefundParams {
+  prisma: any; // Prisma transaction client
+  transactionId: string;
+  refundAmount: Decimal;
+  idempotencyKey: string;
+  expectedVersion?: number;
+}
+
+export interface AtomicRefundResult {
+  success: boolean;
+  refund?: any;
+  transaction?: any;
+  error?: RefundError;
+}
+
+export async function processRefundAtomic(params: AtomicRefundParams): Promise<AtomicRefundResult> {
+  const { prisma, transactionId, refundAmount, idempotencyKey, expectedVersion } = params;
+
+  // Step 1: Check for existing refund with same idempotency key (Requirement 7)
+  const existingRefund = await prisma.refund.findUnique({
+    where: { idempotencyKey },
+  });
+
+  if (existingRefund) {
+    // Return the existing refund for idempotent response
+    const transaction = await prisma.transaction.findUnique({
+      where: { id: transactionId },
+      include: { refunds: true },
+    });
+    return {
+      success: true,
+      refund: existingRefund,
+      transaction,
+    };
+  }
+
+  // Step 2: Fetch transaction with current state
+  const transaction = await prisma.transaction.findUnique({
+    where: { id: transactionId },
+    include: { refunds: true },
+  });
+
+  if (!transaction) {
+    return {
+      success: false,
+      error: {
+        code: 'TRANSACTION_NOT_FOUND',
+        message: `Transaction ${transactionId} not found`,
+      },
+    };
+  }
+
+  // Step 3: Check version for optimistic locking (Requirement 4)
+  if (expectedVersion !== undefined && transaction.version !== expectedVersion) {
+    return {
+      success: false,
+      error: {
+        code: 'CONCURRENT_MODIFICATION',
+        message: 'Transaction was modified by another request. Please refresh and try again.',
+        details: {
+          expectedVersion,
+          currentVersion: transaction.version,
+        },
+      },
+    };
+  }
+
+  // Step 4: Check if already fully refunded
+  if (transaction.status === 'REFUNDED') {
+    return {
+      success: false,
+      error: {
+        code: 'TRANSACTION_ALREADY_REFUNDED',
+        message: 'Transaction has already been fully refunded',
+      },
+    };
+  }
+
+  // Step 5: Calculate totals using Decimal precision (Requirement 5)
+  const totalRefunded = calculateTotalRefunded(transaction.refunds);
+  const remainingBalance = calculateRemainingBalance(transaction.amount, totalRefunded);
+
+  // Step 6: Validate refund against balance (Requirement 3)
+  const balanceValidation = validateRefundAgainstBalance(refundAmount, remainingBalance);
+  if (!balanceValidation.valid) {
+    return {
+      success: false,
+      error: balanceValidation.error,
+    };
+  }
+
+  // Step 7: Calculate new totals and status
+  const newTotalRefunded = totalRefunded.plus(refundAmount);
+  const newStatus = determineTransactionStatus(transaction.amount, newTotalRefunded);
+
+  // Step 8: Create refund and update transaction atomically
+  const refund = await prisma.refund.create({
+    data: {
+      amount: refundAmount.toFixed(2),
+      transactionId,
+      idempotencyKey,
+    },
+  });
+
+  const updatedTransaction = await prisma.transaction.update({
+    where: { id: transactionId },
+    data: {
+      status: newStatus,
+      version: { increment: 1 },
+    },
+    include: { refunds: true },
+  });
+
+  return {
+    success: true,
+    refund,
+    transaction: updatedTransaction,
+  };
+}
+
+/**
+ * Converts a transaction to include computed balance fields
+ */
+export function toTransactionWithBalance(transaction: any): TransactionWithBalance {
+  const totalRefunded = calculateTotalRefunded(transaction.refunds || []);
+  const remainingBalance = calculateRemainingBalance(transaction.amount, totalRefunded);
+
+  return {
+    ...transaction,
+    totalRefunded: totalRefunded.toFixed(2),
+    remainingBalance: remainingBalance.toFixed(2),
+  };
+}
+
+/**
+ * HTTP status code mapper for error codes
+ */
+export function getHttpStatusForError(errorCode: RefundErrorCode): number {
+  switch (errorCode) {
+    case 'INVALID_AMOUNT':
+    case 'VALIDATION_ERROR':
+      return 400; // Bad Request
+    case 'TRANSACTION_NOT_FOUND':
+      return 404; // Not Found
+    case 'CONCURRENT_MODIFICATION':
+      return 409; // Conflict
+    case 'INSUFFICIENT_BALANCE':
+    case 'TRANSACTION_ALREADY_REFUNDED':
+    case 'DUPLICATE_REQUEST':
+      return 422; // Unprocessable Entity
+    case 'INTERNAL_ERROR':
+    default:
+      return 500; // Internal Server Error
+  }
+}
diff --git a/repository_after/src/types/index.ts b/repository_after/src/types/index.ts
new file mode 100644
--- /dev/null
+++ b/repository_after/src/types/index.ts
+/**
+ * Type definitions for WealthWire Banking Application
+ * Financial ledger system types
+ */
+
+import { Decimal } from 'decimal.js';
+
+// Transaction status enum
+export type TransactionStatus = 'SETTLED' | 'PARTIALLY_REFUNDED' | 'REFUNDED';
+
+// Transaction interface matching Prisma model
+export interface Transaction {
+  id: string;
+  amount: Decimal | string | number;
+  currency: string;
+  status: TransactionStatus;
+  version: number;
+  createdAt: Date;
+  updatedAt: Date;
+  refunds?: Refund[];
+}
+
+// Refund interface matching Prisma model
+export interface Refund {
+  id: string;
+  amount: Decimal | string | number;
+  transactionId: string;
+  idempotencyKey: string;
+  createdAt: Date;
+}
+
+// Request payload for creating a refund
+export interface RefundRequest {
+  transactionId: string;
+  amount: string | number;
+  idempotencyKey: string;
+}
+
+// Response from refund operations
+export interface RefundResponse {
+  success: boolean;
+  refund?: Refund;
+  transaction?: Transaction;
+  error?: RefundError;
+}
+
+// Error types for refund operations
+export interface RefundError {
+  code: RefundErrorCode;
+  message: string;
+  details?: Record<string, unknown>;
+}
+
+export type RefundErrorCode =
+  | 'INVALID_AMOUNT'
+  | 'INSUFFICIENT_BALANCE'
+  | 'TRANSACTION_NOT_FOUND'
+  | 'TRANSACTION_ALREADY_REFUNDED'
+  | 'CONCURRENT_MODIFICATION'
+  | 'DUPLICATE_REQUEST'
+  | 'VALIDATION_ERROR'
+  | 'INTERNAL_ERROR';
+
+// Server action result type
+export interface ActionResult<T> {
+  success: boolean;
+  data?: T;
+  error?: RefundError;
+}
+
+// Transaction with computed fields for UI
+export interface TransactionWithBalance extends Transaction {
+  totalRefunded: Decimal | string | number;
+  remainingBalance: Decimal | string | number;
+}
+
+// Form state for React components
+export interface RefundFormState {
+  isSubmitting: boolean;
+  error: RefundError | null;
+  lastSubmittedAt: Date | null;
+}
+
+// Validation result type
+export interface ValidationResult {
+  valid: boolean;
+  error?: RefundError;
+}
+
+// Concurrency check result
+export interface ConcurrencyCheckResult {
+  canProceed: boolean;
+  currentVersion: number;
+  error?: RefundError;
+}
