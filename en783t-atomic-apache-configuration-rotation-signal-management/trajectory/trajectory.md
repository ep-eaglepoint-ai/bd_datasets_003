# Trajectory: Atomic Apache Configuration Rotation & Signal Management

### 1. Audit / Requirements Analysis (The actual problem)
The task is to build a daemon that watches a staging directory for `.conf` files, validates them with Apache’s syntax check (dry-run), atomically moves valid configs to the live directory and invalid ones to a rejected directory, then tells Apache to reload by sending SIGHUP to the process whose PID is in a given file. The real problem is avoiding partial reads (atomic move), avoiding use of systemctl/service/init.d (direct PID + signal), and not crashing when the PID file is stale. So the problem is: poll staging → validate → move atomically → read PID from file → send SIGHUP; handle validation failure and stale PID gracefully.

### 2. Question Assumptions (Challenge the Premise)
At first you might assume using `systemctl reload httpd` or `service httpd reload`. The requirements explicitly forbid systemctl, service, and init.d—we must read the PID from a file and send `syscall.SIGHUP` ourselves. Another assumption: should we copy then delete, or use rename? POSIX `rename` is atomic and avoids partial reads, so we use `os.Rename` for both move-to-live and move-to-rejected. Should validation run before or after move? It must run before: only valid configs go to live; invalid go to rejected. Should a stale PID file crash the daemon? No—we log and return without error so the daemon keeps running.

### 3. Define Success Criteria (Establish Measurable Goals)
Success meant: (1) no use of systemctl, service, or init.d in source; (2) run apachectl -t (or httpd -t) against the config before moving it; (3) read Apache PID from the configured file and parse it as an integer; (4) send `syscall.SIGHUP` to that process; (5) handle stale PID (process not running) by logging and not crashing; (6) after a successful run, processed files exist only in live, not in staging (atomic move, no copy-left-behind); (7) clear status messages to stdout (valid applied, syntax failed/moved to rejected, reload sent or stale PID). The evaluation script maps these to REQ-01 through REQ-07 and the test names.

### 4. Map Requirements to Validation (Define Test Strategy)
Each requirement maps to one test. TestNoSystemctlService walks repository_after Go sources and fails if "systemctl", "init.d", or `"service"` appear. TestDryRunBeforeMove runs the automator with a fake Apache binary that exits 0 for paths containing "good" and 1 otherwise; it asserts good.conf ends in live, bad.conf in reject, bad.conf not in live, and good.conf not left in staging. TestPidReadFromFile runs the automator and checks stdout for reload or stale message plus "Valid config applied" to prove PID was read and used. TestSighupSentToProcess (Linux-only) runs a receiver process that writes its PID to the pid file and waits for SIGHUP, then runs the automator; it asserts the receiver gets SIGHUP (done file appears). TestStalePidHandling uses PID 999999 (no such process) and asserts stdout contains "stale" or "not running" and the process does not crash. TestFileInLiveNotStaging asserts the processed .conf is in live and not in staging. TestStdoutStatusMessages asserts stdout contains "Valid config applied", syntax failed/moved to rejected, and reload or stale message. Tests use GetRepoPath() (flag or REPO_PATH), build the automator and fake binaries, run with short interval (e.g. 200ms), then kill and assert. RecordResult feeds the custom TestMain for pytest-style output.

### 5. Scope the Solution
The solution lives in repository_after: main.go (flags, dirs, validator, automator, signal handling, Run), deploy.go (MoveToLive, MoveToRejected using os.Rename), signal.go (SendReload: read pid file, parse int, FindProcess, Signal(SIGHUP), handle stale by logging and returning nil), validator.go (Validator interface, ApacheValidator with apachectl/httpd -t -f), automator.go (Automator struct, Run loop, scanStaging, processOne: validate → move to reject or live → SendReload). We do not touch repository_before (empty placeholder). Tests and evaluation run against repository_after only. No external dependencies beyond the standard library; validation is pluggable via the Validator interface so tests can inject a fake binary.

### 6. Trace Data Flow (Follow the Path)
On startup, main parses flags (staging, live, reject, pidfile, interval, apache binary), creates dirs for staging and reject, builds ApacheValidator and Automator, and runs a goroutine that cancels context on SIGINT/SIGTERM. Each tick: scanStaging lists staging; for each .conf file, processOne runs. processOne: (1) Validator.Validate(ctx, stagingPath)—exec CommandContext(binary, "-t", "-f", configPath); on failure, MoveToRejected(staging, reject), log "Syntax check failed, moved to rejected", return. (2) On success, MoveToLive(staging, live); on move failure log and return. (3) Log "Valid config applied", then SendReload(pidFile, log). SendReload: ReadFile(pidFile), TrimSpace, Atoi, FindProcess(pid), proc.Signal(SIGHUP); if Signal fails (e.g. stale), log "Apache not running (stale PID file)" and return nil; else log "Reload signal sent to PID %d". Data flow is one-way: staging → validate → reject or live; after move to live, reload is best-effort and does not block or fail the pipeline.

### 7. Anticipate Objections (Play Devil's Advocate)
"What if the pid file is missing or unreadable?" SendReload returns the error from ReadFile or Atoi; the automator doesn't check that return value after SendReload, so the daemon continues. If we wanted to fail the "apply" step when reload fails for a real (non-stale) reason, we'd have to distinguish errors—currently we only treat SIGHUP failure as "stale, log and return nil". "Why not copy then delete?" Copy is not atomic; a reader could see a half-written file. rename is atomic on the same filesystem. "Why allow configurable apache binary?" So we can use httpd when apachectl isn't available and so tests can inject a fake binary. "Why not use systemctl?" Requirements forbid it; we're demonstrating direct PID + signal for teaching and portability.

### 8. Verify Invariants (Define Constraints)
We must not use systemctl, service, or init.d anywhere in repository_after. We must use os.Rename for moves (atomic). We must run validation before any move. We must read PID from file as a string and parse to int (strconv.Atoi). We must send syscall.SIGHUP only; no other signals. On SIGHUP failure (e.g. process doesn't exist), we must not return an error to the caller (daemon must not crash) and should log. Status messages must go to stdout (Log callback in Automator is set to fmt.Println). The Validator interface allows swapping the binary for tests without changing automator logic.

### 9. Execute with Surgical Precision (Ordered Implementation)
First define the contract: Validator interface and ApacheValidator in validator.go. Then deploy.go: MoveToLive and MoveToRejected with os.Rename. Then signal.go: SendReload with ReadFile, TrimSpace, Atoi, FindProcess, Signal(SIGHUP), and on error log "stale" and return nil. Then automator.go: Automator struct with StagingDir, LiveDir, RejectDir, PidFile, Ticker, Validator, Log; Run select on ctx.Done and Ticker.C; scanStaging ReadDir and filter .conf; processOne: Validate → on fail MoveToRejected and return; MoveToLive → on fail return; log applied, SendReload. Then main.go: flags, MkdirAll for staging and reject, NewApacheValidator, ticker, Automator construction, signal.Notify for SIGINT/SIGTERM, cancel on signal, a.Run(ctx). No external packages; all std lib.

### 10. Measure Impact (Verify Completion)
Run `docker compose run --rm app go test -timeout 10s -v ./tests` and ensure all seven tests pass. Run `go run ./evaluation/evaluation.go` to produce the report: all REQ-01 through REQ-07 must show PASS. Tests that spawn the automator (dry run, PID, SIGHUP, stale, file placement, stdout) need a short poll interval (e.g. 200ms) and about 1s run before kill so at least one tick runs. On Windows, tests that depend on Linux (SIGHUP receiver, or automator with fake Apache) skip so the suite can still be run locally; full pass is in Docker (Linux). The evaluation runs only against repository_after and writes report.json to evaluation/<date>/<time>/report.json.

### 11. Document the Decision
We implemented a small daemon in Go that polls a staging directory for .conf files, validates each with an Apache syntax check (apachectl -t -f or httpd -t -f), atomically moves valid configs to live and invalid to rejected using os.Rename, then sends SIGHUP to the process whose PID is read from a file. Stale PID is handled by logging and returning without error so the daemon does not crash. No systemctl, service, or init.d; only standard library and syscall.SIGHUP. Clear stdout messages report validation result, move result, and reload/stale status. This matches typical production patterns for config rotation with graceful reload and keeps the code testable via a pluggable Validator and REPO_PATH for test discovery.

### 12. Infrastructure and Tooling
- **go.work** at project root includes tests, evaluation, and repository_after so `go test ./tests` and `go run ./evaluation/evaluation.go` resolve modules from /app in Docker and avoid path issues on Windows/Git Bash.
- **Docker**: Dockerfile uses golang:1.21-bullseye, WORKDIR /app, COPY . ., CMD runs go test. docker-compose.yml mounts the project at /app, sets working_dir: /app and REPO_PATH=/app/repository_after so tests find the implementation.
- **Tests**: Live under tests/ with their own go.mod; they use -repo or REPO_PATH to point at repository_after, build the automator and fake binaries to temp dirs, run with -interval 200ms, capture stdout/stderr, and use RecordResult + TestMain for a single "collected 7 items" pytest-style session.
- **Evaluation**: evaluation/evaluation.go runs `go test -timeout 60s -json -v` in the tests directory with REPO_PATH set, parses JSON output for pass/fail per test, maps tests to REQ-01..REQ-07, writes Report with Before/After (before is placeholder with success: false), and writes report.json under evaluation/<date>/<time>/.
- **Evaluation output**: stderr is read in a goroutine while stdout is consumed in the main goroutine to avoid deadlock when the test output is large.
- **README**: Documents the two commands only—docker compose for tests and for evaluation.
