diff --git a/repository_before/.gitkeep b/repository_before/.gitkeep
deleted file mode 100644
index e69de29..0000000
diff --git a/repository_after/concurrent_booking.sql b/repository_after/concurrent_booking.sql
new file mode 100644
index 0000000..ae430bb
--- /dev/null
+++ b/repository_after/concurrent_booking.sql
@@ -0,0 +1,51 @@
+-- PostgreSQL Transaction to Prevent Double Booking Under Concurrency
+-- 
+-- This solution ensures concurrency safety by using an advisory lock on the resource_id.
+-- Advisory locks allow us to create a serialization point for a specific ID even
+-- before any rows exist in the bookings table, resolving the race condition
+-- where multiple transactions might try to insert the first booking simultaneously.
+--
+-- Schema (given):
+-- CREATE TABLE bookings (
+--     id SERIAL PRIMARY KEY,
+--     resource_id INT NOT NULL,
+--     user_id INT NOT NULL,
+--     booked_at TIMESTAMP NOT NULL DEFAULT NOW()
+-- );
+
+-- Parameters: $1 = resource_id, $2 = user_id
+
+BEGIN;
+
+-- Step 1: Create a serialization point using an advisory lock.
+-- pg_advisory_xact_lock is automatically released at the end of the transaction.
+-- This ensures that only one transaction at a time can process booking logic 
+-- for a specific resource_id, regardless of whether the row exists yet.
+SELECT pg_advisory_xact_lock($1);
+
+-- Step 2: Now that we hold the lock, safely check and insert.
+WITH booking_attempt AS (
+    INSERT INTO bookings (resource_id, user_id)
+    SELECT $1, $2
+    WHERE NOT EXISTS (
+        SELECT 1 FROM bookings WHERE resource_id = $1
+    )
+    RETURNING id, resource_id, user_id
+)
+SELECT 
+    CASE 
+        WHEN COUNT(*) > 0 THEN 'SUCCESS: Resource ' || $1 || ' booked by user ' || $2
+        ELSE 'FAILED: Resource ' || $1 || ' was already booked'
+    END as booking_result
+FROM booking_attempt;
+
+COMMIT;
+
+-- EXPLANATION OF CONCURRENCY SAFETY:
+-- 1. pg_advisory_xact_lock($1) creates a lock tied to the resource_id value.
+-- 2. If another transaction tries to lock the same $1, it will wait.
+-- 3. Once the lock is acquired, we perform the NOT EXISTS check against the current state.
+-- 4. This eliminates the race condition where two transactions check for existence 
+--    at the same time before either has committed.
+-- 5. By using xact_lock, we ensure the lock is held until COMMIT, preventing
+--    interleaved execution that leads to double booking.
\ No newline at end of file
