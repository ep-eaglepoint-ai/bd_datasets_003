--- a/repository_after/autocomplete.js
+++ b/repository_after/autocomplete.js
@@ -0,0 +1,446 @@
+/* eslint-disable no-console */
+
+let _perfNow = () => Date.now();
+try {
+  // eslint-disable-next-line global-require
+  const { performance } = require('perf_hooks');
+  if (performance && typeof performance.now === 'function') {
+    _perfNow = () => performance.now();
+  }
+} catch {
+}
+
+function normalizeQuery(q) {
+  if (q == null) return '';
+  return String(q).toLowerCase().trim();
+}
+
+function computeTrigrams(str) {
+  if (!str || str.length < 3) return [];
+  const grams = [];
+  for (let i = 0; i <= str.length - 3; i++) {
+    grams.push(str.slice(i, i + 3));
+  }
+  return grams;
+}
+
+class TrieNode {
+  constructor() {
+    this.children = new Map();
+    this.indices = [];
+    this.topIndices = [];
+  }
+}
+
+class Trie {
+  constructor(maxTopPerNode = 50) {
+    this.root = new TrieNode();
+    this.maxTopPerNode = maxTopPerNode;
+  }
+
+  insert(word, productIndex, scoreByIndex, activeByIndex) {
+    let node = this.root;
+    for (let i = 0; i < word.length; i++) {
+      const ch = word[i];
+      let next = node.children.get(ch);
+      if (!next) {
+        next = new TrieNode();
+        node.children.set(ch, next);
+      }
+      node = next;
+
+      node.indices.push(productIndex);
+      this._maybeAddTop(node.topIndices, productIndex, scoreByIndex, activeByIndex);
+    }
+  }
+
+  findNode(prefix) {
+    let node = this.root;
+    for (let i = 0; i < prefix.length; i++) {
+      const ch = prefix[i];
+      node = node.children.get(ch);
+      if (!node) return null;
+    }
+    return node;
+  }
+
+  _maybeAddTop(topIndices, productIndex, scoreByIndex, activeByIndex) {
+    if (activeByIndex && activeByIndex[productIndex] === false) return;
+
+    const score = scoreByIndex[productIndex] ?? 0;
+
+    for (let i = 0; i < topIndices.length; i++) {
+      if (topIndices[i] === productIndex) return;
+    }
+
+    if (topIndices.length === 0) {
+      topIndices.push(productIndex);
+      return;
+    }
+    if (topIndices.length >= this.maxTopPerNode) {
+      const lastIdx = topIndices[topIndices.length - 1];
+      const lastScore = scoreByIndex[lastIdx] ?? 0;
+      if (score <= lastScore) return;
+    }
+    let insertAt = topIndices.length;
+    for (let i = 0; i < topIndices.length; i++) {
+      const existingIdx = topIndices[i];
+      const existingScore = scoreByIndex[existingIdx] ?? 0;
+      if (score > existingScore) {
+        insertAt = i;
+        break;
+      }
+    }
+    topIndices.splice(insertAt, 0, productIndex);
+    if (topIndices.length > this.maxTopPerNode) topIndices.length = this.maxTopPerNode;
+  }
+}
+
+function pushTopK(results, candidate, limit) {
+  if (limit <= 0) return;
+  let inserted = false;
+  for (let i = 0; i < results.length; i++) {
+    if (candidate.relevance > results[i].relevance) {
+      results.splice(i, 0, candidate);
+      inserted = true;
+      break;
+    }
+  }
+  if (!inserted) results.push(candidate);
+  if (results.length > limit) results.length = limit;
+}
+
+class ProductSearch {
+  constructor(products = []) {
+    this.products = Array.isArray(products) ? products : [];
+    this._trie = new Trie(50);
+    this._normalizedNames = [];
+    this._activeByIndex = [];
+    this._idToIndex = new Map();
+    this._gramToIndices = new Map();
+    this._scoreByIndex = [];
+    this._debounceMs = 100;
+    this._minQueryLength = 2; 
+    this._lastSearchAt = -Infinity;
+    this._lastResults = [];
+    this._pendingTimer = null;
+    this._pending = null;
+    this._computeCount = 0;
+    this._timeNow = () => _perfNow();
+
+    this.buildIndex();
+  }
+
+  buildIndex() {
+    this._trie = new Trie(50);
+    this._normalizedNames = new Array(this.products.length);
+    this._activeByIndex = new Array(this.products.length);
+    this._idToIndex = new Map();
+    this._gramToIndices = new Map();
+    this._scoreByIndex = new Array(this.products.length);
+
+    for (let i = 0; i < this.products.length; i++) {
+      const p = this.products[i];
+      this._activeByIndex[i] = true;
+      if (p && p.id != null) this._idToIndex.set(String(p.id), i);
+      const name = p && p.name != null ? String(p.name) : '';
+      const norm = name.toLowerCase();
+      this._normalizedNames[i] = norm;
+
+      const score = p && typeof p.score === 'number' ? p.score : 0;
+      this._scoreByIndex[i] = score;
+
+      this._trie.insert(norm, i, this._scoreByIndex, this._activeByIndex);
+
+      const grams = computeTrigrams(norm);
+      const unique = new Set(grams);
+      for (const gram of unique) {
+        let arr = this._gramToIndices.get(gram);
+        if (!arr) {
+          arr = [];
+          this._gramToIndices.set(gram, arr);
+        }
+        arr.push(i);
+      }
+    }
+  }
+
+  addProduct(product) {
+    const index = this.products.length;
+    this.products.push(product);
+    this._activeByIndex[index] = true;
+    if (product && product.id != null) this._idToIndex.set(String(product.id), index);
+
+    const name = product && product.name != null ? String(product.name) : '';
+    const norm = name.toLowerCase();
+    this._normalizedNames[index] = norm;
+
+    const score = product && typeof product.score === 'number' ? product.score : 0;
+    this._scoreByIndex[index] = score;
+
+    this._trie.insert(norm, index, this._scoreByIndex, this._activeByIndex);
+
+    const grams = computeTrigrams(norm);
+    const unique = new Set(grams);
+    for (const gram of unique) {
+      let arr = this._gramToIndices.get(gram);
+      if (!arr) {
+        arr = [];
+        this._gramToIndices.set(gram, arr);
+      }
+      arr.push(index);
+    }
+  }
+
+  addProducts(products) {
+    if (!Array.isArray(products)) return;
+    for (const p of products) this.addProduct(p);
+  }
+
+  removeProduct(productOrId) {
+    const id = (productOrId && typeof productOrId === 'object') ? productOrId.id : productOrId;
+    if (id == null) return false;
+    const key = String(id);
+    const idx = this._idToIndex.get(key);
+    if (idx == null) return false;
+    this._activeByIndex[idx] = false;
+    this._idToIndex.delete(key);
+    return true;
+  }
+
+  flushPending() {
+    if (!this._pending) return this._lastResults;
+    if (this._pendingTimer) {
+      clearTimeout(this._pendingTimer);
+      this._pendingTimer = null;
+    }
+    const { query, limit } = this._pending;
+    this._pending = null;
+    this._lastResults = this._computeSearch(query, limit);
+    this._lastSearchAt = this._timeNow();
+    return this._lastResults;
+  }
+
+  searchProducts(query, limit = 10) {
+    const normQuery = normalizeQuery(query);
+    if (!normQuery) return [];
+    if (normQuery.length < this._minQueryLength) return [];
+
+    const now = this._timeNow();
+    const elapsed = now - this._lastSearchAt;
+
+    if (elapsed < this._debounceMs) {
+      this._pending = { query: normQuery, limit };
+
+      if (!this._pendingTimer) {
+        const wait = Math.max(0, this._debounceMs - elapsed);
+        this._pendingTimer = setTimeout(() => {
+          this._pendingTimer = null;
+          if (!this._pending) return;
+          const { query: q, limit: lim } = this._pending;
+          this._pending = null;
+          this._lastResults = this._computeSearch(q, lim);
+          this._lastSearchAt = this._timeNow();
+        }, wait);
+      }
+
+      return this._lastResults;
+    }
+    if (this._pendingTimer) {
+      clearTimeout(this._pendingTimer);
+      this._pendingTimer = null;
+    }
+    this._pending = null;
+
+    this._lastResults = this._computeSearch(normQuery, limit);
+    this._lastSearchAt = now;
+    return this._lastResults;
+  }
+
+  _computeSearch(normQuery, limit) {
+    this._computeCount++;
+    const results = [];
+    const seen = new Set();
+    const node = this._trie.findNode(normQuery);
+    if (node) {
+      const candidates = node.topIndices.length ? node.topIndices : node.indices;
+      for (let i = 0; i < candidates.length; i++) {
+        const idx = candidates[i];
+        if (!this._activeByIndex[idx]) continue;
+        const nameNorm = this._normalizedNames[idx];
+        if (!nameNorm || !nameNorm.startsWith(normQuery)) continue;
+        const p = this.products[idx];
+        if (!p) continue;
+        const score = typeof p.score === 'number' ? p.score : 0;
+        seen.add(idx);
+        pushTopK(
+          results,
+          {
+            id: p.id,
+            name: p.name,
+            score,
+            matchType: 'prefix',
+            relevance: 1_000_000 + score,
+          },
+          limit,
+        );
+      }
+    }
+    if (results.length >= limit) {
+      return results.map(r => ({
+        id: r.id,
+        name: r.name,
+        score: r.score,
+        matchType: r.matchType,
+      }));
+    }
+    if (normQuery.length >= 3) {
+      const grams = computeTrigrams(normQuery);
+      let bestList = null;
+      let bestSize = Infinity;
+      for (let i = 0; i < grams.length; i++) {
+        const list = this._gramToIndices.get(grams[i]);
+        if (!list) {
+          bestList = null;
+          bestSize = 0;
+          break;
+        }
+        if (list.length < bestSize) {
+          bestSize = list.length;
+          bestList = list;
+        }
+      }
+
+      if (bestList && bestList.length) {
+        for (let i = 0; i < bestList.length; i++) {
+          const idx = bestList[i];
+          if (seen.has(idx)) continue;
+          if (!this._activeByIndex[idx]) continue;
+          const nameNorm = this._normalizedNames[idx];
+          if (!nameNorm || !nameNorm.includes(normQuery)) continue;
+          const p = this.products[idx];
+          if (!p) continue;
+          const score = typeof p.score === 'number' ? p.score : 0;
+          seen.add(idx);
+          pushTopK(
+            results,
+            {
+              id: p.id,
+              name: p.name,
+              score,
+              matchType: 'contains',
+              relevance: score,
+            },
+            limit,
+          );
+        }
+      }
+    }
+
+    return results.map(r => ({
+      id: r.id,
+      name: r.name,
+      score: r.score,
+      matchType: r.matchType,
+    }));
+  }
+
+  getByCategory(category) {
+    return this.products.filter((p, i) => this._activeByIndex[i] && p && p.category === category);
+  }
+
+  countMatches(prefix) {
+    const q = normalizeQuery(prefix);
+    if (!q) return 0;
+    if (q.length >= 3) {
+      const grams = computeTrigrams(q);
+      let bestList = null;
+      let bestSize = Infinity;
+      for (let i = 0; i < grams.length; i++) {
+        const list = this._gramToIndices.get(grams[i]);
+        if (!list) return 0;
+        if (list.length < bestSize) {
+          bestSize = list.length;
+          bestList = list;
+        }
+      }
+      let count = 0;
+      for (let i = 0; i < bestList.length; i++) {
+        const idx = bestList[i];
+        if (!this._activeByIndex[idx]) continue;
+        if (this._normalizedNames[idx].includes(q)) count++;
+      }
+      return count;
+    }
+
+    let count = 0;
+    for (let i = 0; i < this.products.length; i++) {
+      if (!this._activeByIndex[i]) continue;
+      if ((this._normalizedNames[i] || '').includes(q)) count++;
+    }
+    return count;
+  }
+}
+
+function generateTestProducts(count) {
+  const adjectives = ['Wireless', 'Premium', 'Ultra', 'Pro', 'Classic', 'Modern', 'Smart', 'Portable', 'Heavy-Duty', 'Compact'];
+  const nouns = ['Headphones', 'Speaker', 'Keyboard', 'Mouse', 'Monitor', 'Charger', 'Cable', 'Stand', 'Hub', 'Adapter'];
+  const brands = ['TechCo', 'AudioMax', 'DigitalPro', 'SmartGear', 'ElectroHub', 'ByteWare', 'SoundWave', 'PixelPerfect'];
+  const categories = ['electronics', 'audio', 'accessories', 'computing', 'mobile'];
+
+  const products = [];
+  for (let i = 0; i < count; i++) {
+    const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
+    const noun = nouns[Math.floor(Math.random() * nouns.length)];
+    const brand = brands[Math.floor(Math.random() * brands.length)];
+
+    products.push({
+      id: `prod_${String(i).padStart(6, '0')}`,
+      name: `${brand} ${adj} ${noun} ${i}`,
+      category: categories[Math.floor(Math.random() * categories.length)],
+      score: Math.floor(Math.random() * 100),
+    });
+  }
+  return products;
+}
+
+async function simulateTyping(search, word) {
+  console.log(`\nSimulating typing "${word}" character by character:\n`);
+  let totalTime = 0;
+  for (let i = 1; i <= word.length; i++) {
+    const partial = word.substring(0, i);
+    const start = _perfNow();
+    const results = search.searchProducts(partial);
+    const elapsed = _perfNow() - start;
+    totalTime += elapsed;
+    console.log(`  "${partial}" -> ${elapsed.toFixed(2)}ms (${results.length} results)`);
+  }
+  console.log(`\n  Total time for ${word.length} keystrokes: ${totalTime.toFixed(2)}ms`);
+  console.log(`  Average per keystroke: ${(totalTime / word.length).toFixed(2)}ms`);
+}
+
+if (typeof require !== 'undefined' && require.main === module) {
+  (async () => {
+    const productCount = 50000;
+    console.log(`Generating ${productCount.toLocaleString()} test products...`);
+    const products = generateTestProducts(productCount);
+    const search = new ProductSearch(products);
+    console.log('Products generated and indexed.\n');
+
+    console.log('=' + '='.repeat(59));
+    console.log('Benchmarking search performance:\n');
+    const queries = ['wire', 'wireless', 'TechCo Pro', 'a', 'xyz'];
+    for (const query of queries) {
+      const start = _perfNow();
+      const results = search.searchProducts(query);
+      const elapsed = _perfNow() - start;
+      console.log(`Query "${query}": ${elapsed.toFixed(2)}ms - Found ${results.length} results`);
+    }
+    await simulateTyping(search, 'wireless');
+  })().catch((err) => {
+    console.error(err);
+    process.exitCode = 1;
+  });
+}
+
+module.exports = { ProductSearch, generateTestProducts };

--- a/tests/autocomplete.test.js
+++ b/tests/autocomplete.test.js
@@ -0,0 +1,216 @@
+const test = require('node:test');
+const assert = require('node:assert/strict');
+const fs = require('node:fs');
+const path = require('node:path');
+
+const before = require('../repository_before/autocomplete');
+const after = require('../repository_after/autocomplete');
+
+let perfNow = () => Date.now();
+try {
+  // eslint-disable-next-line global-require
+  const { performance } = require('node:perf_hooks');
+  if (performance && typeof performance.now === 'function') perfNow = () => performance.now();
+} catch {
+  // ignore
+}
+
+test('requirement 1: legacy bottleneck analysis is documented in comments', () => {
+  const filePath = path.join(__dirname, '..', 'repository_after', 'autocomplete.js');
+  const content = fs.readFileSync(filePath, 'utf8');
+  // Basic smoke-check that analysis + complexity notes exist.
+  assert.match(content, /Legacy bottleneck analysis/i);
+  assert.match(content, /O\(n\)/);
+});
+
+test('requirements 2-3: trie exists and prefix lookup is case-insensitive', () => {
+  const products = [
+    { id: '1', name: 'Wireless Mouse', score: 10 },
+    { id: '2', name: 'wireless Keyboard', score: 20 },
+    { id: '3', name: 'Wired Headphones', score: 30 },
+  ];
+
+  const search = new after.ProductSearch(products);
+  search._debounceMs = 0;
+  assert.ok(search._trie && search._trie.root, 'Trie should exist');
+
+  const res1 = search.searchProducts('WIRE', 10);
+  const res2 = search.searchProducts('wire', 10);
+
+  assert.deepEqual(
+    res1.map(r => r.id).sort(),
+    res2.map(r => r.id).sort(),
+    'case-insensitive results should match',
+  );
+});
+
+test('requirement 4: ranking prefers prefix over contains and uses score', () => {
+  const products = [
+    { id: 'a', name: 'Alpha Phone', score: 1 },
+    { id: 'b', name: 'Super Alpha Phone', score: 99 },
+    { id: 'c', name: 'Alpha Case', score: 50 },
+  ];
+  const search = new after.ProductSearch(products);
+  search._debounceMs = 0;
+
+  // Query "alpha" should return prefix matches (a,c) above contains (b)
+  // and higher score should rank higher among same matchType.
+  const results = search.searchProducts('alpha', 10);
+  assert.ok(results.length >= 2);
+  assert.equal(results[0].matchType, 'prefix');
+  assert.equal(results[1].matchType, 'prefix');
+
+  // Among prefix results, c (score 50) should appear before a (score 1)
+  const ids = results.map(r => r.id);
+  assert.ok(ids.indexOf('c') < ids.indexOf('a'));
+
+  // Contains result should be present after prefixes
+  assert.ok(ids.includes('b'));
+  assert.ok(ids.indexOf('b') > ids.indexOf('a'));
+});
+
+test('requirement 5: throttle/debounce coalesces rapid calls; only latest executes', async () => {
+  const products = [
+    { id: '1', name: 'TechCo Wireless Mouse', score: 10 },
+    { id: '2', name: 'TechCo Wireless Keyboard', score: 20 },
+    { id: '3', name: 'Other Brand', score: 5 },
+  ];
+  const search = new after.ProductSearch(products);
+
+  let t = 0;
+  search._timeNow = () => t;
+
+  const r1 = search.searchProducts('te', 10);
+  assert.ok(Array.isArray(r1));
+  const computeAfterFirst = search._computeCount;
+  assert.equal(computeAfterFirst, 1);
+
+  t = 50; // within 100ms
+  const r2 = search.searchProducts('tech', 10);
+  assert.equal(search._computeCount, 1, 'should not compute immediately inside throttle window');
+  // should return last results (could be empty or previous)
+  assert.ok(Array.isArray(r2));
+
+  t = 70; // still within window, update pending again
+  search.searchProducts('techco w', 10);
+  assert.equal(search._computeCount, 1);
+
+  // Force execution of latest pending
+  const flushed = search.flushPending();
+  assert.ok(flushed.every(x => x.id && x.name && typeof x.score === 'number'));
+  assert.ok(flushed.length > 0);
+  assert.ok(flushed[0].name.toLowerCase().includes('techco'));
+  assert.equal(search._computeCount, 2, 'flush should compute exactly once');
+
+  // let timer system settle (no-op, just to be safe in CI)
+  await new Promise(r => setTimeout(r, 0));
+});
+
+test('requirement 6: empty/whitespace and single-character queries return empty', () => {
+  const search = new after.ProductSearch([{ id: '1', name: 'Alpha', score: 1 }]);
+  search._debounceMs = 0;
+  assert.deepEqual(search.searchProducts('', 10), []);
+  assert.deepEqual(search.searchProducts('   ', 10), []);
+  assert.deepEqual(search.searchProducts('a', 10), []);
+});
+
+test('requirements 7-8: buildIndex exists; add/remove updates index without full rebuild', () => {
+  const search = new after.ProductSearch([]);
+  search._debounceMs = 0;
+  assert.equal(typeof search.buildIndex, 'function');
+
+  search.addProduct({ id: 'x', name: 'Gamma Phone', score: 10, category: 'electronics' });
+  const res1 = search.searchProducts('ga', 10);
+  search.flushPending();
+  assert.ok(res1.some(r => r.id === 'x'));
+
+  const removed = search.removeProduct('x');
+  assert.equal(removed, true);
+  const res2 = search.searchProducts('ga', 10);
+  search.flushPending();
+  assert.ok(!res2.some(r => r.id === 'x'));
+});
+
+test('requirement 9: memory overhead is documented in comments', () => {
+  const filePath = path.join(__dirname, '..', 'repository_after', 'autocomplete.js');
+  const content = fs.readFileSync(filePath, 'utf8');
+  assert.match(content, /Memory note/i);
+  assert.match(content, /references/i);
+});
+
+test('performance: search is sub-50ms for 100k prefix query (after)', () => {
+  // Deterministic dataset: huge shared prefix; search should still be fast.
+  const n = 100000;
+  const products = new Array(n);
+  for (let i = 0; i < n; i++) {
+    products[i] = {
+      id: `p${i}`,
+      name: `TechCo Wireless Headphones ${i}`,
+      score: i % 100,
+      category: 'electronics',
+    };
+  }
+
+  const search = new after.ProductSearch(products);
+  // Disable throttle for timing stability in this test.
+  search._debounceMs = 0;
+  const start = perfNow();
+  const results = search.searchProducts('techco w', 10);
+  const elapsed = perfNow() - start;
+
+  assert.ok(results.length > 0);
+  assert.ok(elapsed < 50, `expected <50ms, got ${elapsed.toFixed(2)}ms`);
+});
+
+test('performance: optimized implementation is significantly faster than legacy', () => {
+  const n = 100000;
+  const products = new Array(n);
+  for (let i = 0; i < n; i++) {
+    products[i] = {
+      id: `p${i}`,
+      name: `TechCo Wireless Headphones ${i}`,
+      score: i % 100,
+      category: 'electronics',
+    };
+  }
+
+  const legacy = new before.ProductSearch(products);
+  const optimized = new after.ProductSearch(products);
+  optimized._debounceMs = 0;
+
+  const query = 'techco w';
+
+  const t1 = perfNow();
+  legacy.searchProducts(query, 10);
+  const legacyMs = perfNow() - t1;
+
+  const t2 = perfNow();
+  optimized.searchProducts(query, 10);
+  const optMs = perfNow() - t2;
+
+  // Use ratio to reduce flakiness across environments.
+  assert.ok(optMs <= legacyMs / 3 || legacyMs - optMs >= 20, `legacy=${legacyMs.toFixed(2)}ms optimized=${optMs.toFixed(2)}ms`);
+});
+
+test('compatibility: optimized finds the same matches as legacy (>=2 chars)', () => {
+  const products = [
+    { id: '1', name: 'TechCo Wireless Mouse', score: 10 },
+    { id: '2', name: 'AudioMax Wired Headphones', score: 90 },
+    { id: '3', name: 'SmartGear Ultra Cable', score: 50 },
+    { id: '4', name: 'Cable Organizer - Wireless', score: 5 },
+  ];
+
+  const legacy = new before.ProductSearch(products);
+  const optimized = new after.ProductSearch(products);
+  optimized._debounceMs = 0;
+
+  const query = 'wire';
+  const a = legacy.searchProducts(query, 10);
+  const b = optimized.searchProducts(query, 10);
+
+  // We require compatibility in signature/shape and that it finds the same items,
+  // but ranking can be improved in the optimized implementation.
+  const setA = new Set(a.map(x => x.id));
+  const setB = new Set(b.map(x => x.id));
+  assert.deepEqual([...setB].sort(), [...setA].sort());
+});

--- a/evaluation/evaluation.js
+++ b/evaluation/evaluation.js
@@ -0,0 +1,190 @@
+/*
+Evaluation script
+
+Goal:
+- Run a small benchmark for both legacy (before) and optimized (after) search.
+- Emit a JSON report to stdout.
+
+IMPORTANT (Aquila harness expectation):
+- This script must exit with code 0 even on errors.
+- Errors are reported in the JSON and via stderr.
+
+The surrounding harness may treat non-zero exit codes as infrastructure failures.
+*/
+
+/* eslint-disable no-console */
+
+const path = require('node:path');
+
+function die_oom() {
+  // Keep it simple and robust.
+  try {
+    process.stderr.write('evaluation: OOM detected (heap out of memory)\n');
+  } catch {
+    // ignore
+  }
+
+  // Still exit 0 by contract.
+  try {
+    process.stdout.write(
+      JSON.stringify(
+        {
+          ok: false,
+          error: 'oom',
+        },
+        null,
+        2,
+      ) + '\n',
+    );
+  } catch {
+    // ignore
+  }
+  process.exit(0);
+}
+
+function perfNow() {
+  try {
+    // eslint-disable-next-line global-require
+    const { performance } = require('node:perf_hooks');
+    if (performance && typeof performance.now === 'function') return performance.now();
+  } catch {
+    // ignore
+  }
+  return Date.now();
+}
+
+function median(values) {
+  if (!values.length) return 0;
+  const sorted = [...values].sort((a, b) => a - b);
+  const mid = Math.floor(sorted.length / 2);
+  if (sorted.length % 2 === 1) return sorted[mid];
+  return (sorted[mid - 1] + sorted[mid]) / 2;
+}
+
+function benchSearch({ label, SearchClass, products, queries, limit = 10, reps = 5 }) {
+  const startInit = perfNow();
+  const search = new SearchClass(products);
+  const initMs = perfNow() - startInit;
+
+  // Disable throttle if the implementation supports it; evaluation measures core search.
+  if (search && typeof search === 'object' && '_debounceMs' in search) {
+    search._debounceMs = 0;
+  }
+
+  const queryStats = {};
+
+  for (const q of queries) {
+    const queryOriginal = String(q);
+    const queryKey = queryOriginal.toLowerCase();
+    const times = [];
+    let lastResultCount = 0;
+
+    // Warmup
+    try {
+      const warm = search.searchProducts(queryOriginal, limit);
+      lastResultCount = Array.isArray(warm) ? warm.length : 0;
+    } catch {
+      // ignore
+    }
+
+    for (let i = 0; i < reps; i++) {
+      const t0 = perfNow();
+      const res = search.searchProducts(queryOriginal, limit);
+      const t1 = perfNow();
+      times.push(t1 - t0);
+      lastResultCount = Array.isArray(res) ? res.length : 0;
+    }
+
+    queryStats[queryKey] = {
+      query: queryOriginal,
+      medianMs: median(times),
+      minMs: Math.min(...times),
+      maxMs: Math.max(...times),
+      reps,
+      resultCount: lastResultCount,
+    };
+  }
+
+  return {
+    label,
+    initMs,
+    queryStats,
+    memory: process.memoryUsage(),
+  };
+}
+
+function main() {
+  const before = require(path.join('..', 'repository_before', 'autocomplete.js'));
+  const after = require(path.join('..', 'repository_after', 'autocomplete.js'));
+
+  const productCount = 100000;
+  const products = before.generateTestProducts
+    ? before.generateTestProducts(productCount)
+    : after.generateTestProducts(productCount);
+
+  const queries = ['wire', 'wireless', 'TechCo Pro', 'xyz'];
+
+  const beforeReport = benchSearch({
+    label: 'before',
+    SearchClass: before.ProductSearch,
+    products,
+    queries,
+  });
+
+  const afterReport = benchSearch({
+    label: 'after',
+    SearchClass: after.ProductSearch,
+    products,
+    queries,
+  });
+
+  // Gate: after prefix-based queries should be < 50ms (median).
+  const thresholdMs = 50;
+  const gatedQueries = ['wire', 'wireless', 'techco pro'];
+
+  const afterGate = gatedQueries.map((q) => {
+    const key = String(q).toLowerCase();
+    const stat = afterReport.queryStats[key];
+    const medianMs = stat ? stat.medianMs : null;
+    return { query: key, medianMs, ok: typeof medianMs === 'number' ? medianMs < thresholdMs : false };
+  });
+
+  const ok = afterGate.every((g) => g.ok);
+
+  const report = {
+    ok,
+    thresholdMs,
+    afterGate,
+    before: beforeReport,
+    after: afterReport,
+  };
+
+  process.stdout.write(JSON.stringify(report, null, 2) + '\n');
+
+  // Always exit 0 (Aquila requirement).
+  process.exit(0);
+}
+
+process.on('unhandledRejection', (e) => {
+  const msg = e && e.stack ? String(e.stack) : String(e);
+  if (msg.includes('heap out of memory')) return die_oom();
+  try {
+    process.stderr.write(`evaluation: unhandled rejection: ${msg}\n`);
+  } catch {
+    // ignore
+  }
+  process.exit(0);
+});
+
+try {
+  main();
+} catch (e) {
+  const msg = e && e.stack ? String(e.stack) : String(e);
+  if (msg.includes('heap out of memory')) return die_oom();
+  try {
+    process.stderr.write(`evaluation: fatal error: ${msg}\n`);
+  } catch {
+    // ignore
+  }
+  process.exit(0);
+}

--- a/Dockerfile
+++ b/Dockerfile
@@ -1,7 +1,6 @@
-# Add your Dockerfile content here, e.g. for a Python project with pytest would be like:
+FROM node:20-slim
 
-FROM python:3.11-slim
 WORKDIR /app
 COPY . /app
-RUN pip install --no-cache-dir -r requirements.txt
-CMD ["pytest", "-q", "tests"]
+
+CMD ["node", "--test", "--test-reporter", "spec"]

--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -1,8 +1,21 @@
-# Docker Compose file for running tests. You should customize this as needed.
-
 services:
-  app:
+  before_test:
     build: .
-    command: pytest -q tests
+    working_dir: /app
+    command: "node -e \"console.log('before_test: node', process.version)\""
     volumes:
       - .:/app
+
+  test_report:
+    build: .
+    working_dir: /app
+    command: node --test --test-reporter spec
+    volumes:
+      - .:/app
+
+  after_test:
+    build: .
+    working_dir: /app
+    command: 'node -e "console.log(''after_test: done'')"'
+    volumes:
+      - .:/app

--- a/README.md
+++ b/README.md
@@ -1,11 +1,11 @@
 # NW51D6 - autocomplete_optimization
 
-    ## Before Test Docker Command
-    <docker before command here>
+## Before Test Docker Command
+`docker compose run --rm before_test`
 
-    ## After Test Docker Command
-    <docker after command here>
+## Test and Report Docker Command
+`docker compose run --rm test_report`
 
-    ## Evaluation Docker Command
-    <evaluation command here>
-    
+## After Test Docker Command
+`docker compose run --rm after_test`
+    
--- a/trajectory/trajectory.md
+++ b/trajectory/trajectory.md
@@ -1,2 +1,40 @@
 # Trajectory
 
+## 1: Identified bottleneck
+- The legacy implementation in repository_before/autocomplete.js does a full linear scan of all products on every keystroke.
+- For each product it lowercases the name and runs `startsWith` / `includes`.
+- It then sorts *all* matches even though only the top 10 are displayed.
+
+Net effect: per keystroke complexity is approximately O(n * L + k log k) where:
+- n = number of products (50k–100k)
+- L = average product name length
+- k = number of matches (can be very large for common prefixes)
+This is why typing a multi-character word triggers multiple expensive passes and feels laggy.
+
+## 2: Considered alternatives
+- **Plain caching only**: this helps repeated queries but doesn’t solve first-time lookups and doesn’t avoid O(n) work.
+- **Binary search on sorted names**: good for prefix-only, but not for substring `includes` matches.
+- **Full-text / external libraries**: disallowed.
+- **Trie (prefix tree) + lightweight substring accelerator**: best fit for the constraints.
+
+## 3: What changed
+Implemented an indexed search engine in repository_after/autocomplete.js:
+- A Trie is built once during initialization for prefix matches.
+- A trigram -> posting list map to avoid scanning all products for substring matches.
+- Top-K selection without sorting all matches.
+- Throttle/debounce window (100ms) to coalesce rapid keystrokes and avoid redundant work.
+- Incremental updates: `addProduct` and `removeProduct` update the index without a full rebuild.
+
+## 4: Complexity improved
+- Index build: O(total characters across names + total unique trigrams).
+- Prefix query: O(m + K) where m is query length, K is small top-list size.
+- Substring query: O(P + verification) where P is posting list size for the rarest trigram in the query (then exact `includes` verification on candidates).
+
+Critically, i avoid the legacy O(n) scan for every prefix query.
+
+## 5: Memory changed
+- Trie stores references(indices), not duplicated product objects.
+- Each product contributes roughly one integer reference per character in its name across the trie.
+- Trigram index also stores references only, deduped per product per trigram.
+This increases memory relative to storing only the raw product array, but keeps it bounded and predictable and trades memory for sub-50ms latency.
+

--- a/instances/instance.json
+++ b/instances/instance.json
@@ -1,11 +1,17 @@
 {
             "instance_id": "NW51D6",
-            "problem_statement": "Users are experiencing noticeable lag when typing in the search bar of an e-commerce product catalog. The autocomplete feature in search/autocomplete.js should display suggestions within 50 milliseconds of each keystroke, but performance testing shows response times averaging 800 milliseconds when the product catalog contains 50000 items. The delay makes the typing experience feel sluggish and users often complete their query before suggestions appear. The system needs to find products whose names start with or contain the typed prefix, rank results by relevance and popularity, and return the top 10 suggestions instantly. Frontend monitoring revealed that each keystroke triggers a full scan of the product array using filter and includes, typing \"wire\" triggers 4 separate search operations in rapid succession as each letter is typed, and the ranking sort runs on thousands of matched products even though only 10 are displayed.\n",
+"problem_statement": "Users are experiencing noticeable lag when typing in the search bar of an e-commerce product catalog. The autocomplete feature in search/autocomplete.js should display suggestions within 50 milliseconds of each keystroke, but performance testing shows response times averaging 800 milliseconds when the product catalog contains 50000 items. The delay makes the typing experience feel sluggish and users often complete their query before suggestions appear. The system needs to find products whose names start with or contain the typed prefix, rank results by relevance and popularity, and return the top 10 suggestions instantly. Frontend monitoring revealed that each keystroke triggers a full scan of the product array using filter and includes, typing \"wire\" triggers 4 separate search operations in rapid succession as each letter is typed, and the ranking sort runs on thousands of matched products even though only 10 are displayed.",
             "base_commit": "repository_before/",
             "test_patch": "tests/",
             "github_url": "https://github.com/ep-eaglepoint-ai/bd_datasets_003/tree/main/nw51d6-autocomplete-optimization",
             "environment_setup": "Dockerfile",
-            "FAIL_TO_PASS": [],
-            "PASS_TO_PASS": []
+            "FAIL_TO_PASS": [
+                "performance: search is sub-50ms for 100k prefix query (after)",
+                "performance: optimized implementation is significantly faster than legacy",
+                "requirement 5: throttle/debounce coalesces rapid calls; only latest executes"
+            ],
+            "PASS_TO_PASS": [
+                "compatibility: optimized finds the same matches as legacy (>=2 chars)"
+            ]
         }
-        
+        