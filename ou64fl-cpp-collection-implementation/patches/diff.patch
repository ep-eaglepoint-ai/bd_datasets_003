diff --git a/repository_after/main.cpp b/repository_after/main.cpp
new file mode 100644
index 00000000..e46c8609
--- /dev/null
+++ b/repository_after/main.cpp
@@ -0,0 +1,34 @@
+#include "record_processor.h"
+#include <iostream>
+#include <cstdlib>
+
+/**
+ * @brief Entry point of the program
+ * 
+ * Demonstrates the record processing functionality with sample data.
+ * In a real system, records would come from a database or API.
+ */
+int main() {
+    try {
+        RecordProcessor processor;
+        
+        // Load records from in-memory source
+        std::vector<Record> records = createSampleData();
+        
+        // Process all records
+        processor.processRecords(records);
+        
+        // Generate and output the report
+        processor.generateReport(std::cout);
+        
+        return EXIT_SUCCESS;
+        
+    } catch (const InvalidDataException& e) {
+        std::cerr << "ERROR: " << e.what() << std::endl;
+        return EXIT_FAILURE;
+        
+    } catch (const std::exception& e) {
+        std::cerr << "Unexpected error: " << e.what() << std::endl;
+        return EXIT_FAILURE;
+    }
+}
\ No newline at end of file
diff --git a/repository_after/record_processor.cpp b/repository_after/record_processor.cpp
new file mode 100644
index 00000000..ee9f649d
--- /dev/null
+++ b/repository_after/record_processor.cpp
@@ -0,0 +1,70 @@
+#include "record_processor.h"
+#include <iostream>
+#include <sstream>
+#include <algorithm>
+
+void RecordProcessor::validateRecord(const Record& record) const {
+    if (record.value < 0) {
+        std::ostringstream oss;
+        oss << "Record with ID " << record.id 
+            << " in category '" << record.category 
+            << "' has negative value: " << record.value;
+        throw InvalidDataException(oss.str());
+    }
+    
+    if (record.category.empty()) {
+        std::ostringstream oss;
+        oss << "Record with ID " << record.id 
+            << " has empty category";
+        throw InvalidDataException(oss.str());
+    }
+}
+
+void RecordProcessor::processRecord(const Record& record) {
+    validateRecord(record);
+    
+    auto it = categories.find(record.category);
+    if (it == categories.end()) {
+        // Create new category summary
+        it = categories.emplace(record.category, CategorySummary(record.category)).first;
+    }
+    
+    // Update the summary
+    it->second.count += 1;
+    it->second.total += record.value;
+}
+
+void RecordProcessor::processRecords(const std::vector<Record>& records) {
+    for (const auto& record : records) {
+        processRecord(record);
+    }
+}
+
+void RecordProcessor::generateReport(std::ostream& os) const {
+    // Categories are already stored in lexicographical order in std::map
+    for (const auto& [category_name, summary] : categories) {
+        os << category_name 
+           << " | COUNT=" << summary.count 
+           << " | TOTAL=" << summary.total 
+           << "\n";
+    }
+}
+
+void RecordProcessor::clear() {
+    categories.clear();
+}
+
+std::vector<Record> createSampleData() {
+    return {
+        {1, "Electronics", 150},
+        {2, "Books", 25},
+        {3, "Electronics", 200},
+        {4, "Clothing", 75},
+        {5, "Books", 15},
+        {6, "Clothing", 125},
+        {7, "Electronics", 100},
+        {8, "Books", 30},
+        {9, "Home", 250},
+        {10, "Clothing", 50}
+    };
+}
\ No newline at end of file
diff --git a/repository_after/record_processor.h b/repository_after/record_processor.h
new file mode 100644
index 00000000..8bf577f3
--- /dev/null
+++ b/repository_after/record_processor.h
@@ -0,0 +1,92 @@
+#ifndef RECORD_PROCESSOR_H
+#define RECORD_PROCESSOR_H
+
+#include <string>
+#include <vector>
+#include <map>
+#include <stdexcept>
+#include <ostream>
+
+/**
+ * @brief Represents a single input record
+ */
+struct Record {
+    int id;
+    std::string category;
+    int value;
+};
+
+/**
+ * @brief Represents aggregated data for a category
+ */
+struct CategorySummary {
+    std::string name;
+    int count;
+    int total;
+    
+    CategorySummary(const std::string& category_name) 
+        : name(category_name), count(0), total(0) {}
+};
+
+/**
+ * @brief Exception thrown when invalid data is encountered
+ */
+class InvalidDataException : public std::runtime_error {
+public:
+    explicit InvalidDataException(const std::string& message)
+        : std::runtime_error(message) {}
+};
+
+/**
+ * @brief Main processor for records - handles validation and aggregation
+ */
+class RecordProcessor {
+private:
+    std::map<std::string, CategorySummary> categories;
+    
+    void validateRecord(const Record& record) const;
+    
+public:
+    RecordProcessor() = default;
+    
+    /**
+     * @brief Process a single record
+     * @param record The record to process
+     * @throws InvalidDataException if record value is negative
+     */
+    void processRecord(const Record& record);
+    
+    /**
+     * @brief Process multiple records
+     * @param records Vector of records to process
+     * @throws InvalidDataException if any record has invalid data
+     */
+    void processRecords(const std::vector<Record>& records);
+    
+    /**
+     * @brief Generate formatted report to output stream
+     * @param os Output stream to write to
+     */
+    void generateReport(std::ostream& os) const;
+    
+    /**
+     * @brief Get all category summaries (for testing)
+     * @return Map of category names to summaries
+     */
+    const std::map<std::string, CategorySummary>& getCategorySummaries() const {
+        return categories;
+    }
+    
+    /**
+     * @brief Clear all processed data
+     */
+    void clear();
+};
+
+/**
+ * @brief Utility function to create sample data for demonstration
+ * @return Vector of sample records
+ */
+std::vector<Record> createSampleData();
+
+#endif // RECORD_PROCESSOR_H
\ No newline at end of file
