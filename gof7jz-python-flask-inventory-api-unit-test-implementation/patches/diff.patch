diff --git a/repository_after/.gitkeep b/repository_after/.gitkeep
new file mode 100644
index 0000000..e69de29
diff --git a/repository_before/pytest.ini b/repository_before/pytest.ini
deleted file mode 100644
index 9855d94..0000000
--- a/repository_before/pytest.ini
+++ /dev/null
@@ -1,6 +0,0 @@
-[pytest]
-testpaths = tests
-python_files = test_*.py
-python_classes = Test*
-python_functions = test_*
-addopts = -v --tb=short
diff --git a/repository_after/tests/test_inventory.py b/repository_after/tests/test_inventory.py
new file mode 100644
index 0000000..2cd9e09
--- /dev/null
+++ b/repository_after/tests/test_inventory.py
@@ -0,0 +1,442 @@
+import pytest
+import os
+import jwt
+import json
+from datetime import datetime, timedelta
+from unittest.mock import patch, MagicMock
+from app import create_app, db
+from app.models import User, InventoryItem, Alert, StockMovement
+from app.services.stock_service import StockService
+
+@pytest.fixture(scope='function')
+def app():
+    app = create_app({
+        'TESTING': True,
+        'SQLALCHEMY_DATABASE_URI': 'sqlite:///:memory:',
+        'SECRET_KEY': 'test-secret-key',
+        'SQLALCHEMY_TRACK_MODIFICATIONS': False
+    })
+    
+    with app.app_context():
+        db.create_all()
+        yield app
+        db.session.remove()
+        db.drop_all()
+
+@pytest.fixture(scope='function')
+def client(app):
+    return app.test_client()
+
+@pytest.fixture(scope='function')
+def auth_headers(client):
+    """Fixture to provide authentication headers for protected endpoints."""
+    client.post('/api/auth/register', json={
+        'username': 'testuser',
+        'password': 'testpassword'
+    })
+    response = client.post('/api/auth/login', json={
+        'username': 'testuser',
+        'password': 'testpassword'
+    })
+    token = response.get_json().get('token')
+    return {'Authorization': f'Bearer {token}'}
+
+# --- Auth Tests ---
+# Note: Logout functionality is missing from implementation.
+# and thus cannot test it.
+
+def test_auth_register_success(client):
+    response = client.post('/api/auth/register', json={
+        'username': 'user1',
+        'password': 'password123'
+    })
+    assert response.status_code == 201
+    data = response.get_json()
+    assert data['username'] == 'user1'
+    assert 'id' in data
+
+def test_auth_register_missing_fields(client):
+    response = client.post('/api/auth/register', json={'username': 'user1'})
+    assert response.status_code == 400
+    assert 'error' in response.get_json()
+
+def test_auth_register_duplicate_username(client):
+    client.post('/api/auth/register', json={'username': 'user1', 'password': 'p'})
+    response = client.post('/api/auth/register', json={'username': 'user1', 'password': 'p'})
+    assert response.status_code == 409
+    assert 'exists' in response.get_json()['error']
+
+def test_auth_login_success(client):
+    client.post('/api/auth/register', json={'username': 'user1', 'password': 'password123'})
+    response = client.post('/api/auth/login', json={'username': 'user1', 'password': 'password123'})
+    assert response.status_code == 200
+    data = response.get_json()
+    assert 'token' in data
+    assert 'user_id' in data
+
+def test_auth_login_invalid_password(client):
+    client.post('/api/auth/register', json={'username': 'user1', 'password': 'password123'})
+    response = client.post('/api/auth/login', json={'username': 'user1', 'password': 'wrong'})
+    assert response.status_code == 401
+    assert 'Invalid credentials' in response.get_json()['error']
+
+def test_auth_login_disabled_user(app, client):
+    from app.routes.auth import hash_password
+    with app.app_context():
+        user = User(username='disabled', password_hash=hash_password('p'), is_active=False)
+        db.session.add(user)
+        db.session.commit()
+    
+    response = client.post('/api/auth/login', json={'username': 'disabled', 'password': 'p'})
+    assert response.status_code == 403
+    assert 'disabled' in response.get_json()['error'].lower()
+
+def test_auth_refresh_token(client, auth_headers):
+    response = client.post('/api/auth/refresh', headers=auth_headers)
+    assert response.status_code == 200
+    assert 'token' in response.get_json()
+
+def test_auth_me_endpoint(client, auth_headers):
+    response = client.get('/api/auth/me', headers=auth_headers)
+    assert response.status_code == 200
+    assert response.get_json()['username'] == 'testuser'
+
+def test_auth_token_expired(app, client):
+    payload = {
+        'user_id': 1,
+        'exp': datetime.utcnow() - timedelta(seconds=1)
+    }
+    from flask import current_app
+    token = jwt.encode(payload, app.config['SECRET_KEY'], algorithm='HS256')
+    
+    response = client.get('/api/auth/me', headers={'Authorization': f'Bearer {token}'})
+    assert response.status_code == 401
+    assert 'expired' in response.get_json()['error'].lower()
+
+def test_auth_token_invalid(client):
+    response = client.get('/api/auth/me', headers={'Authorization': 'Bearer garbage'})
+    assert response.status_code == 401
+    assert 'Invalid' in response.get_json()['error']
+
+# --- Inventory Tests ---
+
+def test_inv_create_item_success(client, auth_headers):
+    response = client.post('/api/inventory', headers=auth_headers, json={
+        'sku': 'SKU1', 'name': 'Item 1', 'unit_price': 10.5, 'quantity': 100
+    })
+    assert response.status_code == 201
+    assert response.get_json()['sku'] == 'SKU1'
+
+def test_inv_create_item_missing_fields(client, auth_headers):
+    response = client.post('/api/inventory', headers=auth_headers, json={'sku': 'SKU2'})
+    assert response.status_code == 400
+    assert 'error' in response.get_json()
+
+def test_inv_create_item_duplicate_sku(client, auth_headers):
+    client.post('/api/inventory', headers=auth_headers, json={
+        'sku': 'DUPE', 'name': 'Item 1', 'unit_price': 10.5, 'quantity': 100
+    })
+    response = client.post('/api/inventory', headers=auth_headers, json={
+        'sku': 'DUPE', 'name': 'Item 2', 'unit_price': 12.5, 'quantity': 50
+    })
+    assert response.status_code == 409
+    assert 'exists' in response.get_json()['error']
+
+def test_inv_list_items(client, auth_headers):
+    client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0})
+    client.post('/api/inventory', headers=auth_headers, json={'sku': 'S2', 'name': 'N2', 'unit_price': 2.0})
+    
+    response = client.get('/api/inventory', headers=auth_headers)
+    assert response.status_code == 200
+    data = response.get_json()
+    assert len(data['items']) >= 2
+    assert 'total' in data
+
+def test_inv_get_item_success(client, auth_headers):
+    res = client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0})
+    item_id = res.get_json()['id']
+    
+    response = client.get(f'/api/inventory/{item_id}', headers=auth_headers)
+    assert response.status_code == 200
+    assert response.get_json()['sku'] == 'S1'
+
+def test_inv_get_item_not_found(client, auth_headers):
+    response = client.get('/api/inventory/999', headers=auth_headers)
+    assert response.status_code == 404
+
+def test_inv_update_item(client, auth_headers):
+    res = client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0})
+    item_id = res.get_json()['id']
+    
+    response = client.put(f'/api/inventory/{item_id}', headers=auth_headers, json={'name': 'Updated', 'unit_price': 2.0})
+    assert response.status_code == 200
+    
+    res = client.get(f'/api/inventory/{item_id}', headers=auth_headers)
+    assert res.get_json()['name'] == 'Updated'
+    assert res.get_json()['unit_price'] == 2.0
+
+def test_inv_update_item_not_found(client, auth_headers):
+    response = client.put('/api/inventory/9999', headers=auth_headers, json={'name': 'Updated'})
+    assert response.status_code == 404
+    assert 'not found' in response.get_json()['error'].lower()
+
+def test_inv_delete_item_success(client, auth_headers):
+    res = client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0})
+    item_id = res.get_json()['id']
+    
+    response = client.delete(f'/api/inventory/{item_id}', headers=auth_headers)
+    assert response.status_code == 200
+    
+    res = client.get(f'/api/inventory/{item_id}', headers=auth_headers)
+    assert res.status_code == 404
+
+def test_inv_delete_item_not_found(client, auth_headers):
+    response = client.delete('/api/inventory/9999', headers=auth_headers)
+    assert response.status_code == 404
+    assert 'not found' in response.get_json()['error'].lower()
+
+def test_inv_delete_item_with_reserved_stock(client, auth_headers):
+    res = client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0, 'quantity': 10})
+    item_id = res.get_json()['id']
+    client.post(f'/api/inventory/{item_id}/reserve', headers=auth_headers, json={'quantity': 5})
+    
+    response = client.delete(f'/api/inventory/{item_id}', headers=auth_headers)
+    assert response.status_code == 400
+    assert 'reserved' in response.get_json()['error']
+
+def test_inv_adjust_stock_in(client, auth_headers):
+    res = client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0, 'quantity': 10})
+    item_id = res.get_json()['id']
+    
+    response = client.post(f'/api/inventory/{item_id}/adjust', headers=auth_headers, json={'quantity': 5, 'type': 'IN'})
+    assert response.status_code == 200
+    assert response.get_json()['new_quantity'] == 15
+
+def test_inv_adjust_stock_out_insufficient(client, auth_headers):
+    res = client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0, 'quantity': 10})
+    item_id = res.get_json()['id']
+    
+    response = client.post(f'/api/inventory/{item_id}/adjust', headers=auth_headers, json={'quantity': 15, 'type': 'OUT'})
+    assert response.status_code == 400
+    assert 'Insufficient' in response.get_json()['error']
+
+def test_inv_adjust_stock_not_found(client, auth_headers):
+    response = client.post('/api/inventory/9999/adjust', headers=auth_headers, json={'quantity': 5, 'type': 'IN'})
+    assert response.status_code == 400
+    assert 'not found' in response.get_json()['error'].lower()
+
+def test_inv_reserve_stock_success(client, auth_headers):
+    res = client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0, 'quantity': 10})
+    item_id = res.get_json()['id']
+    
+    response = client.post(f'/api/inventory/{item_id}/reserve', headers=auth_headers, json={'quantity': 5})
+    assert response.status_code == 200
+    data = response.get_json()
+    assert data['reserved'] == 5
+    assert data['available'] == 5
+
+def test_inv_reserve_stock_not_found(client, auth_headers):
+    response = client.post('/api/inventory/9999/reserve', headers=auth_headers, json={'quantity': 5})
+    assert response.status_code == 400
+    assert 'not found' in response.get_json()['error'].lower()
+
+def test_service_reserve_insufficient(app):
+    with app.app_context():
+        item = InventoryItem(sku='RES_FAIL', name='Res Fail', quantity=10, unit_price=10.0)
+        db.session.add(item)
+        db.session.commit()
+        
+        service = StockService()
+        with pytest.raises(ValueError, match="Insufficient"):
+            service.reserve_stock(item.id, 11)
+
+def test_inv_release_stock_success(app):
+    with app.app_context():
+        item = InventoryItem(sku='REL_TEST', name='Rel Test', quantity=50, unit_price=10.0)
+        item.reserved = 20
+        db.session.add(item)
+        db.session.commit()
+        
+        service = StockService()
+        
+        # Success case
+        res = service.release_reservation(item.id, 5)
+        assert res['reserved'] == 15
+        assert res['available'] == 35
+        assert item.reserved == 15
+        
+        # Release more than reserved error
+        with pytest.raises(ValueError, match="more than reserved"):
+            service.release_reservation(item.id, 16)
+
+# --- Alerts Tests ---
+
+def test_alerts_list(client, auth_headers):
+    res = client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0, 'quantity': 5, 'reorder_point': 10})
+    client.post('/api/alerts/check', headers=auth_headers)
+    
+    response = client.get('/api/alerts', headers=auth_headers)
+    assert response.status_code == 200
+    assert len(response.get_json()['alerts']) >= 1
+
+def test_alerts_resolve(client, auth_headers):
+    client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0, 'quantity': 5, 'reorder_point': 10})
+    client.post('/api/alerts/check', headers=auth_headers)
+    
+    res = client.get('/api/alerts', headers=auth_headers)
+    alert_id = res.get_json()['alerts'][0]['id']
+    
+    response = client.post(f'/api/alerts/{alert_id}/resolve', headers=auth_headers)
+    assert response.status_code == 200
+    
+    res = client.get('/api/alerts', headers=auth_headers)
+    assert len(res.get_json()['alerts']) == 0
+
+def test_alerts_check_manual(client, auth_headers):
+    client.post('/api/inventory', headers=auth_headers, json={'sku': 'S1', 'name': 'N1', 'unit_price': 1.0, 'quantity': 5, 'reorder_point': 10})
+    response = client.post('/api/alerts/check', headers=auth_headers)
+    assert response.status_code == 200
+    assert response.get_json()['new_alerts'] >= 1
+
+# --- Service Tests & Edge Cases ---
+
+def test_service_stock_calculations(app):
+    with app.app_context():
+        item = InventoryItem(sku='SKU_CALC', name='Calc Item', quantity=100, unit_price=10.0, reorder_point=20)
+        db.session.add(item)
+        db.session.commit()
+        
+        service = StockService()
+        
+        # Available calculation
+        service.reserve_stock(item.id, 30)
+        assert item.available == 70
+        
+        # Sequential adjustments
+        service.adjust_stock(item.id, 20, 'IN')
+        assert item.quantity == 120
+        assert item.available == 90
+        
+        # Insufficient stock error
+        with pytest.raises(ValueError, match="Insufficient"):
+            service.adjust_stock(item.id, 100, 'OUT')
+            
+        # Negative reserve error
+        with pytest.raises(ValueError, match="negative"):
+            service.reserve_stock(item.id, -1)
+
+def test_service_alert_generation(app):
+    with app.app_context():
+        item = InventoryItem(sku='ALERT_GEN', name='Alert Gen', quantity=50, unit_price=10.0, reorder_point=20)
+        db.session.add(item)
+        db.session.commit()
+        
+        service = StockService()
+        
+        # Drops below reorder point
+        service.adjust_stock(item.id, 40, 'OUT')
+        assert item.needs_reorder is True
+        
+        alert = Alert.query.filter_by(item_id=item.id, is_resolved=False).first()
+        assert alert is not None
+        assert 'below reorder point' in alert.message
+
+def test_service_no_duplicate_alerts(app):
+    with app.app_context():
+        item = InventoryItem(sku='DUPE_CHECK', name='Dupe Check', quantity=5, unit_price=10.0, reorder_point=10)
+        db.session.add(item)
+        db.session.commit()
+        
+        service = StockService()
+        service.check_reorder_alerts()
+        count1 = Alert.query.filter_by(item_id=item.id).count()
+        
+        service.check_reorder_alerts()
+        count2 = Alert.query.filter_by(item_id=item.id).count()
+        
+        assert count1 == 1
+        assert count2 == 1
+
+def test_auth_register_null_values(client):
+    response = client.post('/api/auth/register', json={
+        'username': None,
+        'password': 'password123'
+    })
+    assert response.status_code == 400
+    assert 'required' in response.get_json()['error']
+
+
+def test_inv_create_item_null_values(client, auth_headers):
+    # Testing with explicitly null values which should be rejected
+    response = client.post('/api/inventory', headers=auth_headers, json={
+        'sku': None, 'name': None, 'unit_price': None, 'quantity': 100
+    })
+    assert response.status_code == 400
+    # The API checks explicitly for presence of keys or truthiness of values
+    assert 'error' in response.get_json()
+
+
+def test_service_complex_sequential_movements(app):
+    with app.app_context():
+        # Setup item with 100 units
+        item = InventoryItem(sku='SEQ_TEST', name='Seq Test', quantity=100, unit_price=10.0)
+        db.session.add(item)
+        db.session.commit()
+        
+        service = StockService()
+        
+        # 1. Reserve 20 (Simulate Order 1)
+        service.reserve_stock(item.id, 20)
+        
+        # 2. Adjust OUT 10 (Simulate Order 2 shipping immediately)
+        service.adjust_stock(item.id, 10, 'OUT')
+        
+        # 3. Reserve 30 (Simulate Order 3)
+        service.reserve_stock(item.id, 30)
+        
+        # 4. Release 10 from Order 1 (Order 1 reduced/canceled partially)
+        service.release_reservation(item.id, 10)
+        
+        # Check intermediate state
+        # Total Qty was 100 -> -10 (OUT) = 90
+        # Reserved was 0 -> +20 -> +30 -> -10 = 40
+        # Available should be 90 - 40 = 50
+        
+        item = InventoryItem.query.get(item.id)
+        assert item.quantity == 90
+        assert item.reserved == 40
+        assert item.available == 50
+        
+        # 5. Try to reserve 60 (Should fail, only 50 available)
+        with pytest.raises(ValueError, match="Insufficient"):
+            service.reserve_stock(item.id, 60)
+            
+        # 6. Adjust IN 50 (Restock)
+        service.adjust_stock(item.id, 50, 'IN')
+        
+        # Final Verification
+        db.session.refresh(item)
+        assert item.quantity == 140  # 90 + 50
+        assert item.reserved == 40   # Unchanged
+        assert item.available == 100 # 140 - 40
+
+# Although no actual email service exists, we mock a hypothetical notification call
+@patch('app.services.stock_service.StockService.check_reorder_alerts')
+def test_mock_external_notification_placeholder(mock_check, client, auth_headers):
+    client.post('/api/alerts/check', headers=auth_headers)
+    assert mock_check.called
+
+def test_edge_case_negative_quantity_adjustment(client, auth_headers):
+    res = client.post('/api/inventory', headers=auth_headers, json={'sku': 'NEG', 'name': 'N', 'unit_price': 1.0, 'quantity': 10})
+    item_id = res.get_json()['id']
+    # Adjusting to negative total quantity
+    response = client.post(f'/api/inventory/{item_id}/adjust', headers=auth_headers, json={'quantity': -20, 'type': 'ADJUSTMENT'})
+    assert response.status_code == 400
+    assert 'negative' in response.get_json()['error']
+
+def test_edge_case_zero_quantity_reservation(client, auth_headers):
+    res = client.post('/api/inventory', headers=auth_headers, json={'sku': 'ZERO', 'name': 'Z', 'unit_price': 1.0, 'quantity': 10})
+    item_id = res.get_json()['id']
+    response = client.post(f'/api/inventory/{item_id}/reserve', headers=auth_headers, json={'quantity': 0})
+    assert response.status_code == 200
+    assert response.get_json()['reserved'] == 0
