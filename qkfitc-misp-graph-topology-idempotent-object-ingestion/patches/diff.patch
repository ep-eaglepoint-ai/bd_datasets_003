diff -Naur '--exclude=__pycache__' repository_before/main.py repository_after/main.py
--- repository_before/main.py	1970-01-01 03:00:00.000000000 +0300
+++ repository_after/main.py	2026-02-02 10:17:43.836704179 +0300
@@ -0,0 +1,41 @@
+import json
+import os
+import sys
+from phishing_feed_ingestor import PhishingFeedIngestor
+
+def main():
+    misp_url = os.getenv("MISP_URL", "https://localhost")
+    misp_key = os.getenv("MISP_KEY", "")
+    
+    if not misp_key:
+        print("Error: MISP_KEY environment variable not set.")
+        sys.exit(1)
+
+    # In a real scenario, this might be loaded from a file or API
+    # For demonstration/testing, we use a sample path
+    input_path = os.getenv("INPUT_PATH", "tests/resources/sample_input.json")
+    
+    if not os.path.exists(input_path):
+        print(f"Error: Input file {input_path} not found.")
+        sys.exit(1)
+
+    with open(input_path, 'r') as f:
+        try:
+            data = json.load(f)
+        except json.JSONDecodeError:
+            print(f"Error: Failed to decode JSON from {input_path}")
+            sys.exit(1)
+
+    try:
+        ingestor = PhishingFeedIngestor(misp_url, misp_key)
+        results = ingestor.ingest_data(data)
+        print(f"Ingestion complete: {results}")
+    except ConnectionError as e:
+        print(f"Connection Error: {e}")
+        sys.exit(1)
+    except Exception as e:
+        print(f"Unexpected Error: {e}")
+        sys.exit(1)
+
+if __name__ == "__main__":
+    main()
diff -Naur '--exclude=__pycache__' repository_before/phishing_feed_ingestor.py repository_after/phishing_feed_ingestor.py
--- repository_before/phishing_feed_ingestor.py	1970-01-01 03:00:00.000000000 +0300
+++ repository_after/phishing_feed_ingestor.py	2026-02-02 10:35:07.580983586 +0300
@@ -0,0 +1,113 @@
+import json
+from typing import List, Dict, Optional
+from pymisp import PyMISP, MISPEvent, MISPObject, MISPAttribute, MISPObjectReference
+import logging
+
+# Configure logging
+logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
+logger = logging.getLogger(__name__)
+
+class PhishingFeedIngestor:
+    def __init__(self, misp_url: str, misp_key: str, ssl: bool = False):
+        try:
+            self.misp = PyMISP(misp_url, misp_key, ssl=ssl)
+            # Verify connectivity
+            self.misp.get_version()
+        except Exception as e:
+            logger.error(f"Failed to initialize PyMISP: {e}")
+            raise ConnectionError(f"Could not connect to MISP at {misp_url}")
+
+    def get_or_create_event(self, event_name: str) -> MISPEvent:
+        """Retrieves an existing event by name or creates a new one."""
+        search_result = self.misp.search(controller='events', eventinfo=event_name, pythonify=True)
+        if search_result:
+            return search_result[0]
+        
+        event = MISPEvent()
+        event.info = event_name
+        event.distribution = 0  # Your Organization only
+        event.threat_level_id = 2  # Medium
+        event.analysis = 0  # Initial
+        
+        event = self.misp.add_event(event, pythonify=True)
+        # Add a standard tag
+        self.misp.tag(event.uuid, 'tlp:white')
+        self.misp.tag(event.uuid, 'veris:malware:variety="phishing"')
+        return event
+
+    def ingest_data(self, data: List[Dict[str, str]], publish: bool = False) -> Dict[str, int]:
+        """Ingests a list of phishing entries into MISP."""
+        event = self.get_or_create_event("Daily Phishing Feed")
+        stats = {"added_objects": 0, "added_attributes": 0, "added_relationships": 0}
+
+        # Refresh event to get latest objects/attributes for idempotency
+        event = self.misp.get_event(event.id, pythonify=True)
+
+        for entry in data:
+            filename = entry.get('filename')
+            sha256 = entry.get('sha256')
+            url = entry.get('payload_delivery_url')
+
+            if not all([filename, sha256, url]):
+                logger.warning(f"Skipping incomplete entry: {entry}")
+                continue
+
+            # 1. Handle File Object (Idempotency check by sha256)
+            file_obj = self._get_existing_file_object(event, sha256)
+            if not file_obj:
+                file_obj = MISPObject('file')
+                file_obj.add_attribute('filename', value=filename)
+                file_obj.add_attribute('sha256', value=sha256)
+                file_obj = self.misp.add_object(event.id, file_obj, pythonify=True)
+                stats["added_objects"] += 1
+                # Update local event state for same-run idempotency
+                event.objects.append(file_obj)
+            
+            # 2. Handle URL Attribute (Idempotency check by value)
+            url_attr = self._get_existing_url_attribute(event, url)
+            if not url_attr:
+                url_attr = MISPAttribute()
+                url_attr.type = 'url'
+                url_attr.value = url
+                url_attr = self.misp.add_attribute(event.id, url_attr, pythonify=True)
+                stats["added_attributes"] += 1
+                # Update local event state
+                event.attributes.append(url_attr)
+
+            # 3. Create Relationship: File Object -> downloaded-from -> URL Attribute
+            # Requirement: File Object is the Source, URL is the Target
+            if not self._relationship_exists(file_obj, url_attr.uuid, 'downloaded-from'):
+                ref = self.misp.add_object_reference(file_obj.uuid, url_attr.uuid, 'downloaded-from', pythonify=True)
+                stats["added_relationships"] += 1
+                # Update local object state
+                if not hasattr(file_obj, 'references'):
+                    file_obj.references = []
+                file_obj.references.append(ref)
+
+        if publish and not event.published:
+            self.misp.publish(event.id)
+            logger.info(f"Event {event.id} published.")
+
+        return stats
+
+    def _get_existing_file_object(self, event: MISPEvent, sha256: str) -> Optional[MISPObject]:
+        for obj in event.objects:
+            if obj.name == 'file':
+                for attr in obj.attributes:
+                    if attr.object_relation == 'sha256' and attr.value == sha256:
+                        return obj
+        return None
+
+    def _get_existing_url_attribute(self, event: MISPEvent, url: str) -> Optional[MISPAttribute]:
+        for attr in event.attributes:
+            if attr.type == 'url' and attr.value == url:
+                return attr
+        return None
+
+    def _relationship_exists(self, file_obj: MISPObject, target_uuid: str, relationship_type: str) -> bool:
+        if not hasattr(file_obj, 'references') or not file_obj.references:
+            return False
+        for ref in file_obj.references:
+            if ref.referenced_uuid == target_uuid and ref.relationship_type == relationship_type:
+                return True
+        return False
