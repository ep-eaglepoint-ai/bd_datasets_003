import { createBooking } from '../../repository_after/api/src/services/bookings/bookings';
import { createProviderProfile, createService } from '../../repository_after/api/src/services/providers/providers';
import { createRecurringAvailability } from '../../repository_after/api/src/services/availability/availability';
import { Role, User } from '../../repository_after/api/src/lib/auth';
import { DateTime } from 'luxon';

// Mock Prisma with performance monitoring
const buildLargeDatasetMockPrisma = () => {
  const state: any = {
    providerProfiles: [],
    services: [],
    recurringAvailability: [],
    bookings: []
  };
  
  let idSeq = 1;
  const performanceStats = {
    totalQueries: 0,
    totalQueryTime: 0,
    avgQueryTime: 0,
    maxQueryTime: 0,
    queryTimes: [] as number[],
    memoryUsage: 0
  };

  const trackPerformance = (operation: () => Promise<any>) => {
    const startTime = Date.now();
    performanceStats.totalQueries++;
    
    return operation().then(result => {
      const endTime = Date.now();
      const queryTime = endTime - startTime;
      
      performanceStats.totalQueryTime += queryTime;
      performanceStats.maxQueryTime = Math.max(performanceStats.maxQueryTime, queryTime);
      performanceStats.queryTimes.push(queryTime);
      performanceStats.avgQueryTime = performanceStats.totalQueryTime / performanceStats.totalQueries;
      
      return result;
    });
  };

  return {
    providerProfile: {
      create: async ({ data }: any) => {
        return trackPerformance(async () => {
          const profile = { id: idSeq++, ...data, createdAt: new Date(), updatedAt: new Date() };
          state.providerProfiles.push(profile);
          performanceStats.memoryUsage += JSON.stringify(profile).length;
          return profile;
        });
      },
      findUnique: async ({ where }: any) => {
        return trackPerformance(async () => {
          // Simulate index lookup
          await new Promise(resolve => setTimeout(resolve, Math.random() * 2));
          if (where.id) {
            return state.providerProfiles.find((p: any) => p.id === where.id) || null;
          }
          if (where.userId) {
            return state.providerProfiles.find((p: any) => p.userId === where.userId) || null;
          }
          return null;
        });
      },
      findMany: async ({ where }: any) => {
        return trackPerformance(async () => {
          // Simulate table scan for large datasets
          await new Promise(resolve => setTimeout(resolve, Math.random() * 10));
          
          if (where?.userId) {
            return state.providerProfiles.filter((p: any) => p.userId === where.userId);
          }
          return state.providerProfiles;
        });
      }
    },
    service: {
      create: async ({ data }: any) => {
        return trackPerformance(async () => {
          const service = { id: idSeq++, ...data, createdAt: new Date(), updatedAt: new Date() };
          state.services.push(service);
          performanceStats.memoryUsage += JSON.stringify(service).length;
          return service;
        });
      },
      findUnique: async ({ where }: any) => {
        return trackPerformance(async () => {
          await new Promise(resolve => setTimeout(resolve, Math.random() * 2));
          return state.services.find((s: any) => s.id === where.id) || null;
        });
      },
      findMany: async ({ where }: any) => {
        return trackPerformance(async () => {
          await new Promise(resolve => setTimeout(resolve, Math.random() * 8));
          
          if (where?.providerId) {
            return state.services.filter((s: any) => s.providerId === where.providerId);
          }
          return state.services;
        });
      }
    },
    recurringAvailability: {
      create: async ({ data }: any) => {
        return trackPerformance(async () => {
          const recurring = { id: idSeq++, ...data, createdAt: new Date(), updatedAt: new Date() };
          state.recurringAvailability.push(recurring);
          performanceStats.memoryUsage += JSON.stringify(recurring).length;
          return recurring;
        });
      },
      findMany: async ({ where }: any) => {
        return trackPerformance(async () => {
          await new Promise(resolve => setTimeout(resolve, Math.random() * 5));
          
          if (where?.providerId) {
            return state.recurringAvailability.filter((r: any) => r.providerId === where.providerId);
          }
          return state.recurringAvailability;
        });
      }
    },
    booking: {
      create: async ({ data }: any) => {
        return trackPerformance(async () => {
          const booking = { id: idSeq++, ...data, createdAt: new Date(), updatedAt: new Date() };
          state.bookings.push(booking);
          performanceStats.memoryUsage += JSON.stringify(booking).length;
          return booking;
        });
      },
      findUnique: async ({ where }: any) => {
        return trackPerformance(async () => {
          await new Promise(resolve => setTimeout(resolve, Math.random() * 3));
          return state.bookings.find((b: any) => b.id === where.id) || null;
        });
      },
      findMany: async ({ where }: any) => {
        return trackPerformance(async () => {
          // Simulate expensive query on large dataset
          await new Promise(resolve => setTimeout(resolve, Math.random() * 15));
          
          let results = state.bookings;
          
          if (where?.OR) {
            results = results.filter((b: any) => {
              return where.OR.some((condition: any) => {
                if (condition.provider?.user?.id) {
                  const profile = state.providerProfiles.find((p: any) => p.id === b.providerId);
                  return profile?.userId === condition.provider.user.id;
                }
                if (condition.customerEmail) {
                  return b.customerEmail === condition.customerEmail;
                }
                return false;
              });
            });
          }
          
          if (where?.serviceId) {
            results = results.filter((b: any) => b.serviceId === where.serviceId);
          }
          
          return results;
        });
      },
      count: async ({ where }: any) => {
        return trackPerformance(async () => {
          await new Promise(resolve => setTimeout(resolve, Math.random() * 5));
          
          return state.bookings.filter((b: any) => {
            if (where?.serviceId && b.serviceId !== where.serviceId) return false;
            if (where?.startUtc && b.startUtc.getTime() === where.startUtc.getTime()) return false;
            if (where?.canceledAt === false && b.canceledAt) return false;
            return true;
          }).length;
        });
      }
    },
    $transaction: async (cb: any) => {
      return trackPerformance(async () => {
        await new Promise(resolve => setTimeout(resolve, Math.random() * 10));
        const tx = buildLargeDatasetMockPrisma();
        return cb(tx);
      });
    },
    getPerformanceStats: () => performanceStats,
    resetStats: () => {
      performanceStats.totalQueries = 0;
      performanceStats.totalQueryTime = 0;
      performanceStats.avgQueryTime = 0;
      performanceStats.maxQueryTime = 0;
      performanceStats.queryTimes = [];
      performanceStats.memoryUsage = 0;
    },
    getDatasetSize: () => ({
      providers: state.providerProfiles.length,
      services: state.services.length,
      availability: state.recurringAvailability.length,
      bookings: state.bookings.length
    })
  };
};

describe('Large Dataset Handling Tests', () => {
  let prisma: any;

  beforeEach(() => {
    prisma = buildLargeDatasetMockPrisma();
  });

  describe('Large Provider Dataset', () => {
    test('Should handle 1000+ providers efficiently', async () => {
      const startTime = Date.now();
      
      // Create 1000 providers
      const providerPromises = [];
      for (let i = 0; i < 1000; i++) {
        const provider = { 
          id: i + 1, 
          email: `provider${i}@test.com`, 
          role: Role.PROVIDER 
        };
        
        providerPromises.push(
          createProviderProfile(provider, {
            name: `Provider ${i}`,
            bio: `Bio for provider ${i}`
          }, prisma)
        );
      }
      
      const providers = await Promise.all(providerPromises);
      const endTime = Date.now();
      
      expect(providers).toHaveLength(1000);
      expect(endTime - startTime).toBeLessThan(10000); // Should complete within 10 seconds
      
      const stats = prisma.getPerformanceStats();
      expect(stats.totalQueries).toBe(1000);
      expect(stats.avgQueryTime).toBeLessThan(10); // Average query < 10ms
      
      const datasetSize = prisma.getDatasetSize();
      expect(datasetSize.providers).toBe(1000);
    });

    test('Should handle provider lookup in large dataset', async () => {
      // Create 5000 providers first
      for (let i = 0; i < 5000; i++) {
        const provider = { 
          id: i + 1, 
          email: `provider${i}@test.com`, 
          role: Role.PROVIDER 
        };
        
        await createProviderProfile(provider, {
          name: `Provider ${i}`,
          bio: `Bio for provider ${i}`
        }, prisma);
      }
      
      // Test lookup performance
      const lookupPromises = [];
      const startTime = Date.now();
      
      for (let i = 0; i < 100; i++) {
        const randomId = Math.floor(Math.random() * 5000) + 1;
        lookupPromises.push(
          prisma.providerProfile.findUnique({ where: { id: randomId } })
        );
      }
      
      await Promise.all(lookupPromises);
      const endTime = Date.now();
      
      expect(endTime - startTime).toBeLessThan(2000); // 100 lookups < 2 seconds
      
      const stats = prisma.getPerformanceStats();
      expect(stats.avgQueryTime).toBeLessThan(20); // Average lookup < 20ms
    });
  });

  describe('Large Service Dataset', () => {
    test('Should handle 10,000+ services efficiently', async () => {
      const provider = { id: 1, email: 'provider@test.com', role: Role.PROVIDER };
      
      const profile = await createProviderProfile(provider, {
        name: 'Large Dataset Provider',
        bio: 'Provider with many services'
      }, prisma);
      
      const startTime = Date.now();
      
      // Create 10,000 services
      const servicePromises = [];
      for (let i = 0; i < 10000; i++) {
        servicePromises.push(
          createService(provider, {
            name: `Service ${i}`,
            durationMinutes: 30 + (i % 8) * 15,
            capacity: 1 + (i % 5)
          }, prisma)
        );
      }
      
      const services = await Promise.all(servicePromises);
      const endTime = Date.now();
      
      expect(services).toHaveLength(10000);
      expect(endTime - startTime).toBeLessThan(30000); // Should complete within 30 seconds
      
      const stats = prisma.getPerformanceStats();
      expect(stats.totalQueries).toBe(10000);
      expect(stats.memoryUsage).toBeGreaterThan(1000000); // > 1MB of data
      
      const datasetSize = prisma.getDatasetSize();
      expect(datasetSize.services).toBe(10000);
    });

    test('Should handle service filtering in large dataset', async () => {
      const provider = { id: 1, email: 'provider@test.com', role: Role.PROVIDER };
      
      const profile = await createProviderProfile(provider, {
        name: 'Filter Test Provider',
        bio: 'Provider for filtering tests'
      }, prisma);
      
      // Create 5000 services with different properties
      for (let i = 0; i < 5000; i++) {
        await createService(provider, {
          name: `Service ${i}`,
          durationMinutes: 30 + (i % 8) * 15,
          capacity: 1 + (i % 5)
        }, prisma);
      }
      
      // Test filtering performance
      const startTime = Date.now();
      
      const services = await prisma.service.findMany({
        where: { providerId: profile.id }
      });
      
      const endTime = Date.now();
      
      expect(services).toHaveLength(5000);
      expect(endTime - startTime).toBeLessThan(5000); // Filter < 5 seconds
    });
  });

  describe('Large Booking Dataset', () => {
    test('Should handle 50,000+ bookings efficiently', async () => {
      const provider = { id: 1, email: 'provider@test.com', role: Role.PROVIDER };
      
      const profile = await createProviderProfile(provider, {
        name: 'High Volume Provider',
        bio: 'Provider with many bookings'
      }, prisma);
      
      const service = await createService(provider, {
        name: 'Popular Service',
        durationMinutes: 30,
        capacity: 1
      }, prisma);
      
      const startTime = Date.now();
      
      // Create 50,000 bookings
      const bookingPromises = [];
      for (let i = 0; i < 50000; i++) {
        const customer = { 
          id: i + 2, 
          email: `customer${i}@test.com`, 
          role: Role.CUSTOMER 
        };
        
        const slotTime = DateTime.now().plus({ 
          days: Math.floor(i / 24), 
          hours: i % 24 
        });
        
        bookingPromises.push(
          createBooking(customer, {
            providerId: profile.id,
            serviceId: service.id,
            startUtcISO: slotTime.toUTC().toISO()!,
            endUtcISO: slotTime.plus({ minutes: 30 }).toUTC().toISO()!,
            customerEmail: customer.email,
            cutoffHours: 24
          }, prisma)
        );
      }
      
      // Process in batches to avoid overwhelming
      const batchSize = 1000;
      for (let i = 0; i < bookingPromises.length; i += batchSize) {
        const batch = bookingPromises.slice(i, i + batchSize);
        await Promise.all(batch);
      }
      
      const endTime = Date.now();
      
      expect(endTime - startTime).toBeLessThan(120000); // Should complete within 2 minutes
      
      const stats = prisma.getPerformanceStats();
      expect(stats.totalQueries).toBe(50000);
      expect(stats.memoryUsage).toBeGreaterThan(5000000); // > 5MB of data
      
      const datasetSize = prisma.getDatasetSize();
      expect(datasetSize.bookings).toBe(50000);
    });

    test('Should handle booking queries in large dataset', async () => {
      const provider = { id: 1, email: 'provider@test.com', role: Role.PROVIDER };
      
      const profile = await createProviderProfile(provider, {
        name: 'Query Test Provider',
        bio: 'Provider for query testing'
      }, prisma);
      
      const service = await createService(provider, {
        name: 'Query Test Service',
        durationMinutes: 30,
        capacity: 1
      }, prisma);
      
      // Create 20,000 bookings
      for (let i = 0; i < 20000; i++) {
        const customer = { 
          id: i + 2, 
          email: `customer${i}@test.com`, 
          role: Role.CUSTOMER 
        };
        
        const slotTime = DateTime.now().plus({ days: i % 365, hours: i % 24 });
        
        await createBooking(customer, {
          providerId: profile.id,
          serviceId: service.id,
          startUtcISO: slotTime.toUTC().toISO()!,
          endUtcISO: slotTime.plus({ minutes: 30 }).toUTC().toISO()!,
          customerEmail: customer.email,
          cutoffHours: 24
        }, prisma);
      }
      
      // Test various query patterns
      const queryTests = [
        // Find bookings for specific service
        () => prisma.booking.findMany({
          where: { serviceId: service.id }
        }),
        
        // Count bookings
        () => prisma.booking.count({}),
        
        // Find recent bookings (simulated)
        () => prisma.booking.findMany({
          where: { serviceId: service.id }
        })
      ];
      
      const startTime = Date.now();
      const results = await Promise.all(queryTests.map(test => test()));
      const endTime = Date.now();
      
      expect(results[0]).toHaveLength(20000);
      expect(results[1]).toBe(20000);
      expect(endTime - startTime).toBeLessThan(10000); // All queries < 10 seconds
    });
  });

  describe('Complex Large Dataset Operations', () => {
    test('Should handle multi-table joins with large datasets', async () => {
      // Create 100 providers
      const providers = [];
      for (let i = 0; i < 100; i++) {
        const provider = { 
          id: i + 1, 
          email: `provider${i}@test.com`, 
          role: Role.PROVIDER 
        };
        
        const profile = await createProviderProfile(provider, {
          name: `Provider ${i}`,
          bio: `Bio for provider ${i}`
        }, prisma);
        
        providers.push({ provider, profile });
      }
      
      // Create 5 services per provider (500 total)
      const services = [];
      for (const { provider, profile } of providers) {
        for (let i = 0; i < 5; i++) {
          const service = await createService(provider, {
            name: `Service ${profile.id}-${i}`,
            durationMinutes: 30 + i * 15,
            capacity: 1 + i
          }, prisma);
          services.push(service);
        }
      }
      
      // Create 100 bookings per service (50,000 total)
      for (let serviceIndex = 0; serviceIndex < services.length; serviceIndex++) {
        const service = services[serviceIndex];
        
        for (let i = 0; i < 100; i++) {
          const customer = { 
            id: serviceIndex * 100 + i + 2, 
            email: `customer${serviceIndex}_${i}@test.com`, 
            role: Role.CUSTOMER 
          };
          
          const slotTime = DateTime.now().plus({ 
            days: Math.floor(i / 10), 
            hours: i % 10 
          });
          
          await createBooking(customer, {
            providerId: service.providerId,
            serviceId: service.id,
            startUtcISO: slotTime.toUTC().toISO()!,
            endUtcISO: slotTime.plus({ minutes: service.durationMinutes }).toUTC().toISO()!,
            customerEmail: customer.email,
            cutoffHours: 24
          }, prisma);
        }
      }
      
      const datasetSize = prisma.getDatasetSize();
      expect(datasetSize.providers).toBe(100);
      expect(datasetSize.services).toBe(500);
      expect(datasetSize.bookings).toBe(50000);
      
      // Test complex query (simulated join)
      const startTime = Date.now();
      
      const allBookings = await prisma.booking.findMany({
        where: { serviceId: services[0].id }
      });
      
      const endTime = Date.now();
      
      expect(allBookings).toHaveLength(100);
      expect(endTime - startTime).toBeLessThan(5000); // Complex query < 5 seconds
      
      const stats = prisma.getPerformanceStats();
      expect(stats.memoryUsage).toBeGreaterThan(10000000); // > 10MB
    });

    test('Should handle pagination with large datasets', async () => {
      const provider = { id: 1, email: 'provider@test.com', role: Role.PROVIDER };
      
      const profile = await createProviderProfile(provider, {
        name: 'Pagination Test Provider',
        bio: 'Provider for pagination testing'
      }, prisma);
      
      const service = await createService(provider, {
        name: 'Pagination Test Service',
        durationMinutes: 30,
        capacity: 1
      }, prisma);
      
      // Create 10,000 bookings
      for (let i = 0; i < 10000; i++) {
        const customer = { 
          id: i + 2, 
          email: `customer${i}@test.com`, 
          role: Role.CUSTOMER 
        };
        
        const slotTime = DateTime.now().plus({ days: i, hours: i % 24 });
        
        await createBooking(customer, {
          providerId: profile.id,
          serviceId: service.id,
          startUtcISO: slotTime.toUTC().toISO()!,
          endUtcISO: slotTime.plus({ minutes: 30 }).toUTC().toISO()!,
          customerEmail: customer.email,
          cutoffHours: 24
        }, prisma);
      }
      
      // Test pagination performance
      const pageSize = 100;
      const totalPages = Math.ceil(10000 / pageSize);
      
      const startTime = Date.now();
      
      // Simulate pagination by querying multiple times
      const paginationPromises = [];
      for (let page = 0; page < 10; page++) { // Test first 10 pages
        paginationPromises.push(
          prisma.booking.findMany({
            where: { serviceId: service.id }
          })
        );
      }
      
      const results = await Promise.all(paginationPromises);
      const endTime = Date.now();
      
      expect(results.length).toBe(10);
      expect(results[0]).toHaveLength(10000); // All results (mock doesn't paginate)
      expect(endTime - startTime).toBeLessThan(15000); // 10 pages < 15 seconds
    });
  });

  describe('Memory Management', () => {
    test('Should handle memory pressure with large datasets', async () => {
      const initialStats = prisma.getPerformanceStats();
      
      // Create large dataset
      const provider = { id: 1, email: 'provider@test.com', role: Role.PROVIDER };
      
      const profile = await createProviderProfile(provider, {
        name: 'Memory Test Provider',
        bio: 'Provider for memory testing'
      }, prisma);
      
      // Create many services with large descriptions
      for (let i = 0; i < 1000; i++) {
        await createService(provider, {
          name: `Service ${i}`,
          durationMinutes: 30,
          capacity: 1
        }, prisma);
      }
      
      const afterServicesStats = prisma.getPerformanceStats();
      
      // Create many bookings
      for (let i = 0; i < 5000; i++) {
        const customer = { 
          id: i + 2, 
          email: `customer${i}@test.com`, 
          role: Role.CUSTOMER 
        };
        
        const slotTime = DateTime.now().plus({ days: i % 365, hours: i % 24 });
        
        await createBooking(customer, {
          providerId: profile.id,
          serviceId: (i % 1000) + 1,
          startUtcISO: slotTime.toUTC().toISO()!,
          endUtcISO: slotTime.plus({ minutes: 30 }).toUTC().toISO()!,
          customerEmail: customer.email,
          cutoffHours: 24
        }, prisma);
      }
      
      const finalStats = prisma.getPerformanceStats();
      
      // Verify memory usage tracking
      expect(finalStats.memoryUsage).toBeGreaterThan(afterServicesStats.memoryUsage);
      expect(finalStats.memoryUsage).toBeGreaterThan(initialStats.memoryUsage);
      
      // Verify performance remains acceptable
      expect(finalStats.avgQueryTime).toBeLessThan(50);
    });
  });

  describe('Performance Regression Detection', () => {
    test('Should detect performance degradation with dataset growth', async () => {
      const performanceMetrics = [];
      
      // Test with increasing dataset sizes
      const datasetSizes = [100, 500, 1000, 2000];
      
      for (const size of datasetSizes) {
        prisma.resetStats();
        
        const provider = { id: 1, email: 'provider@test.com', role: Role.PROVIDER };
        
        const profile = await createProviderProfile(provider, {
          name: `Regression Test Provider ${size}`,
          bio: `Provider for regression testing with ${size} items`
        }, prisma);
        
        const service = await createService(provider, {
          name: 'Regression Test Service',
          durationMinutes: 30,
          capacity: 1
        }, prisma);
        
        // Create specified number of bookings
        const startTime = Date.now();
        
        for (let i = 0; i < size; i++) {
          const customer = { 
            id: i + 2, 
            email: `customer${i}@test.com`, 
            role: Role.CUSTOMER 
          };
          
          const slotTime = DateTime.now().plus({ days: i, hours: i % 24 });
          
          await createBooking(customer, {
            providerId: profile.id,
            serviceId: service.id,
            startUtcISO: slotTime.toUTC().toISO()!,
            endUtcISO: slotTime.plus({ minutes: 30 }).toUTC().toISO()!,
            customerEmail: customer.email,
            cutoffHours: 24
          }, prisma);
        }
        
        const endTime = Date.now();
        const stats = prisma.getPerformanceStats();
        
        performanceMetrics.push({
          datasetSize: size,
          totalTime: endTime - startTime,
          avgQueryTime: stats.avgQueryTime,
          maxQueryTime: stats.maxQueryTime,
          totalQueries: stats.totalQueries
        });
      }
      
      // Verify performance scales reasonably
      for (let i = 1; i < performanceMetrics.length; i++) {
        const current = performanceMetrics[i];
        const previous = performanceMetrics[i - 1];
        
        // Performance shouldn't degrade exponentially
        const sizeRatio = current.datasetSize / previous.datasetSize;
        const timeRatio = current.totalTime / previous.totalTime;
        
        // Time should scale sub-linearly with dataset size
        expect(timeRatio).toBeLessThan(sizeRatio * 1.5);
        
        // Average query time should remain reasonable
        expect(current.avgQueryTime).toBeLessThan(100);
      }
    });
  });
});
