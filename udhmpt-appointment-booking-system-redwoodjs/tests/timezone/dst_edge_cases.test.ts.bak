import { DateTime } from 'luxon';
import { generateSlots } from '../../repository_after/api/src/services/availability/availability';
import { expandWeeklyRules, mergeOverrides } from '../../repository_after/api/src/services/availability/availability';

describe('DST Edge Cases and Complex Timezone Scenarios', () => {
  
  describe('North America DST Transitions', () => {
    describe('Spring Forward (DST Start)', () => {
      test('America/New_York 2024 DST start - March 10, 2:00 AM jumps to 3:00 AM', () => {
        const tz = 'America/New_York';
        const dstDate = '2024-03-10'; // DST start date
        
        // Create availability that spans the missing hour
        const startLocal = DateTime.fromISO(`${dstDate}T01:00`, { zone: tz });
        const endLocal = DateTime.fromISO(`${dstDate}T04:00`, { zone: tz });
        
        const window = [{
          startUtcISO: startLocal.toUTC().toISO()!,
          endUtcISO: endLocal.toUTC().toISO()!
        }];
        
        // Generate 60-minute slots
        const slots = generateSlots(window, 60, 0, 0, tz);
        
        // Should generate slots for: 1:00 AM, 3:00 AM, 4:00 AM (2:00 AM doesn't exist)
        expect(slots).toHaveLength(3);
        
        const localTimes = slots.map(slot => 
          DateTime.fromISO(slot.startUtcISO).setZone(tz).hour
        ).sort();
        
        expect(localTimes).toEqual([1, 3, 4]);
        
        // Verify no slot falls in the missing hour (2:00-3:00 AM)
        slots.forEach(slot => {
          const localTime = DateTime.fromISO(slot.startUtcISO).setZone(tz);
          const hour = localTime.hour;
          expect(hour).not.toBe(2); // 2:00 AM doesn't exist on this day
        });
      });

      test('America/Los_Angeles 2024 DST start - March 10, 2:00 AM jumps to 3:00 AM', () => {
        const tz = 'America/Los_Angeles';
        const dstDate = '2024-03-10';
        
        const startLocal = DateTime.fromISO(`${dstDate}T01:30`, { zone: tz });
        const endLocal = DateTime.fromISO(`${dstDate}T04:30`, { zone: tz });
        
        const window = [{
          startUtcISO: startLocal.toUTC().toISO()!,
          endUtcISO: endLocal.toUTC().toISO()!
        }];
        
        const slots = generateSlots(window, 30, 0, 0, tz);
        
        // Should generate 30-min slots: 1:30, 1:45, 3:00, 3:15, 3:30, 3:45, 4:00, 4:15, 4:30
        expect(slots.length).toBeGreaterThan(5);
        
        slots.forEach(slot => {
          const localTime = DateTime.fromISO(slot.startUtcISO).setZone(tz);
          const hour = localTime.hour;
          expect(hour).not.toBe(2); // 2:00 AM doesn't exist
        });
      });

      test('America/Chicago 2024 DST start - March 10, 2:00 AM jumps to 3:00 AM', () => {
        const tz = 'America/Chicago';
        const dstDate = '2024-03-10';
        
        const startLocal = DateTime.fromISO(`${dstDate}T00:30`, { zone: tz });
        const endLocal = DateTime.fromISO(`${dstDate}T05:00`, { zone: tz });
        
        const window = [{
          startUtcISO: startLocal.toUTC().toISO()!,
          endUtcISO: endLocal.toUTC().toISO()!
        }];
        
        const slots = generateSlots(window, 45, 0, 0, tz);
        
        // Verify no slots in the missing hour
        slots.forEach(slot => {
          const localTime = DateTime.fromISO(slot.startUtcISO).setZone(tz);
          const hour = localTime.hour;
          expect(hour).not.toBe(2);
        });
      });
    });

    describe('Fall Back (DST End)', () => {
      test('America/New_York 2024 DST end - November 3, 2:00 AM repeats (occurs twice)', () => {
        const tz = 'America/New_York';
        const dstDate = '2024-11-03'; // DST end date
        
        // Create availability that spans the repeated hour
        const startLocal = DateTime.fromISO(`${dstDate}T00:30`, { zone: tz });
        const endLocal = DateTime.fromISO(`${dstDate}T03:30`, { zone: tz });
        
        const window = [{
          startUtcISO: startLocal.toUTC().toISO()!,
          endUtcISO: endLocal.toUTC().toISO()!
        }];
        
        const slots = generateSlots(window, 30, 0, 0, tz);
        
        // Should generate more slots due to the repeated hour
        expect(slots.length).toBeGreaterThan(6);
        
        // Verify we handle the ambiguous hour correctly
        const twoAmSlots = slots.filter(slot => {
          const localTime = DateTime.fromISO(slot.startUtcISO).setZone(tz);
          return localTime.hour === 2;
        });
        
        // Should have slots for both occurrences of 2:00-3:00 AM
        expect(twoAmSlots.length).toBeGreaterThan(0);
      });

      test('Booking during ambiguous hour should use standard time', () => {
        const tz = 'America/New_York';
        const dstDate = '2024-11-03';
        
        // Create a booking during the ambiguous hour
        const ambiguousTime = DateTime.fromISO(`${dstDate}T02:30`, { zone: tz });
        
        // Luxon should default to standard time (after DST ends)
        expect(ambiguousTime.isOffsetFixed).toBe(false);
        expect(ambiguousTime.offset).toBe(-300); // UTC-5 (standard time)
      });
    });
  });

  describe('European DST Transitions', () => {
    test('Europe/London 2024 DST start - March 31, 1:00 AM jumps to 2:00 AM', () => {
      const tz = 'Europe/London';
      const dstDate = '2024-03-31';
      
      const startLocal = DateTime.fromISO(`${dstDate}T00:00`, { zone: tz });
      const endLocal = DateTime.fromISO(`${dstDate}T04:00`, { zone: tz });
      
      const window = [{
        startUtcISO: startLocal.toUTC().toISO()!,
        endUtcISO: endLocal.toUTC().toISO()!
      }];
      
      const slots = generateSlots(window, 60, 0, 0, tz);
      
      // Should generate slots for: 0:00, 2:00, 3:00 (1:00 AM doesn't exist)
      expect(slots.length).toBe(3);
      
      const localTimes = slots.map(slot => 
        DateTime.fromISO(slot.startUtcISO).setZone(tz).hour
      ).sort();
      
      expect(localTimes).toEqual([0, 2, 3]);
    });

    test('Europe/Paris 2024 DST start - March 31, 2:00 AM jumps to 3:00 AM', () => {
      const tz = 'Europe/Paris';
      const dstDate = '2024-03-31';
      
      const startLocal = DateTime.fromISO(`${dstDate}T01:00`, { zone: tz });
      const endLocal = DateTime.fromISO(`${dstDate}T05:00`, { zone: tz });
      
      const window = [{
        startUtcISO: startLocal.toUTC().toISO()!,
        endUtcISO: endLocal.toUTC().toISO()!
      }];
      
      const slots = generateSlots(window, 30, 0, 0, tz);
      
      // Verify no slots in the missing hour
      slots.forEach(slot => {
        const localTime = DateTime.fromISO(slot.startUtcISO).setZone(tz);
        const hour = localTime.hour;
        expect(hour).not.toBe(2); // 2:00 AM doesn't exist
      });
    });

    test('Europe/Berlin 2024 DST end - October 27, 3:00 AM repeats', () => {
      const tz = 'Europe/Berlin';
      const dstDate = '2024-10-27';
      
      const startLocal = DateTime.fromISO(`${dstDate}T01:30`, { zone: tz });
      const endLocal = DateTime.fromISO(`${dstDate}T04:30`, { zone: tz });
      
      const window = [{
        startUtcISO: startLocal.toUTC().toISO()!,
        endUtcISO: endLocal.toUTC().toISO()!
      }];
      
      const slots = generateSlots(window, 30, 0, 0, tz);
      
      // Should have slots for both occurrences of the repeated hour
      expect(slots.length).toBeGreaterThan(6);
    });
  });

  describe('Southern Hemisphere DST', () => {
    test('Australia/Sydney 2024 DST start - October 6, 2:00 AM jumps to 3:00 AM', () => {
      const tz = 'Australia/Sydney';
      const dstDate = '2024-10-06';
      
      const startLocal = DateTime.fromISO(`${dstDate}T01:00`, { zone: tz });
      const endLocal = DateTime.fromISO(`${dstDate}T05:00`, { zone: tz });
      
      const window = [{
        startUtcISO: startLocal.toUTC().toISO()!,
        endUtcISO: endLocal.toUTC().toISO()!
      }];
      
      const slots = generateSlots(window, 60, 0, 0, tz);
      
      // Should generate slots for: 1:00, 3:00, 4:00 (2:00 AM doesn't exist)
      expect(slots.length).toBe(3);
      
      const localTimes = slots.map(slot => 
        DateTime.fromISO(slot.startUtcISO).setZone(tz).hour
      ).sort();
      
      expect(localTimes).toEqual([1, 3, 4]);
    });

    test('Brazil/Sao_Paulo 2024 DST end - February 17, midnight jumps back', () => {
      const tz = 'America/Sao_Paulo';
      const dstDate = '2024-02-17';
      
      const startLocal = DateTime.fromISO(`${dstDate}T22:00`, { zone: tz });
      const endLocal = DateTime.fromISO(`${dstDate}T02:00`, { zone: tz });
      
      const window = [{
        startUtcISO: startLocal.toUTC().toISO()!,
        endUtcISO: endLocal.toUTC().toISO()!
      }];
      
      const slots = generateSlots(window, 30, 0, 0, tz);
      
      // Should handle the midnight transition correctly
      expect(slots.length).toBeGreaterThan(0);
    });
  });

  describe('Edge Cases and Boundary Conditions', () => {
    test('Booking exactly at DST transition moment', () => {
      const tz = 'America/New_York';
      const dstStart = '2024-03-10T02:00:00'; // This time doesn't exist
      
      // Should handle non-existent time gracefully
      const nonExistentTime = DateTime.fromISO(dstStart, { zone: tz });
      
      // Luxon should adjust this to a valid time
      expect(nonExistentTime.isValid).toBe(true);
    });

    test('Cross-midnight DST transitions', () => {
      const tz = 'Pacific/Auckland'; // Some timezones have midnight DST changes
      const testDate = '2024-09-29';
      
      const startLocal = DateTime.fromISO(`${testDate}T22:00`, { zone: tz });
      const endLocal = DateTime.fromISO(`${testDate}T03:00`, { zone: tz }).plus({ days: 1 });
      
      const window = [{
        startUtcISO: startLocal.toUTC().toISO()!,
        endUtcISO: endLocal.toUTC().toISO()!
      }];
      
      const slots = generateSlots(window, 60, 0, 0, tz);
      
      expect(slots.length).toBeGreaterThan(0);
    });

    test('Historical DST changes', () => {
      // Test with a year when DST rules were different
      const tz = 'America/New_York';
      const historicalDate = '1974-01-06'; // Emergency DST period during oil crisis
      
      const startLocal = DateTime.fromISO(`${historicalDate}T10:00`, { zone: tz });
      const endLocal = DateTime.fromISO(`${historicalDate}T18:00`, { zone: tz });
      
      const window = [{
        startUtcISO: startLocal.toUTC().toISO()!,
        endUtcISO: endLocal.toUTC().toISO()!
      }];
      
      const slots = generateSlots(window, 120, 0, 0, tz);
      
      expect(slots.length).toBeGreaterThan(0);
    });

    test('Timezone without DST', () => {
      const tz = 'Asia/Dubai'; // No DST
      const testDate = '2024-06-15';
      
      const startLocal = DateTime.fromISO(`${testDate}T09:00`, { zone: tz });
      const endLocal = DateTime.fromISO(`${testDate}T17:00`, { zone: tz });
      
      const window = [{
        startUtcISO: startLocal.toUTC().toISO()!,
        endUtcISO: endLocal.toUTC().toISO()!
      }];
      
      const slots = generateSlots(window, 60, 0, 0, tz);
      
      // Should generate exactly 8 slots (9 AM to 5 PM)
      expect(slots).toHaveLength(8);
      
      // All slots should be at consistent UTC times
      const utcOffsets = slots.map(slot => 
        DateTime.fromISO(slot.startUtcISO).offset
      );
      
      // All offsets should be the same (no DST change)
      expect(new Set(utcOffsets).size).toBe(1);
    });
  });

  describe('Recurring Rules Across DST Boundaries', () => {
    test('Weekly recurring rule spanning DST transition', () => {
      const tz = 'America/New_York';
      const weekOfDST = '2024-03-10'; // Week of DST start
      
      const rules = [
        { weekday: 7, startLocal: '10:00', endLocal: '12:00', tz } // Sunday
      ];
      
      const expanded = expandWeeklyRules(rules, weekOfDST);
      
      // Should handle the DST transition correctly
      expect(expanded.length).toBeGreaterThan(0);
      
      // Check that times are properly converted
      const dstDayRule = expanded.find(rule => 
        DateTime.fromISO(rule.startUtc).setZone(tz).toISODate() === '2024-03-10'
      );
      
      expect(dstDayRule).toBeDefined();
    });

    test('Custom day availability during DST transition', () => {
      const tz = 'Europe/London';
      const dstDate = '2024-03-31';
      
      const rules: any[] = []; // No recurring rules
      const expanded = expandWeeklyRules(rules, dstDate);
      
      const customDays = [{
        dateISO: dstDate,
        startUtcISO: DateTime.fromISO(`${dstDate}T14:00`, { zone: tz }).toUTC().toISO()!,
        endUtcISO: DateTime.fromISO(`${dstDate}T16:00`, { zone: tz }).toUTC().toISO()!,
        tz
      }];
      
      const merged = mergeOverrides(expanded, customDays, dstDate);
      
      expect(merged.length).toBe(1);
      expect(merged[0].source).toBe('custom');
    });
  });

  describe('Performance with DST Calculations', () => {
    test('Large date range spanning multiple DST transitions', () => {
      const tz = 'America/New_York';
      const start = '2024-01-01';
      const end = '2024-12-31';
      
      const rules = [
        { weekday: 1, startLocal: '09:00', endLocal: '17:00', tz }, // Monday
        { weekday: 2, startLocal: '09:00', endLocal: '17:00', tz }, // Tuesday
        { weekday: 3, startLocal: '09:00', endLocal: '17:00', tz }, // Wednesday
        { weekday: 4, startLocal: '09:00', endLocal: '17:00', tz }, // Thursday
        { weekday: 5, startLocal: '09:00', endLocal: '17:00', tz }, // Friday
      ];
      
      const startTime = Date.now();
      const expanded = expandWeeklyRules(rules, start);
      const endTime = Date.now();
      
      // Should complete within reasonable time
      expect(endTime - startTime).toBeLessThan(1000);
      
      // Should generate rules for entire year
      expect(expanded.length).toBeGreaterThan(200);
    });

    test('Multiple timezone conversions performance', () => {
      const timezones = [
        'America/New_York',
        'Europe/London',
        'Asia/Tokyo',
        'Australia/Sydney',
        'America/Los_Angeles'
      ];
      
      const baseTime = DateTime.fromISO('2024-06-15T10:00:00Z');
      
      const startTime = Date.now();
      
      timezones.forEach(tz => {
        for (let i = 0; i < 100; i++) {
          const converted = baseTime.setZone(tz);
          expect(converted.isValid).toBe(true);
        }
      });
      
      const endTime = Date.now();
      
      // Should complete quickly even with many conversions
      expect(endTime - startTime).toBeLessThan(500);
    });
  });

  describe('Error Handling for Edge Cases', () => {
    test('Invalid timezone during DST calculation', () => {
      const invalidTz = 'Invalid/Timezone';
      
      expect(() => {
        DateTime.fromISO('2024-03-10T10:00', { zone: invalidTz });
      }).toThrow();
    });

    test('Extreme dates with DST', () => {
      const tz = 'America/New_York';
      
      // Test with very old and very future dates
      const oldDate = DateTime.fromISO('1900-01-01T10:00', { zone: tz });
      const futureDate = DateTime.fromISO('2100-01-01T10:00', { zone: tz });
      
      expect(oldDate.isValid).toBe(true);
      expect(futureDate.isValid).toBe(true);
    });

    test('Floating timezone handling', () => {
      // Test with floating time (no timezone)
      const floatingTime = DateTime.fromISO('2024-03-10T10:00:00', { zone: 'utc' });
      
      expect(floatingTime.isValid).toBe(true);
      expect(floatingTime.zoneName).toBe('utc');
    });
  });
});
