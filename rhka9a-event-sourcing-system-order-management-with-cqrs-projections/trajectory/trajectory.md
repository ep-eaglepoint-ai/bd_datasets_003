# Event Sourcing System - Order Management with CQRS Projections

## Trajectory: Step-by-Step Problem Solving

---

## 1. Problem Statement

Based on the prompt requirements, I identified that the engineering team needs to build an event sourcing framework for the order management domain to support audit logging, temporal queries, and eventual consistency across microservices. The system must store all state changes as immutable events, rebuild aggregate state from event history, maintain denormalized read models via projections, and handle concurrent modifications safely. The framework should support snapshot optimization for aggregates with many events and allow full projection rebuilds without blocking ongoing operations.

Based on the prompt/requirement, I understood that the core challenge is implementing event sourcing from scratch without using external libraries like Axon Framework or EventStoreDB, while still providing all the features of a production-ready event sourcing system including optimistic locking, snapshots, and CQRS projections.

---

## 2. Requirements

Based on the prompt, I identified the following requirements that must be met:

1. **Event Store**: The event store must persist domain events to PostgreSQL with append-only semantics. Each event record must include a unique event ID, aggregate ID, sequential version number, timestamp, event type as fully qualified class name, and JSON payload. Events for the same aggregate must be stored with strictly increasing version numbers.

2. **Optimistic Locking**: Optimistic locking must prevent concurrent modifications to the same aggregate. When saving events, the system must verify that the current aggregate version matches the expected version. If another transaction has already appended events, the save must fail with a concurrency exception rather than corrupting the event stream.

3. **Aggregate Base Class**: The aggregate base class must manage uncommitted events, version tracking, and state rebuild from history. Concrete aggregates extend this base class and implement event application methods. The base class must support loading from event history, tracking new events generated by commands, and clearing uncommitted events after successful persistence.

4. **Snapshot Support**: Snapshot support must reduce aggregate load time by periodically saving aggregate state. When loading an aggregate, the system should first check for a snapshot and then replay only events after the snapshot version. Snapshots must be created in separate transactions to avoid blocking command processing.

5. **Order Aggregate**: The order aggregate must handle CreateOrder, AddItem, RemoveItem, and SubmitOrder commands. Each command must validate business rules before generating the corresponding event. Orders can only have items added or removed while in draft status, and empty orders cannot be submitted.

6. **Event Immutability**: Domain events must be immutable after creation. I decided to use Java records or final fields with constructor-only initialization. Events must serialize to JSON with Jackson and deserialize back to the correct concrete event type using polymorphic type handling.

7. **Projections**: Projections must subscribe to domain events and maintain denormalized read models. The order projection must track order ID, customer ID, status, total amount, item count, and timestamps. Projection event handlers must be idempotent, processing the same event multiple times without changing the result.

8. **Projection Rebuilds**: Projection rebuilds must support reprocessing the entire event history without running out of memory. Events should be loaded in batches or streamed rather than loaded all at once. Rebuilds must not block ongoing command processing or event publishing.

9. **Event Publication**: Event publication must occur after successful event persistence. I chose to use Spring's application event publisher to notify projections of new events. Projection updates should run in separate transactions so that projection failures do not roll back command transactions.

10. **Technology Stack**: The system must use only Spring Boot 3.x, Spring Data JPA, PostgreSQL, and Jackson. No external event sourcing libraries such as Axon Framework or EventStoreDB are permitted. All framework code must be implemented from scratch using standard Spring components.

---

## 3. Constraints

Based on the prompt, I identified the following constraints:

1. Events are immutable once persisted
2. Aggregates must not be modified directly, only through events
3. Event handlers must be idempotent (processing same event twice has no effect)
4. Concurrent writes to same aggregate must fail with optimistic lock exception
5. Projection rebuilds must not block ongoing operations
6. All database operations must use transactions appropriately
7. No external event sourcing libraries (Axon, EventStore, etc.)

---

## 4. Research and Resources

Before implementing the solution, I researched the following concepts and resources:

### 4.1 Core Event Sourcing Concepts

- **Event Sourcing Pattern**: I researched the event sourcing pattern which stores all state changes as a sequence of events instead of maintaining current state. This enables audit logging, temporal queries, and replay capabilities.

  - [Microsoft Event Sourcing Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing)
  - [Event Sourcing Wikipedia](https://en.wikipedia.org/wiki/Event_sourcing)

- **CQRS Pattern**: I studied the Command Query Responsibility Segregation pattern which separates read and write operations for better scalability and flexibility.

  - [CQRS Pattern - Microsoft](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs)
  - [Greg Young's CQRS Documents](https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf)

### 4.2 Optimistic Locking

- I researched optimistic locking strategies for event stores to prevent concurrent write conflicts while maintaining event ordering.

  - [Optimistic Locking in Event Sourcing](https://eventstore.com/blog/optimistic-concurrency-and-idempotence-in-event-sourcing)
  - [Spring Data JPA Optimistic Locking](https://www.baeldung.com/jpa-optimistic-locking)

### 4.3 Jackson Polymorphic Serialization

- I studied how to configure Jackson for polymorphic JSON serialization/deserialization of domain events.

  - [Jackson Polymorphic Type Handling](https://www.baeldung.com/jackson-inheritance)
  - [Jackson ObjectMapper Configuration](https://www.baeldung.com/jackson-object-mapper-tutorial)

### 4.4 Spring Application Events

- I researched Spring's application event mechanism for implementing the observer pattern and decoupling event producers from consumers.

  - [Spring Application Events](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events)
  - [Async Event Handling in Spring](https://www.baeldung.com/spring-events)

### 4.5 Snapshot Strategies

- I studied various snapshot strategies to optimize aggregate loading performance for aggregates with long event histories.

  - [Event Sourcing Snapshotting](https://eventstore.com/blog/event-sourcing-snapshotting-patterns)
  - [Snapshots in Event Sourcing - Enterprise](https://github.com/eventstore/EventStore/wiki/Snapshots)

### 4.6 Videos and Tutorials

- [Event Sourcing Explained - YouTube](https://www.youtube.com/watch?v=6jA75MXl7C4)
- [CQRS and Event Sourcing - Domain-Driven Design Europe](https://www.youtube.com/watch?v=CdRNr3XRZ9s)
- [Building Event Sourced Systems - Greg Young](https://www.youtube.com/watch?v=JwbRIK8gWc0)

---

## 5. Methods Chosen and Why

Based on the research and requirements, I chose the following methods and approaches:

### 5.1 Event Store Implementation

I chose to implement a custom EventStore service using Spring Data JPA with PostgreSQL because:

- **Spring Data JPA** provides transaction management, optimistic locking support, and repository pattern out of the box, reducing boilerplate code
- **PostgreSQL** offers ACID compliance, reliable JSON storage, and good performance for append-only workloads
- **Append-only semantics** are achieved by only providing save methods and never implementing update or delete operations on events
- **Sequential version numbers** are enforced by checking the current aggregate version before appending new events

### 5.2 Aggregate Base Class

I chose to create an abstract Aggregate base class because:

- **Code reusability** is achieved by centralizing version tracking, uncommitted event management, and history loading in the base class
- **Template method pattern** is used with abstract apply() methods that subclasses implement for their specific event types
- **Protected registerEvent()** method ensures events are both added to the uncommitted list and applied to state immediately, maintaining consistency

### 5.3 Optimistic Locking Strategy

I chose version-based optimistic locking because:

- **Version comparison** before saving ensures that only one transaction can append events at a time
- **ConcurrencyException** is thrown when versions don't match, clearly indicating the failure reason
- **No distributed locks** are needed, avoiding the complexity of distributed coordination

### 5.4 Event Serialization with Jackson

I chose to use Jackson with polymorphic type handling because:

- **activateDefaultTyping()** automatically adds type information to JSON payloads
- **@JsonProperty annotations** on constructor parameters make events immutable while still supporting deserialization
- **JavaTimeModule** handles Instant timestamps correctly without custom converters

### 5.5 Spring Application Events for Projection Updates

I chose Spring's ApplicationEventPublisher because:

- **Loose coupling** between event store and projections is achieved through the observer pattern
- **Separate transactions** are possible by using @Transactional on event listener methods
- **Built-in async support** allows projections to process events without blocking command processing

### 5.6 Snapshot Strategy

I chose to implement snapshot support at the repository level because:

- **Transparent to aggregates** - snapshots are handled automatically during load/save
- **Version-based loading** - events after the snapshot version are replayed, reducing load time
- **Separate transactions** for snapshot creation prevent blocking ongoing operations

### 5.7 Idempotent Projection Handlers

I chose to implement idempotent handlers using event ID tracking because:

- **ConcurrentHashMap** provides thread-safe storage of processed event IDs
- **Double-check pattern** ensures events are processed only once even with concurrent invocations
- **Database-backed tracking** (via event_repository.existsByEventId) ensures durability across restarts

---

## 6. Solution Implementation and Explanation

### 6.1 Domain Model Implementation

I started by creating the core domain model:

**DomainEvent Base Class** - I created an abstract DomainEvent class that all concrete events extend. This class contains eventId, aggregateId, version, timestamp, and eventType fields. The constructor uses Objects.requireNonNull() for validation and generates UUIDs automatically.

**Aggregate Base Class** - I implemented the Aggregate abstract class with the following key methods:
- `registerEvent()` - Registers new events and applies them immediately
- `loadFromHistory()` - Replays all historical events to rebuild state
- `getUncommittedEvents()` - Returns read-only view of uncommitted events
- `markEventsAsCommitted()` - Clears uncommitted events after successful persistence

### 6.2 Event Store Implementation

I implemented the EventStore service with these key methods:

**appendEvents()** - Takes aggregateId, expectedVersion, and list of events. First verifies current version matches expected, then persists each event with incrementing version numbers, and publishes events via ApplicationEventPublisher.

**loadEvents()** - Retrieves all events for an aggregate ordered by version, deserializes them using the stored eventType for polymorphic reconstruction.

**appendInitialEvent()** - Special method for creating new aggregates, verifies no existing events exist (version == 0).

### 6.3 Aggregate Repository with Snapshot Support

I created the AggregateRepository to handle aggregate loading and saving:

**load()** - First checks for snapshots, loads aggregate state from snapshot if available, then replays only events after the snapshot version. This dramatically reduces loading time for aggregates with many events.

**save()** - Calls EventStore.appendEvents() with the aggregate's current version. On success, clears uncommitted events.

### 6.4 Order Aggregate Implementation

I implemented the OrderAggregate class with:

**Commands**:
- `createOrder()` - Static factory method creating a new order in DRAFT status
- `addItem()` - Validates order is in DRAFT status, adds item to order
- `removeItem()` - Validates order is in DRAFT status, removes item from order
- `submitOrder()` - Validates order is in DRAFT status and has items, transitions to SUBMITTED

**Event Application Methods**:
- `apply(OrderCreatedEvent)` - Sets initial state
- `apply(OrderItemAddedEvent)` - Adds item to items map and updates total
- `apply(OrderItemRemovedEvent)` - Removes item and recalculates total
- `apply(OrderSubmittedEvent)` - Updates status and submittedAt timestamp

### 6.5 Order Projection Implementation

I created the OrderProjection class that implements the read model:

**Event Handlers**:
- `handleOrderCreated()` - Creates new OrderProjectionEntity
- `handleOrderItemAdded()` - Updates totalAmount and itemCount
- `handleOrderItemRemoved()` - Updates totalAmount and decrements itemCount
- `handleOrderSubmitted()` - Updates status to SUBMITTED

**Idempotency** - Each handler first checks if the event has already been processed using `isEventProcessed()`, preventing duplicate updates.

### 6.6 Jackson Configuration

I configured Jackson with:

- **JavaTimeModule** for proper Instant serialization
- **activateDefaultTyping()** with NON_FINAL to enable polymorphic serialization
- **FAIL_ON_UNKNOWN_PROPERTIES set to false** for forward compatibility

### 6.7 Service Layer

I created the OrderService that coordinates between the aggregate repository and projections:

- Methods are @Transactional to ensure atomic operations
- Each command (createOrder, addItem, removeItem, submitOrder) loads the aggregate, applies changes, and saves
- Separate read methods provide access to the read model (projections)

---

## 7. How Solution Handles Constraints, Requirements, and Edge Cases

### 7.1 Event Immutability

I ensured event immutability through:

- **Final fields** in DomainEvent with no setters
- **Constructor-only initialization** with Objects.requireNonNull validation
- **No update operations** in EventRepository - events can only be created, never modified
- **Serialization copies** - when updating versions, I deserialize to a new object rather than modifying the original

### 7.2 Aggregate Modification Only Through Events

I enforced this constraint through:

- **Protected registerEvent()** - only aggregate code can register events
- **Private setters** for aggregate state fields
- **Event application methods** that are the only way to change aggregate state
- **No public setters** for internal state fields

### 7.3 Idempotent Event Handlers

I implemented idempotency through:

- **Event ID tracking** using ConcurrentHashMap in projections
- **Database-level checking** via EventRepository.existsByEventId()
- **Existence checks** in each handler before making database changes
- **Version comparison** ensures events are applied in correct order

### 7.4 Concurrent Write Handling

I handled concurrent writes through:

- **Version check** before appending events in EventStore.appendEvents()
- **ConcurrencyException** thrown when versions don't match
- **Retry mechanism** (client-side) - clients catch ConcurrencyException and reload the aggregate before retrying
- **Serializable isolation** - PostgreSQL transactions provide additional protection

### 7.5 Non-Blocking Projection Rebuilds

I ensured non-blocking rebuilds through:

- **Spring Application Events** - projections receive events asynchronously
- **@Transactional on event listeners** - separate transaction from command processing
- **Eventual consistency** model - projections are updated eventually, not synchronously
- **Batch loading** - EventRepository methods support loading events in batches

### 7.6 Transaction Management

I implemented proper transaction management through:

- **@Transactional** on service methods for command operations
- **read_only=true** on query methods for optimization
- **Separate transactions** for projection updates via @Transactional on event listeners
- **Event persistence in one transaction** - all events for a command are saved atomically

### 7.7 Edge Cases Handled

**Edge Case 1: Removing non-existent item**
- Handled in OrderAggregate.removeItem() - returns early if item not found

**Edge Case 2: Submitting empty order**
- Validated in OrderAggregate.validateCanSubmit() - throws IllegalStateException if items.isEmpty()

**Edge Case 3: Modifying submitted order**
- Validated in OrderAggregate.validateDraftStatus() - throws IllegalStateException if status != DRAFT

**Edge Case 4: Concurrent modification detected**
- Handled in EventStore.appendEvents() - throws ConcurrencyException if version mismatch

**Edge Case 5: Duplicate event processing**
- Handled in OrderProjection.isEventProcessed() - checks eventId before processing

**Edge Case 6: Projection not found during event processing**
- Handled in OrderProjection event handlers - logs warning and returns gracefully

**Edge Case 7: Snapshot for new aggregate**
- Handled in AggregateRepository - snapshotVersion defaults to 0L if no snapshot exists

**Edge Case 8: Event deserialization failure**
- Handled in EventStore.fromEntity() - wraps ClassNotFoundException and JsonProcessingException in RuntimeException

---

## 8. Conclusion

I implemented a complete event sourcing framework with CQRS projections for order management using only Spring Boot 3.x, Spring Data JPA, PostgreSQL, and Jackson. The solution satisfies all requirements from the prompt including:

1. Append-only event store with optimistic locking
2. Aggregate base class managing uncommitted events and state reconstruction
3. Snapshot support for performance optimization
4. CQRS projections with idempotent event handlers
5. Order aggregate with business rule validation
6. Immutable domain events with polymorphic JSON serialization
7. Non-blocking projection updates using Spring application events
8. Full compliance with all constraints

The architecture provides a solid foundation for building event-sourced systems with audit logging, temporal queries, and eventual consistency across microservices.
