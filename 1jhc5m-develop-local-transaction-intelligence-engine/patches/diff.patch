diff --git a/repository_after/__init__.py b/repository_after/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/repository_after/transaction_engine.py b/repository_after/transaction_engine.py
new file mode 100644
index 0000000..8950cdb
--- /dev/null
+++ b/repository_after/transaction_engine.py
@@ -0,0 +1,267 @@
+import re
+
+class TransactionEngine:
+    def __init__(self):
+        self.categories = {
+            'Dining': ['restaurant', 'cafe', 'coffee', 'bistro', 'diner', 'food', 'steakhouse', 'pizza', 'burger'],
+            'Travel': ['uber', 'lyft', 'taxi', 'airline', 'flight', 'rail', 'train', 'metro', 'bus', 'travel'],
+            'Utilities': ['electric', 'water', 'gas', 'power', 'telecom', 'broadband', 'internet', 'mobile', 'bill'],
+            'Shopping': ['amazon', 'walmart', 'target', 'store', 'market', 'grocery', 'retail', 'shop', 'fashion', 'mall']
+        }
+
+    def process_message(self, message: str) -> dict:
+        """
+        Parses a financial SMS message and extracts structured data.
+        """
+        
+        if re.search(r'\b(OTP|Verification Code|Secured Login)\b', message, re.IGNORECASE):
+            return {}
+
+        result = {
+            "amount": None,
+            "currency": None,
+            "merchant": None,
+            "category": None,
+            "type": None,
+            "confidence": 0.0
+        }
+
+        amount, currency = self._extract_amount_currency(message)
+        result['amount'] = amount
+        result['currency'] = currency
+
+        merchant = self._extract_merchant(message)
+        
+        detected_invalid_merchant = False
+        if merchant:
+            # Check if merchant is just digits, dashes, slashes. e.g. dates or account numbers
+            if re.fullmatch(r'[\d\-/]+', merchant):
+                merchant = None # Discard
+                detected_invalid_merchant = True
+        
+        result['merchant'] = merchant
+
+        direction = self._determine_direction(message, merchant)
+        result['type'] = direction
+
+        if result['merchant']:
+            result['category'] = self._categorize_merchant(result['merchant'])
+        
+        score = 0.0
+        if result['amount'] is not None:
+            score += 0.4
+        if result['currency'] is not None:
+            score += 0.2
+        if result['merchant'] is not None:
+            score += 0.2
+        if result['type'] is not None:
+            score += 0.2
+        
+        if detected_invalid_merchant:
+            score -= 0.1
+        
+        result['confidence'] = round(score, 2)
+
+        if result['confidence'] < 0.6:
+            return {} # Treat as unreliable/empty
+
+        if result['amount'] is not None:
+            # Check for zero, negative (unless valid type? usually amount is absolute value in extraction)
+            # "Amounts that are zero, negative... or excessively large"
+            if result['amount'] <= 0 or result['amount'] > 1000000000: # Arbitrary large threshold
+                 return {}
+
+        return result
+
+    def _extract_amount_currency(self, text):
+        # Supports: $100.50, 100.50€, USD 100.50, Rs. 500
+        # Decimal notations: 1.000,50 and 1,000.50 -> 1000.5
+        
+        # Patterns
+        # P1: Currency Prefix: (Symbol|Code) Space? Number
+        # P2: Currency Suffix: Number Space? (Symbol|Code)
+        
+        currency_pattern = r'(?P<curr>USD|EUR|GBP|INR|Rs\.?|[$€£¥Rp])'
+        number_pattern = r'(?P<num>[\d][\d.,]*)' 
+        
+        # Combined Regexes
+        # Group 1: Prefix
+        # Note: We use \b for codes but not for symbols necessarily, though symbols are standalone usually or attached.
+        
+        regex_prefix = re.compile(rf'{currency_pattern}\s*{number_pattern}')
+        regex_suffix = re.compile(rf'{number_pattern}\s*{currency_pattern}')
+        
+        found_amount = None
+        found_currency = None
+
+        # Search for matches
+        # We prefer the first clear match?
+        
+        matches = []
+        
+        # Check prefix matches
+        for m in regex_prefix.finditer(text):
+            matches.append( (m.group('curr'), m.group('num')) )
+            
+        # Check suffix matches
+        for m in regex_suffix.finditer(text):
+             # For suffix, num is first, curr is second
+             matches.append( (m.group('curr'), m.group('num')) )
+             
+        # Process matches to find a valid one
+        for curr_str, num_str in matches:
+            # Parse number
+            val = self._parse_number(num_str)
+            if val is not None:
+                found_amount = val
+                found_currency = curr_str.strip()
+                if found_currency == 'Rs.': found_currency = 'Rs' # Normalize
+                break # Take first valid
+                
+        return found_amount, found_currency
+
+    def _parse_number(self, num_str):
+        # Handling 1.000,50 vs 1,000.50 vs 100.50
+        # Remove trailing punctuation often caught by greedy regex if not careful
+        num_str = num_str.strip('.,')
+        
+        # Count occurences
+        dots = num_str.count('.')
+        commas = num_str.count(',')
+        
+        clean_str = num_str
+        
+        if dots > 0 and commas > 0:
+            # Both present
+            last_dot = num_str.rfind('.')
+            last_comma = num_str.rfind(',')
+            
+            if last_dot > last_comma:
+                # 1,000.50 -> Dot is decimal
+                clean_str = num_str.replace(',', '')
+            else:
+                # 1.000,50 -> Comma is decimal
+                clean_str = num_str.replace('.', '').replace(',', '.')
+        elif commas > 0:
+            # Only commas. 1,000 or 1,50?
+            # 1,000 -> 1000. 1,50 -> 1.50?
+            # Ambiguous. 
+            # If comma is used as decimal, usually matches "digits,digits".
+            # If used as thousands, usually "digits,digits(3)".
+            # Heuristic: If there is exactly one comma, and it has 2 digits after, it's decimal.
+            # If 3 digits, assumed thousands.
+            parts = num_str.split(',')
+            if len(parts) == 2 and len(parts[1]) == 2:
+                 clean_str = num_str.replace(',', '.')
+            else:
+                # Assume thousands
+                clean_str = num_str.replace(',', '')
+        elif dots > 0:
+             # Only dots. 1.000 or 1.50?
+             # Same logic.
+             parts = num_str.split('.')
+             if len(parts) == 2 and len(parts[1]) == 2:
+                  # Decimal
+                  pass # Already correct format
+             elif len(parts) > 1 and all(len(p)==3 for p in parts[1:]):
+                  # 1.000.000 -> thousands
+                  clean_str = num_str.replace('.', '')
+             else:
+                  # 1.50 -> Decimal
+                  pass
+
+        try:
+            return float(clean_str)
+        except ValueError:
+            return None
+
+    def _extract_merchant(self, text):
+        # Anchors: at, in, to, from, paid to, vpa
+        # Regex to find these keywords followed by text
+        # We need to capture the text until some stop condition (e.g. amount number, end of string)
+        
+        anchors = r'(?:at|in|to|from|paid\s+to|vpa)'
+        # Look for anchor, then spaces, then capture group until specific noise or number
+        
+        # Stop at:
+        # - End of line
+        # - Currency symbol
+        # - Common separators like 'on' (date), 'using', 'via'
+         
+        pattern = rf'\b{anchors}\s+(?P<merchant>.+?)(?=\s+(?:on|using|via|for|with|confirmed|successful|ref|trans|\$|€|£|Rs)|$)'
+        
+        match = re.search(pattern, text, re.IGNORECASE)
+        if match:
+            raw_merchant = match.group('merchant').strip()
+            
+            # Normalization pass
+            # Strip noise: branch codes, payment prefixes, numeric IDs
+            
+            # Remove VPA- prefix
+            raw_merchant = re.sub(r'^VPA-', '', raw_merchant, flags=re.IGNORECASE)
+            
+            # Remove trailing numbers or ID patterns like *8829
+            # Remove "Branch" info? e.g. "-London"
+            
+            # Remove trailing branch like "- Location" if distinct?
+            # Strategy: Split by '-' if present and take first part if looks like name?
+            # Or just remove specific noise types mentioned: "asterisks, branch codes, or automated sequence numbers"
+            
+            # Remove *xxxx
+            raw_merchant = re.sub(r'\*\d+', '', raw_merchant)
+
+            # normalization pass to strip common transactional noise, including branch locations (e.g., '-London')
+            # Removes suffix starting with "-" followed by letters at the end of the string
+            raw_merchant = re.sub(r'-\s*[A-Za-z]+$', '', raw_merchant)
+            
+            # Just naive strip of non-alphanumeric noise at edges
+            raw_merchant = raw_merchant.strip(" -.,")
+            
+            return raw_merchant
+            
+        return None
+
+    def _categorize_merchant(self, merchant):
+        # Case-insensitive substring search
+        m_lower = merchant.lower()
+        
+        for category, keywords in self.categories.items():
+            for kw in keywords:
+                if kw in m_lower:
+                    return category
+        
+        return "Uncategorized"
+
+    def _determine_direction(self, text, merchant):
+        # Weighted context analysis
+        # Keywords
+        debit_kw = ['spent', 'debited', 'charged', 'purchase']
+        credit_kw = ['credited', 'received', 'refund', 'deposited']
+        
+        text_lower = text.lower()
+        
+        debit_score = 0
+        credit_score = 0
+        
+        for kw in debit_kw:
+            if kw in text_lower:
+                debit_score += 1
+                
+        for kw in credit_kw:
+            if kw in text_lower:
+                credit_score += 1
+                # Weight "refund" heavily? Prompt says "ensure that a 'refund' is never categorized as a 'debit.'"
+                if kw == 'refund':
+                    return "Credit" 
+
+        if credit_score > debit_score:
+            return "Credit"
+        elif debit_score > credit_score:
+            return "Debit"
+        else:
+            # Ambiguous
+            # Default to 'Debit' only if merchant name is successfully identified.
+            if merchant:
+                return "Debit"
+            
+        return None # Ambiguous
