# Trajectory: High-Concurrency Seat Reservation with Optimistic UI and SSE Sync

### 1. Audit / Requirements Analysis (The actual problem)
I analyzed the core challenge: building a seat reservation system that feels instant to users while maintaining data consistency across multiple concurrent clients. The problem has three critical components: (1) **Optimistic UI** - users see immediate feedback when booking seats, even before server confirmation, (2) **Automatic Rollback** - if the server rejects the booking (conflict, network error, etc.), the UI must automatically revert to the previous state without user intervention, (3) **Server Authority via SSE** - real-time updates from other clients must override local optimistic state to prevent desynchronization. The engineering complexity lies in mediating race conditions between local optimistic updates and authoritative server streams during high-concurrency periods.

### 2. Question Assumptions (Challenge the Premise)
Initially I considered using WebSockets for bidirectional communication, but the requirements specified Server-Sent Events for unidirectional real-time updates. I also questioned whether to use external libraries like Socket.IO or Axios, but the constraints required native browser APIs only (fetch, EventSource). The key architectural decision was whether to implement pessimistic locking (wait for server confirmation) or true optimistic UI (immediate local updates with rollback). The requirements clearly demanded optimistic UI for perceived performance, so I committed to the complexity of state reconciliation and rollback mechanisms.

### 3. Define Success Criteria (Establish Measurable Goals)
Success meant: (1) **Backend**: Thread-safe concurrent booking with sync.Mutex protection, SSE implementation with correct headers (text/event-stream, no-cache, keep-alive), real-time broadcasting to all connected clients, proper conflict resolution (409 status for no seats), (2) **Frontend**: Optimistic UI with immediate state decrement before fetch resolves, automatic rollback on fetch failures or non-200 responses, EventSource lifecycle management with useEffect, state tracking with useRef for rollback purposes, (3) **Integration**: Server authority overrides local state via SSE, multiple clients stay synchronized, race condition handling between optimistic updates and SSE streams, (4) **Testing**: Comprehensive test coverage mapping each requirement to specific test cases, unified test runner for both backend (Go) and frontend (Jest).

### 4. Map Requirements to Validation (Define Test Strategy)
I mapped each requirement to specific test cases: **REQ-1** (no external libraries) → TestMustNotUseExternalLibraries for backend and TestFrontendREQ1 for frontend, **REQ-2** (mutex protection) → TestMustUseSyncMutexToProtectDecrementOperation with 50 concurrent requests, **REQ-3** (SSE headers) → TestMustImplementServerSentEventsWithCorrectHeaders validating all required headers, **REQ-4** (broadcasting) → TestMustBroadcastUpdatesToAllActiveClientsAfterSuccessfulBooking, **REQ-5** (state tracking) → TestFrontendREQ5 for useRef/useState rollback tracking, **REQ-6** (optimistic timing) → TestFrontendREQ6 verifying state decrements before fetch resolves, **REQ-7** (rollback on failure) → TestFrontendREQ7 testing automatic revert on non-200 responses, **REQ-8** (EventSource lifecycle) → TestFrontendREQ8 for connection management, **REQ-9** (critical concurrency) → 1 seat + 5 concurrent requests = 1 success + 4 conflicts, **REQ-10** (rollback test) → Mock 500 error with immediate visual feedback then automatic revert, **REQ-11** (resync test) → Client A books, Client B receives SSE update automatically.

### 5. Scope the Solution
The solution spans three main components: **Backend** (`repository_after/backend/main.go`) implements SeatReservationServer with sync.Mutex protection, SSE endpoint with proper headers, broadcasting mechanism to all connected clients, and conflict resolution for concurrent bookings. **Frontend** (`repository_after/frontend/src/`) contains `SeatBookingDemo.tsx` for the UI component, `hooks/useSeatBooking.ts` for optimistic state management with rollback, and proper EventSource lifecycle handling. **Testing Infrastructure** uses `test_wrapper.go` to execute backend tests from `repository_after/backend` and frontend Jest tests that target the real hook implementation, with `evaluation.go` generating reports from unified output. The scope deliberately excludes complex features like user authentication, persistent storage, or advanced queueing - focusing purely on the concurrency and optimistic UI challenges.

### 6. Trace Data Flow (Follow the Path)
**Optimistic Booking Flow**: User clicks "Book Seat" → useSeatBooking hook immediately decrements availableSeats (optimistic UI) → fetch POST /book sent to backend → if success: keep optimistic state, if failure: rollback to previous state stored in useRef. **Server-Side Processing**: POST /book → seatMutex.Lock() → check availableSeats > 0 → if yes: decrement and broadcast via SSE, if no: return 409 Conflict → seatMutex.Unlock(). **Real-Time Synchronization**: Server broadcasts seat count via SSE → all connected EventSource clients receive update → useSeatBooking hook updates local state with server authority → UI reflects authoritative count. **Race Condition Handling**: If optimistic update and SSE update arrive simultaneously, SSE (server authority) always wins, ensuring consistency across all clients.

### 7. Anticipate Objections (Play Devil's Advocate)
Someone might argue: "Optimistic UI creates confusion when rollbacks happen frequently." Counter: The system provides clear visual feedback (loading states, error messages) and the rollback is automatic, maintaining user trust. Another objection: "Why not use WebSockets instead of SSE?" SSE is simpler for unidirectional updates, has built-in reconnection, and fits the requirement perfectly. "What about memory leaks with EventSource connections?" The useEffect cleanup function properly closes connections, and the backend removes disconnected clients from the broadcast list. "Mutex locking could create bottlenecks under extreme load." For this use case, the critical section is minimal (just the seat decrement), and the mutex ensures data integrity without significant performance impact.

### 8. Verify Invariants (Define Constraints)
Critical invariants: (1) **Thread Safety**: All seat modifications must be protected by sync.Mutex - no race conditions allowed, (2) **State Consistency**: Server state is always authoritative - SSE updates override local optimistic state, (3) **No External Dependencies**: Backend uses only Go standard library, frontend uses only native browser APIs (fetch, EventSource), (4) **Automatic Rollback**: Any fetch failure or non-200 response must trigger immediate state revert without user action, (5) **Connection Lifecycle**: EventSource connections must be properly managed - created in useEffect, cleaned up on unmount, (6) **Broadcast Integrity**: All connected SSE clients must receive seat count updates after successful bookings, (7) **Conflict Resolution**: Multiple concurrent requests for the last seat must result in exactly one success and the rest as 409 conflicts.

### 9. Execute with Surgical Precision (Ordered Implementation)
**Phase 1 - Backend Foundation**: Implemented SeatReservationServer struct with availableSeats, seatMutex, sseClients map, and clientsMutex. Created handleSeatBooking with proper mutex locking, conflict detection, and JSON responses. Built handleSSEEvents with required headers and client management. **Phase 2 - Frontend Core**: Developed useSeatBooking hook with useState for current state, useRef for previous state tracking, and useEffect for EventSource lifecycle. Implemented optimistic bookSeat function with immediate decrement, fetch call, and rollback logic. **Phase 3 - UI Integration**: Created SeatBookingDemo component with real-time seat display, connection status indicator, loading states, and error handling. Added comprehensive visual feedback for all system states. **Phase 4 - Testing Infrastructure**: Built unified test_wrapper.go that orchestrates both backend Go tests and frontend Jest tests. Created comprehensive test suites covering all requirements with specific test cases. Implemented evaluation.go for automated report generation. **Phase 5 - Integration & Validation**: Connected all components, verified end-to-end functionality, and ensured proper error handling and edge cases.

### 10. Measure Impact (Verify Completion)
I validated the solution by running backend and frontend tests through the unified runner. **Backend tests** now execute against the actual implementation in `repository_after/backend/main.go` (not a duplicate in the test file). **Frontend tests** now execute the real `useSeatBooking` hook and verify optimistic decrement timing, rollback behavior, EventSource lifecycle management, and SSE resynchronization using mocked `fetch` and `EventSource`. The trajectory now reports outcomes based on actual run results instead of claiming unconditional 11/11 success.

### 11. Document the Decision
I implemented a high-concurrency seat reservation system with optimistic UI and automatic rollback using pure Go backend with sync.Mutex protection and native browser APIs for the frontend. The architecture separates visual state (optimistic) from confirmed server state (authoritative) to eliminate perceived latency while maintaining data consistency. Key design decisions: (1) **Optimistic UI First**: Immediate visual feedback with automatic rollback on failures, (2) **Server Authority**: SSE streams override local state to prevent desynchronization, (3) **Thread Safety**: Mutex protection for all critical sections, (4) **No External Dependencies**: Standard library only for maximum compatibility and minimal complexity, (5) **Comprehensive Testing**: Every requirement mapped to specific test cases with unified test runner. This approach provides the best user experience (instant feedback) while ensuring data integrity and consistency across multiple concurrent clients.

### 12. Infrastructure and Tooling
- **Docker Environment**: Single container with Go and Node.js for unified development and testing environment, working directory set to /app with proper REPO_PATH environment variable handling.
- **Unified Test Runner**: test_wrapper.go orchestrates both backend Go tests (go test) and frontend Jest tests (npm test), providing pytest-like output format with unified pass/fail reporting and proper exit codes.
- **Backend Testing**: Go test suite in `repository_after/backend/main_test.go` that validates the real backend handlers and concurrency behavior with `httptest` and goroutines.
- **Frontend Testing**: Jest + Testing Library suite in `tests/ui/useSeatBooking.test.tsx` that imports and tests the real hook from `repository_after/frontend/src/hooks/useSeatBooking.ts` with mocked `fetch` and `EventSource`.
- **Evaluation System**: evaluation.go runs the unified test suite, parses results from both backend and frontend, maps test outcomes to specific requirements, and generates detailed JSON reports with timestamps and environment information.
- **Development Workflow**: Docker Compose with single command execution for tests (`docker compose run --rm -e REPO_PATH=repository_after app go run tests/runner.go`) and evaluation (`docker compose run --rm app go run ./evaluation/evaluation.go`).
- **Report Generation**: Automated report creation in evaluation/YYYY-MM-DD/HH-MM-SS/report.json with comprehensive test results, requirement mapping, and success/failure analysis for AI training dataset validation.