diff --git a/repository_after/.env b/repository_after/.env
new file mode 100644
index 0000000..d91f958
--- /dev/null
+++ b/repository_after/.env
@@ -0,0 +1 @@
+DATABASE_URL="file:./dev.db"
diff --git a/repository_after/.example.env b/repository_after/.example.env
new file mode 100644
index 0000000..5699bcb
--- /dev/null
+++ b/repository_after/.example.env
@@ -0,0 +1 @@
+DATABASE_URL=ur database url
\ No newline at end of file
diff --git a/repository_before/.gitkeep b/repository_before/.gitkeep
deleted file mode 100644
index e69de29..0000000
diff --git a/repository_after/jest.config.cjs b/repository_after/jest.config.cjs
new file mode 100644
index 0000000..65f55c3
--- /dev/null
+++ b/repository_after/jest.config.cjs
@@ -0,0 +1,20 @@
+/** @type {import('jest').Config} */
+module.exports = {
+  testEnvironment: "jsdom",
+  roots: ["<rootDir>/src", "<rootDir>/../tests"],
+  testMatch: [
+    "<rootDir>/../tests/**/*.test.ts",
+    "<rootDir>/../tests/**/*.test.tsx",
+  ],
+  setupFilesAfterEnv: ["<rootDir>/../tests/setupTests.ts"],
+  modulePaths: ["<rootDir>/node_modules"],
+  transform: {
+    "^.+\\.(t|j)sx?$": [
+      "ts-jest",
+      { tsconfig: "<rootDir>/tsconfig.jest.json" },
+    ],
+  },
+  moduleNameMapper: {
+    "^@/(.*)$": "<rootDir>/src/$1",
+  },
+};
diff --git a/repository_after/next-env.d.ts b/repository_after/next-env.d.ts
new file mode 100644
index 0000000..84ab714
--- /dev/null
+++ b/repository_after/next-env.d.ts
@@ -0,0 +1,4 @@
+/// <reference types="next" />
+/// <reference types="next/image-types/global" />
+
+// NOTE: This file should not be edited
diff --git a/repository_after/next.config.js b/repository_after/next.config.js
new file mode 100644
index 0000000..19c6d97
--- /dev/null
+++ b/repository_after/next.config.js
@@ -0,0 +1,10 @@
+/** @type {import('next').NextConfig} */
+const nextConfig = {
+  experimental: {
+    serverActions: {
+      allowedOrigins: ["*"],
+    },
+  },
+};
+
+module.exports = nextConfig;
diff --git a/repository_after/package.json b/repository_after/package.json
new file mode 100644
index 0000000..f711827
--- /dev/null
+++ b/repository_after/package.json
@@ -0,0 +1,35 @@
+{
+  "name": "swifttask",
+  "private": true,
+  "version": "0.1.0",
+  "scripts": {
+    "dev": "next dev",
+    "build": "next build",
+    "start": "next start",
+    "lint": "next lint",
+    "prisma:generate": "prisma generate",
+    "db:push": "prisma db push",
+    "test": "export DATABASE_URL=file:./test.db && prisma db push --force-reset && jest --config jest.config.cjs"
+  },
+  "dependencies": {
+    "@prisma/client": "^6.3.0",
+    "next": "^15.1.6",
+    "react": "^19.0.0",
+    "react-dom": "^19.0.0",
+    "zod": "^3.24.1"
+  },
+  "devDependencies": {
+    "@testing-library/jest-dom": "^6.6.3",
+    "@testing-library/react": "^16.1.0",
+    "@testing-library/user-event": "^14.6.1",
+    "@types/jest": "^29.5.14",
+    "@types/node": "^20.11.30",
+    "@types/react": "^19.0.10",
+    "@types/react-dom": "^19.0.4",
+    "jest": "^29.7.0",
+    "jest-environment-jsdom": "^29.7.0",
+    "prisma": "^6.3.0",
+    "ts-jest": "^29.2.5",
+    "typescript": "^5.7.3"
+  }
+}
diff --git a/repository_after/prisma/schema.prisma b/repository_after/prisma/schema.prisma
new file mode 100644
index 0000000..da7d800
--- /dev/null
+++ b/repository_after/prisma/schema.prisma
@@ -0,0 +1,26 @@
+generator client {
+  provider = "prisma-client-js"
+}
+
+datasource db {
+  provider = "sqlite"
+  url      = env("DATABASE_URL")
+}
+
+enum TaskStatus {
+  TODO
+  IN_PROGRESS
+  DONE
+}
+
+model Task {
+  id          String     @id @default(cuid())
+  title       String
+  description String     @default("")
+  status      TaskStatus @default(TODO)
+  version     Int        @default(1)
+  createdAt   DateTime   @default(now())
+  updatedAt   DateTime   @updatedAt
+
+  @@index([status])
+}
diff --git a/repository_after/src/actions/tasks.ts b/repository_after/src/actions/tasks.ts
new file mode 100644
index 0000000..358faf9
--- /dev/null
+++ b/repository_after/src/actions/tasks.ts
@@ -0,0 +1,142 @@
+"use server";
+
+import { revalidatePath } from "next/cache";
+import { prisma } from "@/lib/prisma";
+import { TaskStatusSchema, UpdateTaskInputSchema } from "@/lib/taskTypes";
+
+export type ActionResult<T> =
+  | { ok: true; data: T }
+  | {
+      ok: false;
+      error: "VALIDATION" | "CONFLICT" | "NOT_FOUND" | "UNKNOWN";
+      message: string;
+      currentVersion?: number;
+    };
+
+function mapTask(task: {
+  id: string;
+  title: string;
+  description: string;
+  status: string;
+  version: number;
+  updatedAt: Date;
+}) {
+  return {
+    id: task.id,
+    title: task.title,
+    description: task.description,
+    status: TaskStatusSchema.parse(task.status),
+    version: task.version,
+    updatedAt: task.updatedAt.toISOString(),
+  };
+}
+
+export async function listTasksAction(): Promise<
+  ActionResult<ReturnType<typeof mapTask>[]>
+> {
+  try {
+    const tasks = await prisma.task.findMany({
+      orderBy: { createdAt: "asc" },
+    });
+
+    return { ok: true, data: tasks.map(mapTask) };
+  } catch (error) {
+    return { ok: false, error: "UNKNOWN", message: "Failed to list tasks" };
+  }
+}
+
+export async function createTaskAction(input: {
+  title: string;
+  description?: string;
+}): Promise<ActionResult<ReturnType<typeof mapTask>>> {
+  try {
+    const title = (input.title ?? "").trim();
+    if (!title) {
+      return { ok: false, error: "VALIDATION", message: "Title is required" };
+    }
+
+    const task = await prisma.task.create({
+      data: {
+        title,
+        description: input.description ?? "",
+      },
+    });
+
+    revalidatePath("/");
+    return { ok: true, data: mapTask(task) };
+  } catch (error) {
+    return { ok: false, error: "UNKNOWN", message: "Failed to create task" };
+  }
+}
+
+/**
+ * Optimistic Concurrency Control (OCC): the update only succeeds if `expectedVersion`
+ * matches the DB row's current `version`. We then atomically increment `version`.
+ */
+export async function updateTaskAction(
+  rawInput: unknown
+): Promise<ActionResult<ReturnType<typeof mapTask>>> {
+  const parsed = UpdateTaskInputSchema.safeParse(rawInput);
+  if (!parsed.success) {
+    return {
+      ok: false,
+      error: "VALIDATION",
+      message: "Invalid update payload",
+    };
+  }
+
+  const { id, expectedVersion, title, description, status } = parsed.data;
+
+  try {
+    const data: Record<string, unknown> = {
+      version: { increment: 1 },
+    };
+
+    if (typeof title === "string") data.title = title;
+    if (typeof description === "string") data.description = description;
+    if (typeof status === "string")
+      data.status = TaskStatusSchema.parse(status);
+
+    const result = await prisma.$transaction(async (tx) => {
+      const updated = await tx.task.updateMany({
+        where: {
+          id,
+          version: expectedVersion,
+        },
+        data,
+      });
+
+      if (updated.count !== 1) {
+        const current = await tx.task.findUnique({
+          where: { id },
+        });
+
+        if (!current) return { kind: "not_found" as const };
+        return { kind: "conflict" as const, currentVersion: current.version };
+      }
+
+      const task = await tx.task.findUnique({ where: { id } });
+      if (!task) return { kind: "not_found" as const };
+
+      return { kind: "ok" as const, task };
+    });
+
+    if (result.kind === "not_found") {
+      return { ok: false, error: "NOT_FOUND", message: "Task not found" };
+    }
+
+    if (result.kind === "conflict") {
+      return {
+        ok: false,
+        error: "CONFLICT",
+        message: "Task was changed by someone else",
+        currentVersion: result.currentVersion,
+      };
+    }
+
+    revalidatePath("/");
+    return { ok: true, data: mapTask(result.task) };
+  } catch (error) {
+    return { ok: false, error: "UNKNOWN", message: "Failed to update task" };
+  }
+}
diff --git a/repository_after/src/app/layout.tsx b/repository_after/src/app/layout.tsx
new file mode 100644
index 0000000..db867bc
--- /dev/null
+++ b/repository_after/src/app/layout.tsx
@@ -0,0 +1,14 @@
+import type { ReactNode } from "react";
+
+export const metadata = {
+  title: "SwiftTask",
+  description: "Shared task board with optimistic concurrency control",
+};
+
+export default function RootLayout({ children }: { children: ReactNode }) {
+  return (
+    <html lang="en">
+      <body style={{ margin: 0 }}>{children}</body>
+    </html>
+  );
+}
diff --git a/repository_after/src/app/page.tsx b/repository_after/src/app/page.tsx
new file mode 100644
index 0000000..450ce74
--- /dev/null
+++ b/repository_after/src/app/page.tsx
@@ -0,0 +1,7 @@
+import { BoardClient } from "@/components/BoardClient";
+import { listTasksAction } from "@/actions/tasks";
+
+export default async function HomePage() {
+  const res = await listTasksAction();
+  return <BoardClient initialTasks={res.ok ? res.data : []} />;
+}
diff --git a/repository_after/src/components/BoardClient.tsx b/repository_after/src/components/BoardClient.tsx
new file mode 100644
index 0000000..7f55729
--- /dev/null
+++ b/repository_after/src/components/BoardClient.tsx
@@ -0,0 +1,240 @@
+"use client";
+
+import { useMemo, useOptimistic, useState, useTransition } from "react";
+import type { TaskDTO, TaskStatus } from "@/lib/taskTypes";
+import { createTaskAction, updateTaskAction } from "@/actions/tasks";
+
+type Props = {
+  initialTasks: TaskDTO[];
+};
+
+const columns: { key: TaskStatus; title: string }[] = [
+  { key: "TODO", title: "To Do" },
+  { key: "IN_PROGRESS", title: "In Progress" },
+  { key: "DONE", title: "Done" },
+];
+
+function nextStatus(status: TaskStatus): TaskStatus | null {
+  if (status === "TODO") return "IN_PROGRESS";
+  if (status === "IN_PROGRESS") return "DONE";
+  return null;
+}
+
+function prevStatus(status: TaskStatus): TaskStatus | null {
+  if (status === "DONE") return "IN_PROGRESS";
+  if (status === "IN_PROGRESS") return "TODO";
+  return null;
+}
+
+export function BoardClient({ initialTasks }: Props) {
+  const [tasks, setTasks] = useState<TaskDTO[]>(initialTasks);
+  const [isPending, startTransition] = useTransition();
+  const [lastError, setLastError] = useState<string | null>(null);
+  const [newTitle, setNewTitle] = useState<string>("");
+
+  const [optimisticTasks, applyOptimistic] = useOptimistic(
+    tasks,
+    (
+      current: TaskDTO[],
+      update: { type: "move"; id: string; to: TaskStatus }
+    ) =>
+      current.map((t) => (t.id === update.id ? { ...t, status: update.to } : t))
+  );
+
+  const grouped = useMemo(() => {
+    const map = new Map<TaskStatus, TaskDTO[]>();
+    for (const col of columns) map.set(col.key, []);
+    for (const t of optimisticTasks) map.get(t.status)!.push(t);
+    return map;
+  }, [optimisticTasks]);
+
+  async function moveTask(taskId: string, to: TaskStatus) {
+    setLastError(null);
+
+    const before = tasks;
+    const task = tasks.find((t) => t.id === taskId);
+    if (!task) return;
+
+    // Optimistic UI update
+    startTransition(() => {
+      applyOptimistic({ type: "move", id: taskId, to });
+    });
+
+    startTransition(async () => {
+      try {
+        const res = await updateTaskAction({
+          id: taskId,
+          expectedVersion: task.version,
+          status: to,
+        });
+
+        if (!res.ok) {
+          // Roll back
+          setTasks([...before]);
+          setLastError(
+            res.error === "CONFLICT"
+              ? "Conflict: someone else updated this task."
+              : res.message
+          );
+          return;
+        }
+
+        // Adopt server version + updatedAt
+        setTasks((current) =>
+          current.map((t) => (t.id === taskId ? res.data : t))
+        );
+      } catch (e) {
+        // Network/offline/etc: roll back
+        setTasks([...before]);
+        setLastError("Update failed (offline/network). Reverted.");
+      }
+    });
+  }
+
+  async function createTask() {
+    setLastError(null);
+    const title = newTitle.trim();
+    if (!title) return;
+
+    startTransition(async () => {
+      try {
+        const res = await createTaskAction({ title });
+        if (!res.ok) {
+          setLastError(res.message);
+          return;
+        }
+
+        setTasks((current) => [...current, res.data]);
+        setNewTitle("");
+      } catch (e) {
+        setLastError("Create failed (offline/network). Reverted.");
+      }
+    });
+  }
+
+  return (
+    <div style={{ padding: 16, fontFamily: "system-ui" }}>
+      <h1 style={{ marginBottom: 8 }}>SwiftTask</h1>
+      <p style={{ marginTop: 0, color: "#555" }}>
+        Shared board with optimistic concurrency control.
+      </p>
+
+      <div style={{ display: "flex", gap: 8, marginBottom: 12 }}>
+        <input
+          aria-label="New task title"
+          value={newTitle}
+          onChange={(e) => setNewTitle(e.target.value)}
+          placeholder="New task title"
+          style={{
+            flex: 1,
+            padding: 8,
+            borderRadius: 6,
+            border: "1px solid #ddd",
+          }}
+        />
+        <button type="button" disabled={isPending} onClick={createTask}>
+          Add
+        </button>
+      </div>
+
+      {lastError ? (
+        <div
+          role="alert"
+          style={{
+            background: "#ffe9e9",
+            padding: 8,
+            borderRadius: 6,
+            marginBottom: 12,
+          }}
+        >
+          {lastError}
+        </div>
+      ) : null}
+
+      <div
+        style={{
+          display: "grid",
+          gridTemplateColumns: "repeat(3, 1fr)",
+          gap: 12,
+        }}
+      >
+        {columns.map((col) => (
+          <section
+            key={col.key}
+            aria-label={col.title}
+            style={{ border: "1px solid #ddd", borderRadius: 8, padding: 12 }}
+          >
+            <h2 style={{ marginTop: 0 }}>{col.title}</h2>
+            <ul
+              style={{
+                listStyle: "none",
+                padding: 0,
+                margin: 0,
+                display: "flex",
+                flexDirection: "column",
+                gap: 8,
+              }}
+            >
+              {grouped.get(col.key)!.map((t) => (
+                <li
+                  key={t.id}
+                  style={{
+                    border: "1px solid #eee",
+                    borderRadius: 8,
+                    padding: 10,
+                  }}
+                >
+                  <div
+                    style={{
+                      display: "flex",
+                      justifyContent: "space-between",
+                      gap: 8,
+                    }}
+                  >
+                    <div>
+                      <div style={{ fontWeight: 600 }}>{t.title}</div>
+                      {t.description ? (
+                        <div style={{ color: "#666" }}>{t.description}</div>
+                      ) : null}
+                      <div style={{ color: "#999", fontSize: 12 }}>
+                        v{t.version}
+                      </div>
+                    </div>
+                    <div
+                      style={{
+                        display: "flex",
+                        flexDirection: "column",
+                        gap: 6,
+                      }}
+                    >
+                      <button
+                        type="button"
+                        disabled={isPending || !prevStatus(t.status)}
+                        onClick={() =>
+                          prevStatus(t.status) &&
+                          moveTask(t.id, prevStatus(t.status)!)
+                        }
+                      >
+                        ←
+                      </button>
+                      <button
+                        type="button"
+                        disabled={isPending || !nextStatus(t.status)}
+                        onClick={() =>
+                          nextStatus(t.status) &&
+                          moveTask(t.id, nextStatus(t.status)!)
+                        }
+                      >
+                        →
+                      </button>
+                    </div>
+                  </div>
+                </li>
+              ))}
+            </ul>
+          </section>
+        ))}
+      </div>
+    </div>
+  );
+}
diff --git a/repository_after/src/lib/prisma.ts b/repository_after/src/lib/prisma.ts
new file mode 100644
index 0000000..2eaccbb
--- /dev/null
+++ b/repository_after/src/lib/prisma.ts
@@ -0,0 +1,10 @@
+import { PrismaClient } from "@prisma/client";
+
+declare global {
+  // eslint-disable-next-line no-var
+  var prisma: PrismaClient | undefined;
+}
+
+export const prisma = global.prisma ?? new PrismaClient();
+
+if (process.env.NODE_ENV !== "production") global.prisma = prisma;
diff --git a/repository_after/src/lib/taskTypes.ts b/repository_after/src/lib/taskTypes.ts
new file mode 100644
index 0000000..9c78a18
--- /dev/null
+++ b/repository_after/src/lib/taskTypes.ts
@@ -0,0 +1,23 @@
+import { z } from "zod";
+
+export const TaskStatusSchema = z.enum(["TODO", "IN_PROGRESS", "DONE"]);
+export type TaskStatus = z.infer<typeof TaskStatusSchema>;
+
+export const UpdateTaskInputSchema = z.object({
+  id: z.string().min(1),
+  expectedVersion: z.number().int().positive(),
+  title: z.string().min(1).max(200).optional(),
+  description: z.string().max(5000).optional(),
+  status: TaskStatusSchema.optional(),
+});
+
+export type UpdateTaskInput = z.infer<typeof UpdateTaskInputSchema>;
+
+export type TaskDTO = {
+  id: string;
+  title: string;
+  description: string;
+  status: TaskStatus;
+  version: number;
+  updatedAt: string;
+};
diff --git a/repository_after/tsconfig.jest.json b/repository_after/tsconfig.jest.json
new file mode 100644
index 0000000..8dab473
--- /dev/null
+++ b/repository_after/tsconfig.jest.json
@@ -0,0 +1,9 @@
+{
+  "extends": "./tsconfig.json",
+  "compilerOptions": {
+    "jsx": "react-jsx",
+    "module": "commonjs",
+    "moduleResolution": "node"
+  },
+  "include": ["next-env.d.ts", "src", "../tests"]
+}
diff --git a/repository_after/tsconfig.json b/repository_after/tsconfig.json
new file mode 100644
index 0000000..398bc5b
--- /dev/null
+++ b/repository_after/tsconfig.json
@@ -0,0 +1,24 @@
+{
+  "compilerOptions": {
+    "target": "ES2022",
+    "lib": ["dom", "dom.iterable", "esnext"],
+    "allowJs": false,
+    "skipLibCheck": true,
+    "strict": true,
+    "noEmit": true,
+    "esModuleInterop": true,
+    "module": "esnext",
+    "moduleResolution": "bundler",
+    "resolveJsonModule": true,
+    "isolatedModules": true,
+    "jsx": "preserve",
+    "incremental": true,
+    "types": ["jest", "node"],
+    "baseUrl": ".",
+    "paths": {
+      "@/*": ["src/*"]
+    }
+  },
+  "include": ["next-env.d.ts", "src", "tests"],
+  "exclude": ["node_modules"]
+}
