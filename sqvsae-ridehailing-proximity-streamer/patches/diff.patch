diff -ruN repository_before/broadcast.go repository_after/broadcast.go
--- repository_before/broadcast.go	1970-01-01 03:00:00.000000000 +0300
+++ repository_after/broadcast.go	2026-02-02 12:16:34.810787000 +0300
@@ -0,0 +1,294 @@
+package proximity
+
+import (
+	"encoding/json"
+	"sync"
+	"time"
+)
+
+// BroadcastEngine handles the core broadcasting logic
+type BroadcastEngine struct {
+	hub         *Hub
+	pubsub      PubSub
+	rideStore   RideStore
+	broadcaster *DistributedBroadcaster
+
+	// Proximity checkers per ride
+	proximityCheckers map[string]*ProximityChecker
+
+	// Track if nearby notification was sent per ride
+	nearbyNotified map[string]bool
+
+	// Message queue for ordering
+	messageQueues map[string]*MessageQueue
+
+	mu sync.RWMutex
+}
+
+// MessageQueue ensures strict ordering of messages per ride
+type MessageQueue struct {
+	messages     []QueuedMessage
+	lastSent     int64
+	mu           sync.Mutex
+}
+
+// QueuedMessage represents a message waiting to be sent
+type QueuedMessage struct {
+	Sequence  int64
+	Data      []byte
+	Timestamp int64
+}
+
+// NewMessageQueue creates a new message queue
+func NewMessageQueue() *MessageQueue {
+	return &MessageQueue{
+		messages: make([]QueuedMessage, 0),
+	}
+}
+
+// Enqueue adds a message to the queue
+func (q *MessageQueue) Enqueue(seq int64, data []byte, timestamp int64) {
+	q.mu.Lock()
+	defer q.mu.Unlock()
+	q.messages = append(q.messages, QueuedMessage{
+		Sequence:  seq,
+		Data:      data,
+		Timestamp: timestamp,
+	})
+}
+
+// Dequeue returns messages in order
+func (q *MessageQueue) Dequeue() []QueuedMessage {
+	q.mu.Lock()
+	defer q.mu.Unlock()
+
+	if len(q.messages) == 0 {
+		return nil
+	}
+
+	// Sort by sequence and return
+	result := make([]QueuedMessage, len(q.messages))
+	copy(result, q.messages)
+	q.messages = q.messages[:0]
+
+	// Simple insertion sort for maintaining order
+	for i := 1; i < len(result); i++ {
+		j := i
+		for j > 0 && result[j-1].Sequence > result[j].Sequence {
+			result[j-1], result[j] = result[j], result[j-1]
+			j--
+		}
+	}
+
+	return result
+}
+
+// NewBroadcastEngine creates a new broadcast engine
+func NewBroadcastEngine(hub *Hub, pubsub PubSub, rideStore RideStore) *BroadcastEngine {
+	engine := &BroadcastEngine{
+		hub:               hub,
+		pubsub:            pubsub,
+		rideStore:         rideStore,
+		proximityCheckers: make(map[string]*ProximityChecker),
+		nearbyNotified:    make(map[string]bool),
+		messageQueues:     make(map[string]*MessageQueue),
+	}
+
+	if pubsub != nil {
+		engine.broadcaster = NewDistributedBroadcaster(hub, pubsub, "node-1")
+	}
+
+	return engine
+}
+
+// RegisterRide sets up proximity checking for a ride
+func (e *BroadcastEngine) RegisterRide(rideID string, pickupLat, pickupLng float64) {
+	e.mu.Lock()
+	defer e.mu.Unlock()
+	e.proximityCheckers[rideID] = NewProximityChecker(pickupLat, pickupLng)
+	e.nearbyNotified[rideID] = false
+	e.messageQueues[rideID] = NewMessageQueue()
+
+	// Subscribe to pubsub for distributed messaging
+	if e.broadcaster != nil {
+		e.broadcaster.SubscribeToRide(rideID)
+	}
+}
+
+// UnregisterRide removes a ride from the engine
+func (e *BroadcastEngine) UnregisterRide(rideID string) {
+	e.mu.Lock()
+	defer e.mu.Unlock()
+	delete(e.proximityCheckers, rideID)
+	delete(e.nearbyNotified, rideID)
+	delete(e.messageQueues, rideID)
+}
+
+// ProcessTelemetry handles incoming driver telemetry
+func (e *BroadcastEngine) ProcessTelemetry(telemetry DriverTelemetry) error {
+	rideID := telemetry.RideID
+
+	// Check if ride is completed
+	if e.rideStore != nil && e.rideStore.IsRideCompleted(rideID) {
+		e.hub.DisconnectRideSubscribers(rideID)
+		return nil
+	}
+
+	// Get sequence number for ordering
+	sequence := e.hub.GetNextSequence(rideID)
+
+	// Create coordinate update
+	coordUpdate := CoordUpdate{
+		Type:      TypeCoordUpdate,
+		Lat:       telemetry.Lat,
+		Lng:       telemetry.Lng,
+		Heading:   telemetry.Heading,
+		Timestamp: telemetry.Timestamp,
+		Sequence:  sequence,
+	}
+
+	// Check proximity
+	e.mu.RLock()
+	checker := e.proximityCheckers[rideID]
+	notified := e.nearbyNotified[rideID]
+	e.mu.RUnlock()
+
+	if checker != nil {
+		result := checker.CheckProximity(telemetry.Lat, telemetry.Lng, notified)
+
+		// Send NEARBY_NOTIFICATION if threshold crossed for the first time
+		if result.CrossedThreshold {
+			e.mu.Lock()
+			e.nearbyNotified[rideID] = true
+			e.mu.Unlock()
+
+			notification := NearbyNotification{
+				Type:                 TypeNearbyNotification,
+				CurrentDistance:      result.Distance,
+				EstimatedArrivalTime: EstimateArrivalTime(result.Distance),
+			}
+
+			notifData, _ := json.Marshal(notification)
+
+			// Send notification BEFORE coordinate update
+			if e.broadcaster != nil {
+				e.broadcaster.BroadcastNearby(rideID, notification)
+			} else {
+				e.hub.BroadcastToRide(rideID, notifData)
+			}
+		}
+	}
+
+	// Broadcast coordinate update
+	coordData, err := json.Marshal(coordUpdate)
+	if err != nil {
+		return err
+	}
+
+	if e.broadcaster != nil {
+		e.broadcaster.BroadcastLocation(rideID, coordUpdate)
+	} else {
+		e.hub.BroadcastToRide(rideID, coordData)
+	}
+
+	return nil
+}
+
+// CompleteRide marks a ride as completed and disconnects subscribers
+func (e *BroadcastEngine) CompleteRide(rideID string) {
+	e.hub.DisconnectRideSubscribers(rideID)
+	e.UnregisterRide(rideID)
+}
+
+// IsNearbyNotified checks if nearby notification was sent for a ride
+func (e *BroadcastEngine) IsNearbyNotified(rideID string) bool {
+	e.mu.RLock()
+	defer e.mu.RUnlock()
+	return e.nearbyNotified[rideID]
+}
+
+// GetProximityChecker returns the proximity checker for a ride
+func (e *BroadcastEngine) GetProximityChecker(rideID string) *ProximityChecker {
+	e.mu.RLock()
+	defer e.mu.RUnlock()
+	return e.proximityCheckers[rideID]
+}
+
+// ProcessBatch handles multiple telemetry updates efficiently
+func (e *BroadcastEngine) ProcessBatch(updates []DriverTelemetry) error {
+	for _, update := range updates {
+		if err := e.ProcessTelemetry(update); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+// TelemetryProcessor handles high-throughput telemetry processing
+type TelemetryProcessor struct {
+	engine     *BroadcastEngine
+	inputChan  chan DriverTelemetry
+	batchSize  int
+	flushInterval time.Duration
+	done       chan struct{}
+}
+
+// NewTelemetryProcessor creates a processor for high-throughput scenarios
+func NewTelemetryProcessor(engine *BroadcastEngine, batchSize int, flushInterval time.Duration) *TelemetryProcessor {
+	return &TelemetryProcessor{
+		engine:        engine,
+		inputChan:     make(chan DriverTelemetry, 10000),
+		batchSize:     batchSize,
+		flushInterval: flushInterval,
+		done:          make(chan struct{}),
+	}
+}
+
+// Submit adds telemetry to the processing queue
+func (p *TelemetryProcessor) Submit(telemetry DriverTelemetry) {
+	select {
+	case p.inputChan <- telemetry:
+	default:
+		// Queue full, process synchronously
+		p.engine.ProcessTelemetry(telemetry)
+	}
+}
+
+// Start begins processing telemetry
+func (p *TelemetryProcessor) Start() {
+	go p.processLoop()
+}
+
+// Stop stops the processor
+func (p *TelemetryProcessor) Stop() {
+	close(p.done)
+}
+
+func (p *TelemetryProcessor) processLoop() {
+	ticker := time.NewTicker(p.flushInterval)
+	defer ticker.Stop()
+
+	batch := make([]DriverTelemetry, 0, p.batchSize)
+
+	for {
+		select {
+		case telemetry := <-p.inputChan:
+			batch = append(batch, telemetry)
+			if len(batch) >= p.batchSize {
+				p.engine.ProcessBatch(batch)
+				batch = batch[:0]
+			}
+		case <-ticker.C:
+			if len(batch) > 0 {
+				p.engine.ProcessBatch(batch)
+				batch = batch[:0]
+			}
+		case <-p.done:
+			// Process remaining
+			if len(batch) > 0 {
+				p.engine.ProcessBatch(batch)
+			}
+			return
+		}
+	}
+}
diff -ruN repository_before/client.go repository_after/client.go
--- repository_before/client.go	1970-01-01 03:00:00.000000000 +0300
+++ repository_after/client.go	2026-02-02 12:14:45.656458400 +0300
@@ -0,0 +1,185 @@
+package proximity
+
+import (
+	"encoding/json"
+	"sync"
+	"time"
+)
+
+// MessageSender interface for sending messages (allows mocking)
+type MessageSender interface {
+	SendMessage(data []byte) error
+	Close() error
+}
+
+// Client represents a connected WebSocket client
+type Client struct {
+	ID             string
+	UserID         string
+	RideID         string
+	Sender         MessageSender
+	Hub            *Hub
+	LastActivity   time.Time
+	IsSubscribed   bool
+	NotifiedNearby bool
+	LastSequence   int64
+	closed         bool
+	mu             sync.RWMutex
+	sendChan       chan []byte
+	done           chan struct{}
+}
+
+// NewClient creates a new client instance
+func NewClient(id string, sender MessageSender, hub *Hub) *Client {
+	return &Client{
+		ID:           id,
+		Sender:       sender,
+		Hub:          hub,
+		LastActivity: time.Now(),
+		sendChan:     make(chan []byte, 256),
+		done:         make(chan struct{}),
+	}
+}
+
+// Send sends a message directly to the client
+func (c *Client) Send(data []byte) error {
+	c.mu.RLock()
+	if c.closed {
+		c.mu.RUnlock()
+		return nil
+	}
+	sender := c.Sender
+	c.mu.RUnlock()
+
+	if sender != nil {
+		return sender.SendMessage(data)
+	}
+	return nil
+}
+
+// SendJSON marshals and sends a JSON message
+func (c *Client) SendJSON(v interface{}) error {
+	data, err := json.Marshal(v)
+	if err != nil {
+		return err
+	}
+	return c.Send(data)
+}
+
+// UpdateActivity updates the last activity timestamp
+func (c *Client) UpdateActivity() {
+	c.mu.Lock()
+	c.LastActivity = time.Now()
+	c.mu.Unlock()
+}
+
+// IsIdle checks if the client has been idle beyond the timeout
+func (c *Client) IsIdle() bool {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return time.Since(c.LastActivity) > HeartbeatTimeout
+}
+
+// MarkNotifiedNearby marks that the NEARBY_NOTIFICATION has been sent
+func (c *Client) MarkNotifiedNearby() {
+	c.mu.Lock()
+	c.NotifiedNearby = true
+	c.mu.Unlock()
+}
+
+// HasNotifiedNearby checks if NEARBY_NOTIFICATION was already sent
+func (c *Client) HasNotifiedNearby() bool {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return c.NotifiedNearby
+}
+
+// UpdateSequence updates and returns the next sequence number
+func (c *Client) UpdateSequence() int64 {
+	c.mu.Lock()
+	c.LastSequence++
+	seq := c.LastSequence
+	c.mu.Unlock()
+	return seq
+}
+
+// GetSequence returns the current sequence number
+func (c *Client) GetSequence() int64 {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return c.LastSequence
+}
+
+// Subscribe sets the client's subscription
+func (c *Client) Subscribe(rideID, userID string) {
+	c.mu.Lock()
+	c.RideID = rideID
+	c.UserID = userID
+	c.IsSubscribed = true
+	c.NotifiedNearby = false
+	c.LastSequence = 0
+	c.mu.Unlock()
+}
+
+// Unsubscribe clears the client's subscription
+func (c *Client) Unsubscribe() {
+	c.mu.Lock()
+	c.RideID = ""
+	c.UserID = ""
+	c.IsSubscribed = false
+	c.NotifiedNearby = false
+	c.mu.Unlock()
+}
+
+// Close closes the client connection
+func (c *Client) Close() {
+	c.mu.Lock()
+	if c.closed {
+		c.mu.Unlock()
+		return
+	}
+	c.closed = true
+	close(c.done)
+	c.mu.Unlock()
+
+	if c.Sender != nil {
+		c.Sender.Close()
+	}
+}
+
+// IsClosed checks if the client is closed
+func (c *Client) IsClosed() bool {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return c.closed
+}
+
+// WritePump handles outgoing messages (run as goroutine)
+func (c *Client) WritePump() {
+	ticker := time.NewTicker(HeartbeatInterval)
+	defer ticker.Stop()
+
+	for {
+		select {
+		case message, ok := <-c.sendChan:
+			if !ok {
+				return
+			}
+			if c.Sender != nil {
+				c.Sender.SendMessage(message)
+			}
+		case <-ticker.C:
+			// Send heartbeat
+			heartbeat := map[string]interface{}{
+				"type":      TypeHeartbeat,
+				"timestamp": time.Now().Unix(),
+			}
+			data, _ := json.Marshal(heartbeat)
+			if c.Sender != nil {
+				c.Sender.SendMessage(data)
+			}
+		case <-c.done:
+			return
+		}
+	}
+}
diff -ruN repository_before/hub.go repository_after/hub.go
--- repository_before/hub.go	1970-01-01 03:00:00.000000000 +0300
+++ repository_after/hub.go	2026-02-02 12:13:23.232432800 +0300
@@ -0,0 +1,299 @@
+package proximity
+
+import (
+	"encoding/json"
+	"sync"
+	"time"
+)
+
+// RideStore interface for ride data access
+type RideStore interface {
+	GetRide(rideID string) (*Ride, error)
+	IsRideCompleted(rideID string) bool
+}
+
+// Hub manages all WebSocket connections and subscriptions
+type Hub struct {
+	// Maps rideID -> map of clientID -> Client
+	subscriptions map[string]map[string]*Client
+
+	// All connected clients by ID
+	clients map[string]*Client
+
+	// PubSub for distributed messaging
+	pubsub PubSub
+
+	// Ride data store
+	rideStore RideStore
+
+	// Sequence counters per ride for message ordering
+	rideSequences map[string]int64
+
+	mu sync.RWMutex
+
+	// Channels for hub operations
+	register   chan *Client
+	unregister chan *Client
+	broadcast  chan *BroadcastMessage
+
+	// Cleanup ticker
+	cleanupDone chan struct{}
+}
+
+// BroadcastMessage represents a message to broadcast to a ride
+type BroadcastMessage struct {
+	RideID  string
+	Message []byte
+}
+
+// NewHub creates a new Hub instance
+func NewHub(pubsub PubSub, rideStore RideStore) *Hub {
+	h := &Hub{
+		subscriptions: make(map[string]map[string]*Client),
+		clients:       make(map[string]*Client),
+		pubsub:        pubsub,
+		rideStore:     rideStore,
+		rideSequences: make(map[string]int64),
+		register:      make(chan *Client, 256),
+		unregister:    make(chan *Client, 256),
+		broadcast:     make(chan *BroadcastMessage, 1024),
+		cleanupDone:   make(chan struct{}),
+	}
+	return h
+}
+
+// Run starts the hub's main loop
+func (h *Hub) Run() {
+	go h.cleanupLoop()
+
+	for {
+		select {
+		case client := <-h.register:
+			h.handleRegister(client)
+		case client := <-h.unregister:
+			h.handleUnregister(client)
+		case msg := <-h.broadcast:
+			h.handleBroadcast(msg)
+		}
+	}
+}
+
+// RegisterClient adds a client to the hub
+func (h *Hub) RegisterClient(client *Client) {
+	h.register <- client
+}
+
+// UnregisterClient removes a client from the hub
+func (h *Hub) UnregisterClient(client *Client) {
+	h.unregister <- client
+}
+
+// handleRegister processes client registration
+func (h *Hub) handleRegister(client *Client) {
+	h.mu.Lock()
+	h.clients[client.ID] = client
+	h.mu.Unlock()
+}
+
+// handleUnregister processes client unregistration
+func (h *Hub) handleUnregister(client *Client) {
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	if _, ok := h.clients[client.ID]; ok {
+		delete(h.clients, client.ID)
+
+		// Remove from ride subscriptions
+		if client.RideID != "" {
+			if subs, ok := h.subscriptions[client.RideID]; ok {
+				delete(subs, client.ID)
+				if len(subs) == 0 {
+					delete(h.subscriptions, client.RideID)
+				}
+			}
+		}
+
+		client.Close()
+	}
+}
+
+// SubscribeToRide subscribes a client to a specific ride
+func (h *Hub) SubscribeToRide(client *Client, rideID, userID string) error {
+	// Validate ride exists and belongs to user
+	if h.rideStore != nil {
+		ride, err := h.rideStore.GetRide(rideID)
+		if err != nil {
+			return err
+		}
+		if ride == nil {
+			return &ValidationError{Message: "ride not found", Code: "RIDE_NOT_FOUND"}
+		}
+		if ride.PassengerID != userID {
+			return &ValidationError{Message: "unauthorized access to ride", Code: "UNAUTHORIZED"}
+		}
+		if ride.Status == "completed" {
+			return &ValidationError{Message: "ride already completed", Code: "RIDE_COMPLETED"}
+		}
+	}
+
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	// Remove from previous subscription if any
+	if client.RideID != "" && client.RideID != rideID {
+		if subs, ok := h.subscriptions[client.RideID]; ok {
+			delete(subs, client.ID)
+		}
+	}
+
+	// Add to new subscription
+	if _, ok := h.subscriptions[rideID]; !ok {
+		h.subscriptions[rideID] = make(map[string]*Client)
+	}
+	h.subscriptions[rideID][client.ID] = client
+
+	// Update client state
+	client.Subscribe(rideID, userID)
+
+	return nil
+}
+
+// UnsubscribeFromRide removes a client from ride updates
+func (h *Hub) UnsubscribeFromRide(client *Client) {
+	h.mu.Lock()
+	defer h.mu.Unlock()
+
+	if client.RideID != "" {
+		if subs, ok := h.subscriptions[client.RideID]; ok {
+			delete(subs, client.ID)
+			if len(subs) == 0 {
+				delete(h.subscriptions, client.RideID)
+			}
+		}
+	}
+
+	client.Unsubscribe()
+}
+
+// BroadcastToRide sends a message to all subscribers of a ride
+func (h *Hub) BroadcastToRide(rideID string, message []byte) {
+	h.broadcast <- &BroadcastMessage{
+		RideID:  rideID,
+		Message: message,
+	}
+}
+
+// handleBroadcast processes broadcast messages
+func (h *Hub) handleBroadcast(msg *BroadcastMessage) {
+	h.mu.RLock()
+	subscribers := h.subscriptions[msg.RideID]
+	h.mu.RUnlock()
+
+	for _, client := range subscribers {
+		client.Send(msg.Message)
+	}
+}
+
+// GetNextSequence returns the next sequence number for a ride
+func (h *Hub) GetNextSequence(rideID string) int64 {
+	h.mu.Lock()
+	defer h.mu.Unlock()
+	h.rideSequences[rideID]++
+	return h.rideSequences[rideID]
+}
+
+// GetSubscribers returns all clients subscribed to a ride
+func (h *Hub) GetSubscribers(rideID string) []*Client {
+	h.mu.RLock()
+	defer h.mu.RUnlock()
+
+	subs, ok := h.subscriptions[rideID]
+	if !ok {
+		return nil
+	}
+
+	clients := make([]*Client, 0, len(subs))
+	for _, client := range subs {
+		clients = append(clients, client)
+	}
+	return clients
+}
+
+// DisconnectRideSubscribers disconnects all subscribers of a completed ride
+func (h *Hub) DisconnectRideSubscribers(rideID string) {
+	h.mu.Lock()
+	subscribers := h.subscriptions[rideID]
+	delete(h.subscriptions, rideID)
+	delete(h.rideSequences, rideID)
+	h.mu.Unlock()
+
+	// Send completion message and disconnect
+	completedMsg := RideCompletedEvent{
+		Type:   TypeRideCompleted,
+		RideID: rideID,
+	}
+	msgData, _ := json.Marshal(completedMsg)
+
+	for _, client := range subscribers {
+		client.Send(msgData)
+		h.UnregisterClient(client)
+	}
+}
+
+// cleanupLoop periodically cleans up idle connections
+func (h *Hub) cleanupLoop() {
+	ticker := time.NewTicker(10 * time.Second)
+	defer ticker.Stop()
+
+	for {
+		select {
+		case <-ticker.C:
+			h.cleanupIdleClients()
+		case <-h.cleanupDone:
+			return
+		}
+	}
+}
+
+// cleanupIdleClients removes clients that have been idle too long
+func (h *Hub) cleanupIdleClients() {
+	h.mu.RLock()
+	var idleClients []*Client
+	for _, client := range h.clients {
+		if client.IsIdle() {
+			idleClients = append(idleClients, client)
+		}
+	}
+	h.mu.RUnlock()
+
+	for _, client := range idleClients {
+		h.UnregisterClient(client)
+	}
+}
+
+// GetClientCount returns the total number of connected clients
+func (h *Hub) GetClientCount() int {
+	h.mu.RLock()
+	defer h.mu.RUnlock()
+	return len(h.clients)
+}
+
+// GetSubscriberCount returns the number of subscribers for a ride
+func (h *Hub) GetSubscriberCount(rideID string) int {
+	h.mu.RLock()
+	defer h.mu.RUnlock()
+	if subs, ok := h.subscriptions[rideID]; ok {
+		return len(subs)
+	}
+	return 0
+}
+
+// ValidationError represents a validation error
+type ValidationError struct {
+	Message string
+	Code    string
+}
+
+func (e *ValidationError) Error() string {
+	return e.Message
+}
diff -ruN repository_before/proximity.go repository_after/proximity.go
--- repository_before/proximity.go	1970-01-01 03:00:00.000000000 +0300
+++ repository_after/proximity.go	2026-02-02 12:13:21.843597900 +0300
@@ -0,0 +1,81 @@
+package proximity
+
+import (
+	"math"
+)
+
+const (
+	earthRadiusMeters = 6371000.0
+)
+
+// HaversineDistance calculates the distance between two coordinates in meters
+// using the Haversine formula for great-circle distance
+func HaversineDistance(lat1, lng1, lat2, lng2 float64) float64 {
+	// Convert to radians
+	lat1Rad := lat1 * math.Pi / 180
+	lat2Rad := lat2 * math.Pi / 180
+	deltaLat := (lat2 - lat1) * math.Pi / 180
+	deltaLng := (lng2 - lng1) * math.Pi / 180
+
+	// Haversine formula
+	a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
+		math.Cos(lat1Rad)*math.Cos(lat2Rad)*
+			math.Sin(deltaLng/2)*math.Sin(deltaLng/2)
+	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
+
+	return earthRadiusMeters * c
+}
+
+// ProximityChecker handles proximity threshold detection
+type ProximityChecker struct {
+	pickupLat float64
+	pickupLng float64
+}
+
+// NewProximityChecker creates a new proximity checker for a pickup location
+func NewProximityChecker(pickupLat, pickupLng float64) *ProximityChecker {
+	return &ProximityChecker{
+		pickupLat: pickupLat,
+		pickupLng: pickupLng,
+	}
+}
+
+// CheckDistance calculates distance from driver to pickup point
+func (p *ProximityChecker) CheckDistance(driverLat, driverLng float64) float64 {
+	return HaversineDistance(driverLat, driverLng, p.pickupLat, p.pickupLng)
+}
+
+// IsWithinThreshold checks if distance is within the proximity threshold
+func (p *ProximityChecker) IsWithinThreshold(distance float64) bool {
+	return distance <= ProximityThreshold
+}
+
+// ProximityResult contains the result of a proximity check
+type ProximityResult struct {
+	Distance          float64
+	WithinThreshold   bool
+	CrossedThreshold  bool // True only on first crossing
+}
+
+// CheckProximity performs a full proximity check with threshold crossing detection
+func (p *ProximityChecker) CheckProximity(driverLat, driverLng float64, wasWithinThreshold bool) ProximityResult {
+	distance := p.CheckDistance(driverLat, driverLng)
+	withinThreshold := p.IsWithinThreshold(distance)
+
+	// Crossed threshold = now within AND wasn't before
+	crossedThreshold := withinThreshold && !wasWithinThreshold
+
+	return ProximityResult{
+		Distance:         distance,
+		WithinThreshold:  withinThreshold,
+		CrossedThreshold: crossedThreshold,
+	}
+}
+
+// EstimateArrivalTime estimates arrival time in seconds based on distance
+// Assumes average speed of ~20 km/h in urban areas
+func EstimateArrivalTime(distanceMeters float64) int {
+	// 20 km/h = 5.56 m/s
+	avgSpeedMps := 5.56
+	return int(math.Ceil(distanceMeters / avgSpeedMps))
+}
diff -ruN repository_before/pubsub.go repository_after/pubsub.go
--- repository_before/pubsub.go	1970-01-01 03:00:00.000000000 +0300
+++ repository_after/pubsub.go	2026-02-02 12:17:21.954970700 +0300
@@ -0,0 +1,196 @@
+package proximity
+
+import (
+	"encoding/json"
+	"sync"
+)
+
+// PubSub interface for distributed messaging
+type PubSub interface {
+	Publish(channel string, message []byte) error
+	Subscribe(channel string, handler func([]byte)) error
+	Unsubscribe(channel string) error
+	Close() error
+}
+
+// PubSubMessage wraps messages for pub/sub transport
+type PubSubMessage struct {
+	Type    string          `json:"type"`
+	RideID  string          `json:"rideId"`
+	Payload json.RawMessage `json:"payload"`
+}
+
+// InMemoryPubSub implements PubSub for single-node or testing
+type InMemoryPubSub struct {
+	subscribers map[string][]func([]byte)
+	mu          sync.RWMutex
+}
+
+// NewInMemoryPubSub creates a new in-memory pub/sub instance
+func NewInMemoryPubSub() *InMemoryPubSub {
+	return &InMemoryPubSub{
+		subscribers: make(map[string][]func([]byte)),
+	}
+}
+
+// Publish sends a message to all subscribers of a channel
+func (p *InMemoryPubSub) Publish(channel string, message []byte) error {
+	p.mu.RLock()
+	handlers := p.subscribers[channel]
+	p.mu.RUnlock()
+
+	for _, handler := range handlers {
+		// Call handlers synchronously to preserve ordering
+		handler(message)
+	}
+	return nil
+}
+
+// Subscribe adds a handler for a channel
+func (p *InMemoryPubSub) Subscribe(channel string, handler func([]byte)) error {
+	p.mu.Lock()
+	defer p.mu.Unlock()
+	p.subscribers[channel] = append(p.subscribers[channel], handler)
+	return nil
+}
+
+// Unsubscribe removes all handlers for a channel
+func (p *InMemoryPubSub) Unsubscribe(channel string) error {
+	p.mu.Lock()
+	defer p.mu.Unlock()
+	delete(p.subscribers, channel)
+	return nil
+}
+
+// Close cleans up resources
+func (p *InMemoryPubSub) Close() error {
+	p.mu.Lock()
+	defer p.mu.Unlock()
+	p.subscribers = make(map[string][]func([]byte))
+	return nil
+}
+
+// RedisPubSub implements PubSub using Redis (interface for production)
+// This is a placeholder that would use a Redis client in production
+type RedisPubSub struct {
+	addr        string
+	subscribers map[string][]func([]byte)
+	mu          sync.RWMutex
+}
+
+// NewRedisPubSub creates a new Redis pub/sub instance
+func NewRedisPubSub(addr string) *RedisPubSub {
+	return &RedisPubSub{
+		addr:        addr,
+		subscribers: make(map[string][]func([]byte)),
+	}
+}
+
+// Publish sends a message via Redis
+func (r *RedisPubSub) Publish(channel string, message []byte) error {
+	// In production, this would use redis.Publish
+	// For now, use in-memory for testing
+	r.mu.RLock()
+	handlers := r.subscribers[channel]
+	r.mu.RUnlock()
+
+	for _, handler := range handlers {
+		handler(message)
+	}
+	return nil
+}
+
+// Subscribe adds a handler for Redis channel
+func (r *RedisPubSub) Subscribe(channel string, handler func([]byte)) error {
+	r.mu.Lock()
+	defer r.mu.Unlock()
+	r.subscribers[channel] = append(r.subscribers[channel], handler)
+	return nil
+}
+
+// Unsubscribe removes handlers for a channel
+func (r *RedisPubSub) Unsubscribe(channel string) error {
+	r.mu.Lock()
+	defer r.mu.Unlock()
+	delete(r.subscribers, channel)
+	return nil
+}
+
+// Close closes Redis connections
+func (r *RedisPubSub) Close() error {
+	r.mu.Lock()
+	defer r.mu.Unlock()
+	r.subscribers = make(map[string][]func([]byte))
+	return nil
+}
+
+// DistributedBroadcaster handles broadcasting across nodes
+type DistributedBroadcaster struct {
+	hub    *Hub
+	pubsub PubSub
+	nodeID string
+}
+
+// NewDistributedBroadcaster creates a broadcaster for multi-node setup
+func NewDistributedBroadcaster(hub *Hub, pubsub PubSub, nodeID string) *DistributedBroadcaster {
+	return &DistributedBroadcaster{
+		hub:    hub,
+		pubsub: pubsub,
+		nodeID: nodeID,
+	}
+}
+
+// BroadcastLocation publishes a location update to the pub/sub bus
+func (d *DistributedBroadcaster) BroadcastLocation(rideID string, update CoordUpdate) error {
+	payload, err := json.Marshal(update)
+	if err != nil {
+		return err
+	}
+
+	msg := PubSubMessage{
+		Type:    TypeCoordUpdate,
+		RideID:  rideID,
+		Payload: payload,
+	}
+
+	data, err := json.Marshal(msg)
+	if err != nil {
+		return err
+	}
+
+	return d.pubsub.Publish("ride:"+rideID, data)
+}
+
+// BroadcastNearby publishes a nearby notification to the pub/sub bus
+func (d *DistributedBroadcaster) BroadcastNearby(rideID string, notification NearbyNotification) error {
+	payload, err := json.Marshal(notification)
+	if err != nil {
+		return err
+	}
+
+	msg := PubSubMessage{
+		Type:    TypeNearbyNotification,
+		RideID:  rideID,
+		Payload: payload,
+	}
+
+	data, err := json.Marshal(msg)
+	if err != nil {
+		return err
+	}
+
+	return d.pubsub.Publish("ride:"+rideID, data)
+}
+
+// SubscribeToRide sets up subscription for receiving ride updates from other nodes
+func (d *DistributedBroadcaster) SubscribeToRide(rideID string) error {
+	return d.pubsub.Subscribe("ride:"+rideID, func(data []byte) {
+		var msg PubSubMessage
+		if err := json.Unmarshal(data, &msg); err != nil {
+			return
+		}
+
+		// Broadcast to local subscribers
+		d.hub.BroadcastToRide(rideID, msg.Payload)
+	})
+}
diff -ruN repository_before/smoother.go repository_after/smoother.go
--- repository_before/smoother.go	1970-01-01 03:00:00.000000000 +0300
+++ repository_after/smoother.go	2026-02-02 12:13:25.352557400 +0300
@@ -0,0 +1,307 @@
+package proximity
+
+import (
+	"math"
+	"sync"
+	"time"
+)
+
+// PositionSmoother implements client-side position interpolation
+// to prevent the UI vehicle icon from "teleporting" during high network jitter
+type PositionSmoother struct {
+	// Current interpolated position
+	currentLat float64
+	currentLng float64
+	currentHeading float64
+
+	// Target position from latest update
+	targetLat float64
+	targetLng float64
+	targetHeading float64
+
+	// Previous positions for velocity estimation
+	positions []TimestampedPosition
+
+	// Smoothing parameters
+	smoothingFactor float64 // 0-1, higher = faster response
+	maxPositionHistory int
+
+	// Last update time
+	lastUpdateTime time.Time
+	lastRenderTime time.Time
+
+	mu sync.RWMutex
+}
+
+// TimestampedPosition represents a position with timestamp
+type TimestampedPosition struct {
+	Lat       float64
+	Lng       float64
+	Heading   float64
+	Timestamp time.Time
+}
+
+// SmoothedPosition represents the current smoothed position
+type SmoothedPosition struct {
+	Lat       float64
+	Lng       float64
+	Heading   float64
+	Velocity  float64 // m/s
+	IsMoving  bool
+}
+
+// NewPositionSmoother creates a new position smoother
+func NewPositionSmoother(smoothingFactor float64) *PositionSmoother {
+	if smoothingFactor <= 0 || smoothingFactor > 1 {
+		smoothingFactor = 0.3 // Default smoothing
+	}
+	return &PositionSmoother{
+		smoothingFactor:    smoothingFactor,
+		maxPositionHistory: 5,
+		positions:          make([]TimestampedPosition, 0, 5),
+	}
+}
+
+// Update processes a new coordinate update
+func (s *PositionSmoother) Update(lat, lng, heading float64) {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+
+	now := time.Now()
+
+	// Initialize if first update
+	if s.lastUpdateTime.IsZero() {
+		s.currentLat = lat
+		s.currentLng = lng
+		s.currentHeading = heading
+		s.targetLat = lat
+		s.targetLng = lng
+		s.targetHeading = heading
+		s.lastUpdateTime = now
+		s.lastRenderTime = now
+		return
+	}
+
+	// Store in position history
+	s.positions = append(s.positions, TimestampedPosition{
+		Lat:       lat,
+		Lng:       lng,
+		Heading:   heading,
+		Timestamp: now,
+	})
+
+	// Trim history
+	if len(s.positions) > s.maxPositionHistory {
+		s.positions = s.positions[1:]
+	}
+
+	// Update target
+	s.targetLat = lat
+	s.targetLng = lng
+	s.targetHeading = heading
+	s.lastUpdateTime = now
+}
+
+// GetSmoothedPosition returns the current interpolated position
+func (s *PositionSmoother) GetSmoothedPosition() SmoothedPosition {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+
+	now := time.Now()
+	dt := now.Sub(s.lastRenderTime).Seconds()
+	s.lastRenderTime = now
+
+	if dt <= 0 {
+		dt = 0.016 // ~60fps default
+	}
+
+	// Exponential smoothing (lerp towards target)
+	alpha := 1.0 - math.Exp(-s.smoothingFactor*dt*10)
+
+	s.currentLat = lerp(s.currentLat, s.targetLat, alpha)
+	s.currentLng = lerp(s.currentLng, s.targetLng, alpha)
+	s.currentHeading = lerpAngle(s.currentHeading, s.targetHeading, alpha)
+
+	// Calculate velocity from position history
+	velocity := s.calculateVelocity()
+
+	return SmoothedPosition{
+		Lat:      s.currentLat,
+		Lng:      s.currentLng,
+		Heading:  s.currentHeading,
+		Velocity: velocity,
+		IsMoving: velocity > 0.5, // Moving if > 0.5 m/s
+	}
+}
+
+// calculateVelocity estimates velocity from position history
+func (s *PositionSmoother) calculateVelocity() float64 {
+	if len(s.positions) < 2 {
+		return 0
+	}
+
+	// Use last two positions
+	p1 := s.positions[len(s.positions)-2]
+	p2 := s.positions[len(s.positions)-1]
+
+	dt := p2.Timestamp.Sub(p1.Timestamp).Seconds()
+	if dt <= 0 {
+		return 0
+	}
+
+	distance := HaversineDistance(p1.Lat, p1.Lng, p2.Lat, p2.Lng)
+	return distance / dt
+}
+
+// GetTargetPosition returns the raw target position
+func (s *PositionSmoother) GetTargetPosition() (lat, lng, heading float64) {
+	s.mu.RLock()
+	defer s.mu.RUnlock()
+	return s.targetLat, s.targetLng, s.targetHeading
+}
+
+// Reset clears the smoother state
+func (s *PositionSmoother) Reset() {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	s.positions = s.positions[:0]
+	s.lastUpdateTime = time.Time{}
+	s.lastRenderTime = time.Time{}
+}
+
+// lerp performs linear interpolation between two values
+func lerp(a, b, t float64) float64 {
+	return a + (b-a)*t
+}
+
+// lerpAngle performs linear interpolation between two angles (in degrees)
+// handling the wrap-around at 360 degrees
+func lerpAngle(a, b, t float64) float64 {
+	// Normalize angles to 0-360
+	a = normalizeAngle(a)
+	b = normalizeAngle(b)
+
+	// Find shortest path
+	diff := b - a
+	if diff > 180 {
+		diff -= 360
+	} else if diff < -180 {
+		diff += 360
+	}
+
+	return normalizeAngle(a + diff*t)
+}
+
+// normalizeAngle normalizes an angle to 0-360 range
+func normalizeAngle(angle float64) float64 {
+	for angle < 0 {
+		angle += 360
+	}
+	for angle >= 360 {
+		angle -= 360
+	}
+	return angle
+}
+
+// JitterDetector detects network jitter and adjusts smoothing
+type JitterDetector struct {
+	updateIntervals []time.Duration
+	maxHistory      int
+	expectedInterval time.Duration
+	lastUpdate      time.Time
+	mu              sync.Mutex
+}
+
+// NewJitterDetector creates a new jitter detector
+func NewJitterDetector(expectedInterval time.Duration) *JitterDetector {
+	return &JitterDetector{
+		updateIntervals:  make([]time.Duration, 0, 10),
+		maxHistory:       10,
+		expectedInterval: expectedInterval,
+	}
+}
+
+// RecordUpdate records an update timestamp
+func (j *JitterDetector) RecordUpdate() {
+	j.mu.Lock()
+	defer j.mu.Unlock()
+
+	now := time.Now()
+	if !j.lastUpdate.IsZero() {
+		interval := now.Sub(j.lastUpdate)
+		j.updateIntervals = append(j.updateIntervals, interval)
+		if len(j.updateIntervals) > j.maxHistory {
+			j.updateIntervals = j.updateIntervals[1:]
+		}
+	}
+	j.lastUpdate = now
+}
+
+// GetJitterLevel returns jitter level (0 = no jitter, 1 = high jitter)
+func (j *JitterDetector) GetJitterLevel() float64 {
+	j.mu.Lock()
+	defer j.mu.Unlock()
+
+	if len(j.updateIntervals) < 2 {
+		return 0
+	}
+
+	// Calculate variance in intervals
+	var sum, sumSq float64
+	for _, interval := range j.updateIntervals {
+		ms := float64(interval.Milliseconds())
+		sum += ms
+		sumSq += ms * ms
+	}
+
+	n := float64(len(j.updateIntervals))
+	mean := sum / n
+	variance := (sumSq / n) - (mean * mean)
+	stdDev := math.Sqrt(variance)
+
+	// Normalize by expected interval
+	expectedMs := float64(j.expectedInterval.Milliseconds())
+	jitterRatio := stdDev / expectedMs
+
+	// Clamp to 0-1
+	if jitterRatio > 1 {
+		jitterRatio = 1
+	}
+	return jitterRatio
+}
+
+// AdaptiveSmoother adjusts smoothing based on jitter
+type AdaptiveSmoother struct {
+	smoother       *PositionSmoother
+	jitterDetector *JitterDetector
+	minSmoothing   float64
+	maxSmoothing   float64
+}
+
+// NewAdaptiveSmoother creates an adaptive smoother
+func NewAdaptiveSmoother(expectedUpdateInterval time.Duration) *AdaptiveSmoother {
+	return &AdaptiveSmoother{
+		smoother:       NewPositionSmoother(0.3),
+		jitterDetector: NewJitterDetector(expectedUpdateInterval),
+		minSmoothing:   0.1,
+		maxSmoothing:   0.5,
+	}
+}
+
+// Update processes a coordinate update with adaptive smoothing
+func (a *AdaptiveSmoother) Update(lat, lng, heading float64) {
+	a.jitterDetector.RecordUpdate()
+
+	// Adjust smoothing based on jitter
+	jitter := a.jitterDetector.GetJitterLevel()
+	// More jitter = lower smoothing factor = smoother movement
+	smoothing := a.maxSmoothing - jitter*(a.maxSmoothing-a.minSmoothing)
+	a.smoother.smoothingFactor = smoothing
+
+	a.smoother.Update(lat, lng, heading)
+}
+
+// GetSmoothedPosition returns the smoothed position
+func (a *AdaptiveSmoother) GetSmoothedPosition() SmoothedPosition {
+	return a.smoother.GetSmoothedPosition()
+}
diff -ruN repository_before/store.go repository_after/store.go
--- repository_before/store.go	1970-01-01 03:00:00.000000000 +0300
+++ repository_after/store.go	2026-02-02 12:13:26.013823300 +0300
@@ -0,0 +1,255 @@
+package proximity
+
+import (
+	"errors"
+	"sync"
+	"time"
+)
+
+// ErrRideNotFound is returned when a ride is not found
+var ErrRideNotFound = errors.New("ride not found")
+
+// InMemoryRideStore implements RideStore for testing
+type InMemoryRideStore struct {
+	rides map[string]*Ride
+	mu    sync.RWMutex
+}
+
+// NewInMemoryRideStore creates a new in-memory ride store
+func NewInMemoryRideStore() *InMemoryRideStore {
+	return &InMemoryRideStore{
+		rides: make(map[string]*Ride),
+	}
+}
+
+// CreateRide adds a new ride to the store
+func (s *InMemoryRideStore) CreateRide(ride *Ride) error {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	s.rides[ride.RideID] = ride
+	return nil
+}
+
+// GetRide retrieves a ride by ID
+func (s *InMemoryRideStore) GetRide(rideID string) (*Ride, error) {
+	s.mu.RLock()
+	defer s.mu.RUnlock()
+	ride, ok := s.rides[rideID]
+	if !ok {
+		return nil, ErrRideNotFound
+	}
+	return ride, nil
+}
+
+// UpdateRideStatus updates the status of a ride
+func (s *InMemoryRideStore) UpdateRideStatus(rideID, status string) error {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	ride, ok := s.rides[rideID]
+	if !ok {
+		return ErrRideNotFound
+	}
+	ride.Status = status
+	return nil
+}
+
+// IsRideCompleted checks if a ride is completed
+func (s *InMemoryRideStore) IsRideCompleted(rideID string) bool {
+	s.mu.RLock()
+	defer s.mu.RUnlock()
+	ride, ok := s.rides[rideID]
+	if !ok {
+		return false
+	}
+	return ride.Status == "completed"
+}
+
+// DeleteRide removes a ride from the store
+func (s *InMemoryRideStore) DeleteRide(rideID string) error {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	delete(s.rides, rideID)
+	return nil
+}
+
+// GetAllRides returns all rides
+func (s *InMemoryRideStore) GetAllRides() []*Ride {
+	s.mu.RLock()
+	defer s.mu.RUnlock()
+	rides := make([]*Ride, 0, len(s.rides))
+	for _, ride := range s.rides {
+		rides = append(rides, ride)
+	}
+	return rides
+}
+
+// GetActiveRides returns all non-completed rides
+func (s *InMemoryRideStore) GetActiveRides() []*Ride {
+	s.mu.RLock()
+	defer s.mu.RUnlock()
+	var rides []*Ride
+	for _, ride := range s.rides {
+		if ride.Status != "completed" {
+			rides = append(rides, ride)
+		}
+	}
+	return rides
+}
+
+// ConnectionTracker tracks client connections per user/ride
+type ConnectionTracker struct {
+	// userID -> list of client IDs
+	userConnections map[string][]string
+	// clientID -> rideID
+	clientRides map[string]string
+	mu          sync.RWMutex
+}
+
+// NewConnectionTracker creates a new connection tracker
+func NewConnectionTracker() *ConnectionTracker {
+	return &ConnectionTracker{
+		userConnections: make(map[string][]string),
+		clientRides:     make(map[string]string),
+	}
+}
+
+// RegisterConnection tracks a new connection
+func (t *ConnectionTracker) RegisterConnection(clientID, userID, rideID string) {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+	t.userConnections[userID] = append(t.userConnections[userID], clientID)
+	t.clientRides[clientID] = rideID
+}
+
+// UnregisterConnection removes a connection
+func (t *ConnectionTracker) UnregisterConnection(clientID, userID string) {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+
+	// Remove from user connections
+	if conns, ok := t.userConnections[userID]; ok {
+		for i, id := range conns {
+			if id == clientID {
+				t.userConnections[userID] = append(conns[:i], conns[i+1:]...)
+				break
+			}
+		}
+	}
+
+	delete(t.clientRides, clientID)
+}
+
+// GetUserConnections returns all connections for a user
+func (t *ConnectionTracker) GetUserConnections(userID string) []string {
+	t.mu.RLock()
+	defer t.mu.RUnlock()
+	return t.userConnections[userID]
+}
+
+// GetClientRide returns the ride ID for a client
+func (t *ConnectionTracker) GetClientRide(clientID string) string {
+	t.mu.RLock()
+	defer t.mu.RUnlock()
+	return t.clientRides[clientID]
+}
+
+// Session represents an active WebSocket session
+type Session struct {
+	ClientID     string
+	UserID       string
+	RideID       string
+	ConnectedAt  time.Time
+	LastActivity time.Time
+	IsActive     bool
+}
+
+// SessionManager manages active sessions
+type SessionManager struct {
+	sessions map[string]*Session
+	mu       sync.RWMutex
+}
+
+// NewSessionManager creates a new session manager
+func NewSessionManager() *SessionManager {
+	return &SessionManager{
+		sessions: make(map[string]*Session),
+	}
+}
+
+// CreateSession creates a new session
+func (m *SessionManager) CreateSession(clientID string) *Session {
+	m.mu.Lock()
+	defer m.mu.Unlock()
+
+	session := &Session{
+		ClientID:     clientID,
+		ConnectedAt:  time.Now(),
+		LastActivity: time.Now(),
+		IsActive:     true,
+	}
+	m.sessions[clientID] = session
+	return session
+}
+
+// GetSession retrieves a session
+func (m *SessionManager) GetSession(clientID string) *Session {
+	m.mu.RLock()
+	defer m.mu.RUnlock()
+	return m.sessions[clientID]
+}
+
+// UpdateSession updates session with ride info
+func (m *SessionManager) UpdateSession(clientID, userID, rideID string) {
+	m.mu.Lock()
+	defer m.mu.Unlock()
+	if session, ok := m.sessions[clientID]; ok {
+		session.UserID = userID
+		session.RideID = rideID
+		session.LastActivity = time.Now()
+	}
+}
+
+// TouchSession updates last activity
+func (m *SessionManager) TouchSession(clientID string) {
+	m.mu.Lock()
+	defer m.mu.Unlock()
+	if session, ok := m.sessions[clientID]; ok {
+		session.LastActivity = time.Now()
+	}
+}
+
+// EndSession ends a session
+func (m *SessionManager) EndSession(clientID string) {
+	m.mu.Lock()
+	defer m.mu.Unlock()
+	if session, ok := m.sessions[clientID]; ok {
+		session.IsActive = false
+	}
+	delete(m.sessions, clientID)
+}
+
+// GetActiveSessions returns all active sessions
+func (m *SessionManager) GetActiveSessions() []*Session {
+	m.mu.RLock()
+	defer m.mu.RUnlock()
+	var sessions []*Session
+	for _, s := range m.sessions {
+		if s.IsActive {
+			sessions = append(sessions, s)
+		}
+	}
+	return sessions
+}
+
+// GetSessionsByRide returns sessions for a specific ride
+func (m *SessionManager) GetSessionsByRide(rideID string) []*Session {
+	m.mu.RLock()
+	defer m.mu.RUnlock()
+	var sessions []*Session
+	for _, s := range m.sessions {
+		if s.RideID == rideID && s.IsActive {
+			sessions = append(sessions, s)
+		}
+	}
+	return sessions
+}
diff -ruN repository_before/types.go repository_after/types.go
--- repository_before/types.go	1970-01-01 03:00:00.000000000 +0300
+++ repository_after/types.go	2026-02-02 12:13:21.038842900 +0300
@@ -0,0 +1,94 @@
+package proximity
+
+import (
+	"sync"
+	"time"
+)
+
+// Message types
+const (
+	TypeCoordUpdate         = "COORD_UPDATE"
+	TypeNearbyNotification  = "NEARBY_NOTIFICATION"
+	TypeSubscribeRide       = "SUBSCRIBE_RIDE"
+	TypeUnsubscribe         = "UNSUBSCRIBE"
+	TypeRideCompleted       = "RIDE_COMPLETED"
+	TypeHeartbeat           = "HEARTBEAT"
+	TypeError               = "ERROR"
+)
+
+// CoordUpdate represents a location update from driver to passenger
+type CoordUpdate struct {
+	Type      string  `json:"type"`
+	Lat       float64 `json:"lat"`
+	Lng       float64 `json:"lng"`
+	Heading   float64 `json:"heading"`
+	Timestamp int64   `json:"timestamp"`
+	Sequence  int64   `json:"sequence,omitempty"`
+}
+
+// NearbyNotification is sent when driver enters the 100m threshold
+type NearbyNotification struct {
+	Type                 string  `json:"type"`
+	CurrentDistance      float64 `json:"currentDistance"`
+	EstimatedArrivalTime int     `json:"estimatedArrivalTime"`
+}
+
+// SubscribeRide is sent by client to subscribe to a ride
+type SubscribeRide struct {
+	Type   string `json:"type"`
+	RideID string `json:"rideId"`
+	UserID string `json:"userId"`
+}
+
+// RideCompletedEvent signals that a ride has ended
+type RideCompletedEvent struct {
+	Type   string `json:"type"`
+	RideID string `json:"rideId"`
+}
+
+// ErrorMessage for client errors
+type ErrorMessage struct {
+	Type    string `json:"type"`
+	Message string `json:"message"`
+	Code    string `json:"code"`
+}
+
+// DriverTelemetry represents incoming telemetry from driver
+type DriverTelemetry struct {
+	DriverID  string  `json:"driverId"`
+	RideID    string  `json:"rideId"`
+	Lat       float64 `json:"lat"`
+	Lng       float64 `json:"lng"`
+	Heading   float64 `json:"heading"`
+	Timestamp int64   `json:"timestamp"`
+}
+
+// Ride represents an active ride session
+type Ride struct {
+	RideID        string
+	DriverID      string
+	PassengerID   string
+	PickupLat     float64
+	PickupLng     float64
+	Status        string
+	CreatedAt     time.Time
+}
+
+// RideSubscription tracks a passenger's subscription to ride updates
+type RideSubscription struct {
+	RideID           string
+	UserID           string
+	Client           *Client
+	NotifiedNearby   bool      // Track if NEARBY_NOTIFICATION was sent
+	LastSequence     int64     // Track message ordering
+	mu               sync.Mutex
+}
+
+// ProximityThreshold in meters for NEARBY_NOTIFICATION
+const ProximityThreshold = 100.0
+
+// HeartbeatTimeout duration before considering connection dead
+const HeartbeatTimeout = 30 * time.Second
+
+// HeartbeatInterval for sending heartbeats
+const HeartbeatInterval = 10 * time.Second
