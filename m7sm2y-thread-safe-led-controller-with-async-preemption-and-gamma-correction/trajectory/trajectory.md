# Trajectory: Thread-Safe LED Controller with Async Preemption and Gamma Correction

### 1. Audit / Requirements Analysis (The actual problem)

The problem is state contention in asynchronous firmware control: long-running effects (e.g. a 5-second fade) and immediate overrides (e.g. SetColor) share the same hardware buffer. A naive “fire-and-forget” goroutine for the fade keeps running after the user sets a static color, overwriting the buffer and causing ghosting (lights flicker or revert). We need: (1) only the latest command to have write access to the shared buffer; (2) preemption so a new SetColor or FadeTo cancels any in-flight fade; (3) non-linear gamma so stored values match perceived brightness; (4) correct byte order (GRB for common LED strips) and full-strip updates. The buffer is 100 LEDs × 3 bytes (300 bytes), Green-Red-Blue per pixel. So the problem is designing a thread-safe controller that cancels running fades on new commands, applies gamma to every write, and exposes a single buffer in GRB order for testing and hardware output.

### 2. Question Assumptions (Challenge the Premise)

We could use a command channel and a single goroutine that processes SetColor and FadeTo sequentially—but then FadeTo would block the channel for the whole duration. The requirement is that FadeTo returns immediately and runs asynchronously, so we need a background goroutine per fade. That implies we need a way to stop the previous fade when a new command arrives: revocable context (context.WithCancel), a generation/epoch counter, or a dedicated cancel channel. Context cancel is idiomatic in Go and integrates with select in the fade loop. I assumed we must not block the caller: SetColor and FadeTo return immediately; the fade runs in a goroutine. I also assumed gamma is applied at write time (every SetColor and every fade step), not at read time—so the buffer always holds gamma-corrected values and CopyBuffer returns what would be sent to the strip.

### 3. Define Success Criteria (Establish Measurable Goals)

Success meant: (1) REQ-01: preemption—new SetColor or FadeTo cancels the previous fade (context/cancel); (2) REQ-02: gamma math output = (input*input)/255, with Gamma(0)==0 and Gamma(255)==255; (3) REQ-03: GRB byte order per pixel and full strip; (4) REQ-04: thread safety—mutex-protected buffer so concurrent SetColor/FadeTo do not cause torn reads; (5) REQ-05: no ghosting—after SetColor or a new FadeTo, the buffer must reflect only the latest command; (6) REQ-06: gamma applied in the buffer (e.g. SetColor(127,127,127) stores 63 per channel); (7) REQ-07: tests pass under -race; (8) REQ-08: all 100 LEDs updated. Fade must start from current buffer state (currentColor) so a SetColor then FadeTo fades from the set color to the target. I treated the test suite and evaluation report as the checklist.

### 4. Map Requirements to Validation (Define Test Strategy)

Each requirement maps to one or more tests. TestFadePreemptedBySetColor: FadeTo(Red) then SetColor(Blue); after a short wait, buffer must be strictly blue (REQ-01, REQ-04, REQ-05, REQ-07). TestFadePreemptedByFadeTo: FadeTo(Red) then FadeTo(Green); after the second fade completes, buffer must be green (REQ-01, REQ-05). TestFadeToFromSetColor: SetColor(red) then FadeTo(blue); final buffer blue (integration, currentColor, REQ-04). TestGammaVerification: Gamma(127)==63 (REQ-02). TestGammaEdgeCases: Gamma(0)==0, Gamma(255)==255, SetColor 0 and 255 produce correct buffer (REQ-02). TestGRBByteOrderExplicit: SetColor(0,255,0) → buf[0]=G, buf[1]=R, buf[2]=B (REQ-03). TestSetColorUpdatesAll: all 100 LEDs, GRB order, gamma applied (REQ-03, REQ-08). TestGammaAppliedToBuffer: SetColor(127,127,127) → buffer holds 63 (REQ-06). TestConcurrentSetColorAndFadeTo: concurrent goroutines calling SetColor/FadeTo; final SetColor(1,2,3) must be the only visible state (REQ-04, REQ-07). Evaluation runs go test -race against repository_after and writes report.json with pass/fail per requirement.

### 5. Scope the Solution

The solution lives in repository_after/led: one package with LEDController, Gamma, New, SetColor, FadeTo, CopyBuffer. Controller has a mutex, a 300-byte buffer (GRB), and a context.CancelFunc to stop the active fade. We do not touch repository_before (baseline placeholder). We do not add external dependencies; standard library only (sync, context, time). Gamma is a pure function in gamma.go; controller calls it on every R,G,B before writing. Fade runs in a goroutine with a ticker (e.g. 20ms steps), checks ctx.Done() each iteration, and calls writeAll(interpolated color). SetColor and FadeTo call cancelActive() first so only one fade runs at a time. Scope is limited to the LED controller and gamma; main.go is a thin demo.

### 6. Trace Data Flow (Follow the Path)

Call sequence: SetColor(r,g,b) → cancelActive() (cancel previous fade if any) → writeAll(Gamma(r), Gamma(g), Gamma(b)) under mutex: fill buffer in GRB order for all 100 LEDs. FadeTo(r,g,b,duration) → cancelActive() → under mutex read currentColor() (first pixel GRB from buffer), create context.WithCancel, store cancel in controller, release mutex → start goroutine: steps = duration/20ms, ticker every 20ms; each tick: select on ctx.Done() (exit if cancelled), else interpolate(start, target, i, steps) for R,G,B, call writeAll(ir,ig,ib). So every write (SetColor or fade step) goes through writeAll, which applies gamma and writes GRB to the full buffer under the mutex. CopyBuffer() locks, copies buffer, unlocks—safe for tests and race detector. When a new command arrives, cancelActive() calls the stored cancel(); the fade goroutine’s next select sees ctx.Done() and returns without writing again.

### 7. Anticipate Objections (Play Devil's Advocate)

“Why not a single worker goroutine that receives commands?” Then FadeTo would either block the channel for the whole duration (bad) or we’d still need a way to cancel the in-flight fade when a new command arrives, so we’d end up with a cancel or generation id anyway; the current design keeps the API simple and avoids an extra channel. “Why hold the mutex when reading currentColor?” We need a consistent snapshot of the buffer before starting the fade; without the lock, a concurrent write could tear. “Could the fade goroutine write after cancelActive()?” It only writes inside the ticker case after checking ctx.Err(); once cancel() runs, the next iteration sees Done() and returns, so we don’t write after cancel. “Why 20ms steps?” Fixed in the spec/trajectory for predictable timing; implementation uses a constant so tests can wait deterministically.

### 8. Verify Invariants (Define Constraints)

We must use only the standard library. The buffer is always 300 bytes, GRB order, gamma-applied. SetColor and FadeTo must not block. At most one fade goroutine is active; cancelActive() is called at the start of both SetColor and FadeTo. All buffer writes go through writeAll with the mutex held. CopyBuffer returns a copy so callers (and tests) never see a slice that could be mutated during read. Gamma(0)==0 and Gamma(255)==255 so black and white are exact. Interpolation is linear in component space (before gamma); gamma is applied per component in writeAll, so fade steps are gamma-corrected.

### 9. Execute with Surgical Precision (Ordered Implementation)

First gamma.go: Gamma(v) = (uint16(v)*uint16(v))/255. Then controller: struct with mu sync.Mutex, buffer [300]byte, cancel context.CancelFunc. New() allocates buffer. cancelActive(): lock, if cancel != nil call it and set nil, unlock. writeAll(r,g,b): apply Gamma to r,g,b, lock, write GRB to all 100 LEDs, unlock. currentColor(): assume called with lock held, return first pixel’s R,G,B (buffer indices 1,0,2 for R,G,B in GRB layout). SetColor: cancelActive(), writeAll(r,g,b). FadeTo: cancelActive(); lock, startR,startG,startB = currentColor(), ctx,cancel = WithCancel(Background()), store cancel, unlock; steps = duration/20ms (min 1); goroutine with ticker, for i 0..steps: select Done→return, tick→if ctx.Err()!=nil return, else writeAll(interpolate(startR,r,i,steps), …). interpolate(start,end,i,steps): linear uint8. CopyBuffer: lock, copy buffer to new slice, unlock, return. GRB order in writeAll: buffer[idx+0]=G, buffer[idx+1]=R, buffer[idx+2]=B. No external imports.

### 10. Measure Impact (Verify Completion)

Run the test suite from the project root (e.g. docker compose run --rm app go test -timeout 10s -v ./tests) and with race (go test -race -timeout 30s -v ./tests). All requirement-mapped tests must pass; TestFadePreemptedBySetColor, TestFadePreemptedByFadeTo, TestFadeToFromSetColor, TestGammaVerification, TestGammaEdgeCases, TestGRBByteOrderExplicit, TestSetColorUpdatesAll, TestGammaAppliedToBuffer, TestConcurrentSetColorAndFadeTo. Evaluation script (go run ./evaluation/evaluation.go) runs tests against repository_after with -race, produces report.json with requirement status (REQ-01 through REQ-08). Success means report success true and all requirements satisfied.

### 11. Document the Decision

We implemented a thread-safe LED controller in Go: 100 LEDs, 3 bytes per LED (GRB), single buffer protected by a mutex. SetColor and FadeTo return immediately; FadeTo runs a fade in a background goroutine with a context that is cancelled when a new SetColor or FadeTo runs, ensuring no ghosting. Gamma correction (output = input²/255) is applied on every write so the buffer always holds gamma-corrected values. GRB order and full-strip updates satisfy common LED strip drivers. CopyBuffer gives tests a snapshot without races. This matches the problem statement: revocable context for preemption, mutex for thread safety, gamma for perceptual linearity, and a single authoritative buffer.

### 12. Infrastructure and Tooling

- **go.work** at project root includes repository_after, tests, and evaluation so `go test ./tests` and `go run ./evaluation/evaluation.go` resolve modules from /app (Docker working_dir) without path issues on Windows/Git Bash or CI.
- **Docker**: Dockerfile uses golang:1.21-bullseye; docker-compose defines app service with working_dir /app, volume .:/app, REPO_PATH=/app/repository_after. Tests use replace directive in tests/go.mod so repository_after => /app/repository_after.
- **Evaluation** runs only against repository_after (repository_before is empty/baseline with success false in the report). evaluation.go runs go test -race -timeout 30s -json -v from the tests directory, consumes stdout with a scanner to avoid deadlock when the test process blocks on stdout, reads stderr in a goroutine, then builds report.json with run_id, environment, results, and requirement mapping (REQ-01..REQ-08 to specific tests).
- **TestMain** in tests records each test result (RecordResult) and prints a pytest-style summary; testResults and testFile are in util.go. Tests import repository_after/led and use led.New(), led.Gamma(), c.CopyBuffer(), etc.
- **.gitignore** covers Go build artifacts, IDE files, evaluation outputs. go.work is committed for the workspace.
