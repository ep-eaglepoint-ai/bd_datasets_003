diff --git a/repository_before/.gitkeep b/repository_before/.gitkeep
deleted file mode 100644
index e69de29..0000000
diff --git a/repository_after/go.mod b/repository_after/go.mod
new file mode 100644
index 0000000..1fd704d
--- /dev/null
+++ b/repository_after/go.mod
@@ -0,0 +1,3 @@
+module repository_after
+
+go 1.21
diff --git a/repository_after/led/controller.go b/repository_after/led/controller.go
new file mode 100644
index 0000000..5fd9aaf
--- /dev/null
+++ b/repository_after/led/controller.go
@@ -0,0 +1,129 @@
+package led
+
+import (
+	"context"
+	"sync"
+	"time"
+)
+
+const numLEDs = 100
+const bytesPerLED = 3
+const fadeStepInterval = 20 * time.Millisecond
+
+// LEDController manages a byte slice representing the color state (GRB order) of 100 addressable LEDs.
+// It is thread-safe and supports preemption of long-running fades by new commands.
+type LEDController struct {
+	mu         sync.Mutex
+	buffer     []byte // 100 LEDs Ã— 3 bytes, Green-Red-Blue order
+	cancel     context.CancelFunc
+	generation uint64 // incremented on cancel so stale fade goroutines skip their write
+}
+
+// New returns a new LEDController with a buffer for 100 LEDs (300 bytes) in GRB order.
+func New() *LEDController {
+	return &LEDController{
+		buffer: make([]byte, numLEDs*bytesPerLED),
+	}
+}
+
+// cancelActive stops any running fade goroutine and increments generation so stale fades skip their write.
+func (c *LEDController) cancelActive() {
+	c.mu.Lock()
+	if c.cancel != nil {
+		c.cancel()
+		c.cancel = nil
+	}
+	c.generation++
+	c.mu.Unlock()
+}
+
+// writeAll sets all LEDs to the given color with gamma correction and GRB order.
+// If gen > 0, writeAll only writes when c.generation == gen (fade path); otherwise it skips (stale fade).
+// If gen == 0, writeAll always writes (SetColor path). Caller must not hold c.mu; writeAll acquires it.
+func (c *LEDController) writeAll(gen uint64, r, g, b uint8) {
+	gr := Gamma(g)
+	rr := Gamma(r)
+	br := Gamma(b)
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	if gen != 0 && c.generation != gen {
+		return
+	}
+	for i := 0; i < numLEDs; i++ {
+		idx := i * bytesPerLED
+		c.buffer[idx+0] = gr // G
+		c.buffer[idx+1] = rr // R
+		c.buffer[idx+2] = br // B
+	}
+}
+
+// SetColor instantly sets all LEDs to the given color. It cancels any active fade and does not block.
+func (c *LEDController) SetColor(r, g, b uint8) {
+	c.cancelActive()
+	c.writeAll(0, r, g, b)
+}
+
+// currentColor returns the current color of the first pixel (GRB) for fade start. Call with c.mu held.
+func (c *LEDController) currentColor() (r, g, b uint8) {
+	if len(c.buffer) >= bytesPerLED {
+		g = c.buffer[0]
+		r = c.buffer[1]
+		b = c.buffer[2]
+	}
+	return r, g, b
+}
+
+// FadeTo smoothly transitions from the current color to (r, g, b) over duration.
+// It returns immediately; the transition runs asynchronously. Any previous fade is cancelled.
+func (c *LEDController) FadeTo(r, g, b uint8, duration time.Duration) {
+	c.cancelActive()
+
+	c.mu.Lock()
+	startR, startG, startB := c.currentColor()
+	ctx, cancel := context.WithCancel(context.Background())
+	c.cancel = cancel
+	gen := c.generation
+	c.mu.Unlock()
+
+	steps := int(duration / fadeStepInterval)
+	if steps < 1 {
+		steps = 1
+	}
+
+	go func() {
+		ticker := time.NewTicker(fadeStepInterval)
+		defer ticker.Stop()
+		for i := 0; i <= steps; i++ {
+			select {
+			case <-ctx.Done():
+				return
+			case <-ticker.C:
+				if ctx.Err() != nil {
+					return
+				}
+				ir := interpolate(startR, r, i, steps)
+				ig := interpolate(startG, g, i, steps)
+				ib := interpolate(startB, b, i, steps)
+				c.writeAll(gen, ir, ig, ib)
+			}
+		}
+	}()
+}
+
+func interpolate(start, end uint8, i, steps int) uint8 {
+	if steps <= 0 {
+		return end
+	}
+	s := int(start)
+	e := int(end)
+	return uint8(s + (e-s)*i/steps)
+}
+
+// CopyBuffer returns a copy of the internal buffer for testing. Safe to call from tests under race detector.
+func (c *LEDController) CopyBuffer() []byte {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	out := make([]byte, len(c.buffer))
+	copy(out, c.buffer)
+	return out
+}
diff --git a/repository_after/led/gamma.go b/repository_after/led/gamma.go
new file mode 100644
index 0000000..03dc65c
--- /dev/null
+++ b/repository_after/led/gamma.go
@@ -0,0 +1,7 @@
+package led
+
+// Gamma applies gamma correction: output = (input * input) / 255.
+// LED brightness is non-linear to the human eye; squaring approximates perceptually linear output.
+func Gamma(v uint8) uint8 {
+	return uint8((uint16(v) * uint16(v)) / 255)
+}
diff --git a/repository_after/main.go b/repository_after/main.go
new file mode 100644
index 0000000..ac8fa55
--- /dev/null
+++ b/repository_after/main.go
@@ -0,0 +1,21 @@
+package main
+
+import (
+	"fmt"
+	"repository_after/led"
+	"time"
+)
+
+func main() {
+	c := led.New()
+	fmt.Println("=== LED Strip Controller Demo ===")
+
+	c.SetColor(0, 255, 0) // Green
+	fmt.Println("SetColor(Green)")
+
+	c.FadeTo(255, 0, 0, 2*time.Second) // Fade to Red over 2s
+	fmt.Println("FadeTo(Red, 2s) - returning immediately")
+
+	time.Sleep(3 * time.Second)
+	fmt.Println("Done.")
+}
