diff --git a/repository_before/.gitkeep b/repository_before/.gitkeep
deleted file mode 100644
index e69de29..0000000
diff --git a/repository_after/irrigation_control/celery.py b/repository_after/irrigation_control/celery.py
new file mode 100644
index 0000000..9cab7ec
--- /dev/null
+++ b/repository_after/irrigation_control/celery.py
@@ -0,0 +1,19 @@
+"""
+Celery configuration for irrigation_control project.
+"""
+import os
+from celery import Celery
+
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'irrigation_control.settings')
+
+app = Celery('irrigation_control')
+
+app.config_from_object('django.conf:settings', namespace='CELERY')
+
+app.autodiscover_tasks()
+
+
+@app.task(bind=True, ignore_result=True)
+def debug_task(self):
+    """Debug task for testing Celery setup."""
+    print(f'Request: {self.request!r}')
\ No newline at end of file
diff --git a/repository_after/irrigation_control/init.py b/repository_after/irrigation_control/init.py
new file mode 100644
index 0000000..4553cb5
--- /dev/null
+++ b/repository_after/irrigation_control/init.py
@@ -0,0 +1,4 @@
+"""Irrigation Control Django project."""
+from .celery import app as celery_app
+
+__all__ = ('celery_app',)
\ No newline at end of file
diff --git a/repository_after/irrigation_control/settings.py b/repository_after/irrigation_control/settings.py
new file mode 100644
index 0000000..c9a9b27
--- /dev/null
+++ b/repository_after/irrigation_control/settings.py
@@ -0,0 +1,117 @@
+"""
+Django settings for irrigation_control project.
+Uses PostgreSQL as the database backend.
+"""
+import os
+from pathlib import Path
+
+BASE_DIR = Path(__file__).resolve().parent.parent
+
+SECRET_KEY = os.environ.get('DJANGO_SECRET_KEY', 'dev-secret-key-change-in-production')
+
+DEBUG = os.environ.get('DEBUG', 'True').lower() == 'true'
+
+ALLOWED_HOSTS = ['*']
+
+INSTALLED_APPS = [
+    'django.contrib.admin',
+    'django.contrib.auth',
+    'django.contrib.contenttypes',
+    'django.contrib.sessions',
+    'django.contrib.messages',
+    'django.contrib.staticfiles',
+    'sensors',
+]
+
+MIDDLEWARE = [
+    'django.middleware.security.SecurityMiddleware',
+    'django.contrib.sessions.middleware.SessionMiddleware',
+    'django.middleware.common.CommonMiddleware',
+    'django.middleware.csrf.CsrfViewMiddleware',
+    'django.contrib.auth.middleware.AuthenticationMiddleware',
+    'django.contrib.messages.middleware.MessageMiddleware',
+    'django.middleware.clickjacking.XFrameOptionsMiddleware',
+]
+
+ROOT_URLCONF = 'irrigation_control.urls'
+
+TEMPLATES = [
+    {
+        'BACKEND': 'django.template.backends.django.DjangoTemplates',
+        'DIRS': [],
+        'APP_DIRS': True,
+        'OPTIONS': {
+            'context_processors': [
+                'django.template.context_processors.debug',
+                'django.template.context_processors.request',
+                'django.contrib.auth.context_processors.auth',
+                'django.contrib.messages.context_processors.messages',
+            ],
+        },
+    },
+]
+
+WSGI_APPLICATION = 'irrigation_control.wsgi.application'
+
+# PostgreSQL Database Configuration
+DATABASE_URL = os.environ.get('DATABASE_URL', 'postgres://irrigation_user:irrigation_pass@localhost:5432/irrigation_db')
+
+# Parse DATABASE_URL
+import re
+db_match = re.match(r'postgres://(.+):(.+)@(.+):(\d+)/(.+)', DATABASE_URL)
+if db_match:
+    DATABASES = {
+        'default': {
+            'ENGINE': 'django.db.backends.postgresql',
+            'NAME': db_match.group(5),
+            'USER': db_match.group(1),
+            'PASSWORD': db_match.group(2),
+            'HOST': db_match.group(3),
+            'PORT': db_match.group(4),
+            'ATOMIC_REQUESTS': False,
+        }
+    }
+else:
+    # Fallback for testing
+    DATABASES = {
+        'default': {
+            'ENGINE': 'django.db.backends.postgresql',
+            'NAME': 'irrigation_db',
+            'USER': 'irrigation_user',
+            'PASSWORD': 'irrigation_pass',
+            'HOST': 'db',
+            'PORT': '5432',
+        }
+    }
+
+AUTH_PASSWORD_VALIDATORS = [
+    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
+    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
+    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
+    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
+]
+
+LANGUAGE_CODE = 'en-us'
+TIME_ZONE = 'UTC'
+USE_I18N = True
+USE_TZ = True
+
+STATIC_URL = 'static/'
+
+DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
+
+# Celery Configuration
+CELERY_BROKER_URL = os.environ.get('CELERY_BROKER_URL', 'redis://redis:6379/0')
+CELERY_RESULT_BACKEND = 'redis://redis:6379/0'
+CELERY_ACCEPT_CONTENT = ['json']
+CELERY_TASK_SERIALIZER = 'json'
+CELERY_RESULT_SERIALIZER = 'json'
+CELERY_TIMEZONE = 'UTC'
+CELERY_TASK_TRACK_STARTED = True
+CELERY_TASK_ALWAYS_EAGER = os.environ.get('CELERY_TASK_ALWAYS_EAGER', 'true').lower() == 'true'
+CELERY_TASK_EAGER_PROPAGATES = True
+
+# Irrigation Control Configuration
+PUMP_MAX_RUNTIME_SECONDS = 30
+PUMP_COOLDOWN_MINUTES = 15
+MOISTURE_THRESHOLD = 10.0
\ No newline at end of file
diff --git a/repository_after/irrigation_control/urls.py b/repository_after/irrigation_control/urls.py
new file mode 100644
index 0000000..da88118
--- /dev/null
+++ b/repository_after/irrigation_control/urls.py
@@ -0,0 +1,8 @@
+"""URL configuration for irrigation_control project."""
+from django.contrib import admin
+from django.urls import path, include
+
+urlpatterns = [
+    path('admin/', admin.site.urls),
+    path('api/', include('sensors.urls')),
+]
\ No newline at end of file
diff --git a/repository_after/irrigation_control/wsgi.py b/repository_after/irrigation_control/wsgi.py
new file mode 100644
index 0000000..e6a93cf
--- /dev/null
+++ b/repository_after/irrigation_control/wsgi.py
@@ -0,0 +1,7 @@
+"""WSGI config for irrigation_control project."""
+import os
+from django.core.wsgi import get_wsgi_application
+
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'irrigation_control.settings')
+
+application = get_wsgi_application()
\ No newline at end of file
diff --git a/repository_after/manage.py b/repository_after/manage.py
new file mode 100644
index 0000000..aa7e118
--- /dev/null
+++ b/repository_after/manage.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python
+"""Django's command-line utility for administrative tasks."""
+import os
+import sys
+
+
+def main():
+    """Run administrative tasks."""
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'irrigation_control.settings')
+    try:
+        from django.core.management import execute_from_command_line
+    except ImportError as exc:
+        raise ImportError(
+            "Couldn't import Django. Are you sure it's installed and "
+            "available on your PYTHONPATH environment variable? Did you "
+            "forget to activate a virtual environment?"
+        ) from exc
+    execute_from_command_line(sys.argv)
+
+
+if __name__ == '__main__':
+    main()
\ No newline at end of file
diff --git a/repository_after/sensors/admin.py b/repository_after/sensors/admin.py
new file mode 100644
index 0000000..8f0485e
--- /dev/null
+++ b/repository_after/sensors/admin.py
@@ -0,0 +1,37 @@
+"""Admin configuration for sensors app."""
+from django.contrib import admin
+from .models import Zone, Pump, Sensor, SensorReading, PumpActivationLog
+
+
+@admin.register(Zone)
+class ZoneAdmin(admin.ModelAdmin):
+    list_display = ('name', 'is_active', 'created_at')
+    search_fields = ('name',)
+
+
+@admin.register(Pump)
+class PumpAdmin(admin.ModelAdmin):
+    list_display = ('hardware_id', 'zone', 'status', 'last_activation_time', 'total_activations')
+    list_filter = ('status',)
+    search_fields = ('hardware_id', 'zone__name')
+
+
+@admin.register(Sensor)
+class SensorAdmin(admin.ModelAdmin):
+    list_display = ('hardware_id', 'zone', 'is_active', 'created_at')
+    list_filter = ('is_active', 'zone')
+    search_fields = ('hardware_id',)
+
+
+@admin.register(SensorReading)
+class SensorReadingAdmin(admin.ModelAdmin):
+    list_display = ('sensor', 'zone', 'moisture_percentage', 'timestamp')
+    list_filter = ('zone', 'is_valid')
+    date_hierarchy = 'timestamp'
+
+
+@admin.register(PumpActivationLog)
+class PumpActivationLogAdmin(admin.ModelAdmin):
+    list_display = ('pump', 'started_at', 'ended_at', 'duration_seconds', 'was_successful')
+    list_filter = ('was_successful', 'pump')
+    date_hierarchy = 'started_at'
\ No newline at end of file
diff --git a/repository_after/sensors/apps.py b/repository_after/sensors/apps.py
new file mode 100644
index 0000000..7d2f220
--- /dev/null
+++ b/repository_after/sensors/apps.py
@@ -0,0 +1,8 @@
+"""Sensors app configuration."""
+from django.apps import AppConfig
+
+
+class SensorsConfig(AppConfig):
+    """Configuration for the sensors application."""
+    default_auto_field = 'django.db.models.BigAutoField'
+    name = 'sensors'
\ No newline at end of file
diff --git a/repository_after/sensors/init.py b/repository_after/sensors/init.py
new file mode 100644
index 0000000..507eed6
--- /dev/null
+++ b/repository_after/sensors/init.py
@@ -0,0 +1 @@
+"""Sensors Django app."""
\ No newline at end of file
diff --git a/repository_after/sensors/models.py b/repository_after/sensors/models.py
new file mode 100644
index 0000000..61b9b18
--- /dev/null
+++ b/repository_after/sensors/models.py
@@ -0,0 +1,190 @@
+"""
+Models for IoT Irrigation Control System.
+
+This module defines the database models for sensors, pumps, zones, and readings.
+Implements proper indexing for high-performance SQL aggregation queries.
+Uses PostgreSQL as the database backend.
+"""
+from django.db import models
+from django.utils import timezone
+
+
+class Zone(models.Model):
+    """
+    Represents a physical irrigation zone in the urban farm.
+    Each zone contains multiple sensors and one pump.
+    """
+    name = models.CharField(max_length=100, unique=True)
+    description = models.TextField(blank=True)
+    created_at = models.DateTimeField(default=timezone.now)
+    is_active = models.BooleanField(default=True)
+
+    class Meta:
+        db_table = 'zones'
+        ordering = ['name']
+
+    def __str__(self):
+        return self.name
+
+
+class Pump(models.Model):
+    """
+    Represents a water pump associated with a zone.
+    
+    Implements hardware safety constraints:
+    - Maximum runtime: 30 seconds
+    - Cooldown period: 15 minutes between activations
+    """
+    class Status(models.TextChoices):
+        IDLE = 'IDLE', 'Idle'
+        RUNNING = 'RUNNING', 'Running'
+        COOLDOWN = 'COOLDOWN', 'Cooldown'
+        ERROR = 'ERROR', 'Error'
+
+    zone = models.OneToOneField(
+        Zone,
+        on_delete=models.CASCADE,
+        related_name='pump'
+    )
+    hardware_id = models.CharField(max_length=100, unique=True)
+    status = models.CharField(
+        max_length=20,
+        choices=Status.choices,
+        default=Status.IDLE
+    )
+    last_activation_time = models.DateTimeField(null=True, blank=True)
+    last_deactivation_time = models.DateTimeField(null=True, blank=True)
+    total_activations = models.PositiveIntegerField(default=0)
+    created_at = models.DateTimeField(default=timezone.now)
+    updated_at = models.DateTimeField(auto_now=True)
+
+    class Meta:
+        db_table = 'pumps'
+        ordering = ['zone__name']
+
+    def __str__(self):
+        return f"Pump {self.hardware_id} ({self.zone.name})"
+
+    def is_in_cooldown(self, cooldown_minutes: int = 15) -> bool:
+        """
+        Check if the pump is currently in cooldown period.
+        
+        Args:
+            cooldown_minutes: Minimum time between activations in minutes.
+            
+        Returns:
+            True if pump is in cooldown, False otherwise.
+        """
+        if self.last_activation_time is None:
+            return False
+        
+        time_since_activation = timezone.now() - self.last_activation_time
+        cooldown_seconds = cooldown_minutes * 60
+        return time_since_activation.total_seconds() < cooldown_seconds
+
+    def can_activate(self, cooldown_minutes: int = 15) -> bool:
+        """
+        Determine if the pump can be activated.
+        
+        Args:
+            cooldown_minutes: Minimum time between activations in minutes.
+            
+        Returns:
+            True if pump can be activated, False otherwise.
+        """
+        if self.status == self.Status.RUNNING:
+            return False
+        if self.status == self.Status.ERROR:
+            return False
+        return not self.is_in_cooldown(cooldown_minutes)
+
+
+class Sensor(models.Model):
+    """
+    Represents an IoT moisture sensor in a zone.
+    """
+    zone = models.ForeignKey(
+        Zone,
+        on_delete=models.CASCADE,
+        related_name='sensors'
+    )
+    hardware_id = models.CharField(max_length=100, unique=True)
+    location_description = models.CharField(max_length=255, blank=True)
+    is_active = models.BooleanField(default=True)
+    created_at = models.DateTimeField(default=timezone.now)
+
+    class Meta:
+        db_table = 'sensors'
+        ordering = ['zone__name', 'hardware_id']
+
+    def __str__(self):
+        return f"Sensor {self.hardware_id} ({self.zone.name})"
+
+
+class SensorReading(models.Model):
+    """
+    Represents a moisture reading from an IoT sensor.
+    
+    IMPORTANT: This table can contain millions of rows. 
+    Proper indexing on (zone, timestamp) is critical for aggregation queries.
+    Uses PostgreSQL-specific index features.
+    """
+    sensor = models.ForeignKey(
+        Sensor,
+        on_delete=models.CASCADE,
+        related_name='readings'
+    )
+    zone = models.ForeignKey(
+        Zone,
+        on_delete=models.CASCADE,
+        related_name='readings'
+    )
+    moisture_percentage = models.FloatField()
+    temperature_celsius = models.FloatField(null=True, blank=True)
+    timestamp = models.DateTimeField(default=timezone.now)
+    is_valid = models.BooleanField(default=True)
+
+    class Meta:
+        db_table = 'sensor_readings'
+        ordering = ['-timestamp']
+        # REQUIREMENT 7: Database indexes for performant aggregation queries
+        indexes = [
+            models.Index(fields=['zone', 'timestamp'], name='idx_zone_timestamp'),
+            models.Index(fields=['timestamp'], name='idx_timestamp'),
+            models.Index(fields=['zone', '-timestamp'], name='idx_zone_timestamp_desc'),
+            models.Index(fields=['sensor', 'timestamp'], name='idx_sensor_timestamp'),
+        ]
+
+    def __str__(self):
+        return f"Reading {self.moisture_percentage}% at {self.timestamp}"
+
+
+class PumpActivationLog(models.Model):
+    """
+    Audit log for pump activations.
+    Tracks each activation with start/end times and triggering data.
+    """
+    pump = models.ForeignKey(
+        Pump,
+        on_delete=models.CASCADE,
+        related_name='activation_logs'
+    )
+    triggered_by_reading = models.ForeignKey(
+        SensorReading,
+        on_delete=models.SET_NULL,
+        null=True,
+        blank=True
+    )
+    started_at = models.DateTimeField()
+    ended_at = models.DateTimeField(null=True, blank=True)
+    duration_seconds = models.FloatField(null=True, blank=True)
+    was_successful = models.BooleanField(default=True)
+    error_message = models.TextField(blank=True)
+    celery_task_id = models.CharField(max_length=255, blank=True)
+
+    class Meta:
+        db_table = 'pump_activation_logs'
+        ordering = ['-started_at']
+
+    def __str__(self):
+        return f"Activation of {self.pump} at {self.started_at}"
\ No newline at end of file
diff --git a/repository_after/sensors/tasks.py b/repository_after/sensors/tasks.py
new file mode 100644
index 0000000..fff8c9f
--- /dev/null
+++ b/repository_after/sensors/tasks.py
@@ -0,0 +1,231 @@
+"""
+Celery tasks for IoT Irrigation Control System.
+
+REQUIREMENT 5: Heavy I/O operations (hardware API calls) are offloaded 
+to background Celery workers, not blocking HTTP requests.
+"""
+import time
+import logging
+from typing import Optional
+from celery import shared_task
+from django.conf import settings
+from django.db import transaction
+from django.utils import timezone
+
+logger = logging.getLogger(__name__)
+
+
+class HardwareGateway:
+    """
+    Simulated hardware gateway for pump control.
+    In production, this would communicate with actual hardware.
+    """
+    
+    @staticmethod
+    def activate_pump(hardware_id: str, duration_seconds: int) -> dict:
+        """
+        Simulate activating a pump for a specified duration.
+        
+        Args:
+            hardware_id: The pump's hardware identifier.
+            duration_seconds: How long to run the pump.
+            
+        Returns:
+            dict with activation result.
+        """
+        logger.info(f"[HW Gateway] Activating pump {hardware_id} for {duration_seconds}s")
+        
+        # Simulate hardware communication delay
+        time.sleep(0.1)
+        
+        logger.info(f"[HW Gateway] Pump {hardware_id} completed {duration_seconds}s cycle")
+        
+        return {
+            'success': True,
+            'hardware_id': hardware_id,
+            'actual_duration': duration_seconds,
+            'timestamp': timezone.now().isoformat()
+        }
+    
+    @staticmethod
+    def deactivate_pump(hardware_id: str) -> dict:
+        """
+        Force deactivate a pump.
+        
+        Args:
+            hardware_id: The pump's hardware identifier.
+            
+        Returns:
+            dict with deactivation result.
+        """
+        logger.info(f"[HW Gateway] Deactivating pump {hardware_id}")
+        time.sleep(0.05)
+        
+        return {
+            'success': True,
+            'hardware_id': hardware_id,
+            'timestamp': timezone.now().isoformat()
+        }
+
+
+@shared_task(bind=True, max_retries=3, default_retry_delay=60)
+def activate_pump_task(
+    self,
+    pump_id: int,
+    triggering_reading_id: Optional[int] = None,
+    duration_seconds: Optional[int] = None
+) -> dict:
+    """
+    Celery task to activate a pump for irrigation.
+    
+    REQUIREMENT 3: Pump run duration is capped to max runtime (30s default).
+    REQUIREMENT 5: Hardware API calls happen inside Celery task.
+    
+    Args:
+        pump_id: ID of the pump to activate.
+        triggering_reading_id: ID of the sensor reading that triggered this.
+        duration_seconds: Optional custom duration (capped to max).
+        
+    Returns:
+        dict with task result.
+    """
+    from sensors.models import Pump, PumpActivationLog, SensorReading
+    
+    max_runtime = getattr(settings, 'PUMP_MAX_RUNTIME_SECONDS', 30)
+    
+    if duration_seconds is None:
+        duration_seconds = max_runtime
+    else:
+        # REQUIREMENT 3: Cap duration to max runtime
+        duration_seconds = min(duration_seconds, max_runtime)
+    
+    logger.info(f"[Task] Starting pump activation task for pump_id={pump_id}")
+    
+    try:
+        with transaction.atomic():
+            # Lock the pump row to prevent concurrent modifications
+            pump = Pump.objects.select_for_update().get(id=pump_id)
+            
+            # Check if pump is already running - if so, skip this task
+            # This handles the case where the task is called directly or race condition
+            if pump.status == Pump.Status.RUNNING:
+                # Check if this is a new request (pump was already running before we got here)
+                # vs. we set it to running in the view
+                if pump.last_activation_time:
+                    time_since_activation = (timezone.now() - pump.last_activation_time).total_seconds()
+                    # If activated more than 2 seconds ago, it's likely already being handled
+                    if time_since_activation > 2:
+                        logger.warning(f"[Task] Pump {pump_id} is already running, aborting")
+                        return {'success': False, 'reason': 'pump_already_running'}
+            
+            # Create activation log
+            triggering_reading = None
+            if triggering_reading_id:
+                triggering_reading = SensorReading.objects.filter(
+                    id=triggering_reading_id
+                ).first()
+            
+            activation_log = PumpActivationLog.objects.create(
+                pump=pump,
+                triggered_by_reading=triggering_reading,
+                started_at=timezone.now(),
+                celery_task_id=str(self.request.id) if self.request.id else ''
+            )
+            
+            # Update pump status to RUNNING if not already
+            if pump.status != Pump.Status.RUNNING:
+                pump.status = Pump.Status.RUNNING
+                pump.last_activation_time = timezone.now()
+                pump.save(update_fields=['status', 'last_activation_time', 'updated_at'])
+        
+        # REQUIREMENT 5: Hardware API call (outside transaction, can take time)
+        gateway = HardwareGateway()
+        result = gateway.activate_pump(pump.hardware_id, duration_seconds)
+        
+        # Update records after hardware operation completes
+        with transaction.atomic():
+            pump = Pump.objects.select_for_update().get(id=pump_id)
+            end_time = timezone.now()
+            
+            pump.status = Pump.Status.IDLE
+            pump.last_deactivation_time = end_time
+            pump.total_activations += 1
+            pump.save(update_fields=[
+                'status', 'last_deactivation_time', 
+                'total_activations', 'updated_at'
+            ])
+            
+            activation_log.ended_at = end_time
+            activation_log.duration_seconds = (
+                end_time - activation_log.started_at
+            ).total_seconds()
+            activation_log.was_successful = result.get('success', False)
+            activation_log.save()
+        
+        logger.info(f"[Task] Pump activation completed for pump_id={pump_id}")
+        
+        return {
+            'success': True,
+            'pump_id': pump_id,
+            'duration': duration_seconds,
+            'activation_log_id': activation_log.id
+        }
+        
+    except Pump.DoesNotExist:
+        logger.error(f"[Task] Pump {pump_id} not found")
+        return {'success': False, 'reason': 'pump_not_found'}
+    
+    except Exception as exc:
+        logger.exception(f"[Task] Error activating pump {pump_id}: {exc}")
+        
+        # Try to reset pump status on error
+        try:
+            with transaction.atomic():
+                pump = Pump.objects.select_for_update().get(id=pump_id)
+                pump.status = Pump.Status.ERROR
+                pump.save(update_fields=['status', 'updated_at'])
+        except Exception:
+            pass
+        
+        raise
+
+
+@shared_task(bind=True)
+def stop_pump_task(self, pump_id: int) -> dict:
+    """
+    Force stop a running pump.
+    
+    Args:
+        pump_id: ID of the pump to stop.
+        
+    Returns:
+        dict with task result.
+    """
+    from sensors.models import Pump
+    
+    logger.info(f"[Task] Force stopping pump_id={pump_id}")
+    
+    try:
+        with transaction.atomic():
+            pump = Pump.objects.select_for_update().get(id=pump_id)
+            
+            if pump.status != Pump.Status.RUNNING:
+                return {'success': True, 'reason': 'pump_not_running'}
+            
+            # Call hardware to stop
+            gateway = HardwareGateway()
+            gateway.deactivate_pump(pump.hardware_id)
+            
+            pump.status = Pump.Status.IDLE
+            pump.last_deactivation_time = timezone.now()
+            pump.save(update_fields=[
+                'status', 'last_deactivation_time', 'updated_at'
+            ])
+        
+        return {'success': True, 'pump_id': pump_id}
+        
+    except Pump.DoesNotExist:
+        return {'success': False, 'reason': 'pump_not_found'}
+    except Exception as exc:
+        logger.exception(f"[Task] Error stopping pump {pump_id}: {exc}")
+        return {'success': False, 'reason': str(exc)}
\ No newline at end of file
diff --git a/repository_after/sensors/urls.py b/repository_after/sensors/urls.py
new file mode 100644
index 0000000..3486209
--- /dev/null
+++ b/repository_after/sensors/urls.py
@@ -0,0 +1,17 @@
+"""URL configuration for sensors app."""
+from django.urls import path
+from .views import (
+    SensorDataIngestionView,
+    ZoneHourlyAverageView,
+    PumpStatusView,
+    ManualPumpActivationView,
+    HealthCheckView,
+)
+
+urlpatterns = [
+    path('health/', HealthCheckView.as_view(), name='health-check'),
+    path('sensors/ingest/', SensorDataIngestionView.as_view(), name='sensor-ingest'),
+    path('zones/<int:zone_id>/hourly-average/', ZoneHourlyAverageView.as_view(), name='zone-hourly-average'),
+    path('pumps/<int:pump_id>/status/', PumpStatusView.as_view(), name='pump-status'),
+    path('pumps/<int:pump_id>/activate/', ManualPumpActivationView.as_view(), name='pump-activate'),
+]
\ No newline at end of file
diff --git a/repository_after/sensors/views.py b/repository_after/sensors/views.py
new file mode 100644
index 0000000..2d6eb06
--- /dev/null
+++ b/repository_after/sensors/views.py
@@ -0,0 +1,426 @@
+"""
+Views for IoT Irrigation Control System.
+
+Implements:
+- Sensor data ingestion endpoint
+- Pump activation logic with pessimistic locking
+- High-performance aggregation reporting using PostgreSQL
+"""
+import json
+import logging
+from datetime import timedelta
+from typing import Any, Dict
+
+from django.conf import settings
+from django.db import transaction
+from django.db.models import Avg
+from django.db.models.functions import TruncHour
+from django.http import JsonResponse
+from django.utils import timezone
+from django.utils.decorators import method_decorator
+from django.views import View
+from django.views.decorators.csrf import csrf_exempt
+
+from .models import Pump, Sensor, SensorReading, Zone
+from .tasks import activate_pump_task
+
+logger = logging.getLogger(__name__)
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class SensorDataIngestionView(View):
+    """
+    API endpoint for ingesting sensor telemetry data.
+    
+    POST /api/sensors/ingest/
+    
+    REQUIREMENTS IMPLEMENTED:
+    1. Uses transaction.atomic() and select_for_update() for locking
+    2. Checks last_activation_time for 15-minute cooldown
+    5. Hardware API calls happen in Celery task
+    6. Concurrent requests result in exactly one task during cooldown
+    8. Pump status update and task scheduling in same transaction
+    9. Uses django.utils.timezone.now() for UTC timestamps
+    """
+    
+    def post(self, request, *args, **kwargs) -> JsonResponse:
+        """
+        Handle incoming sensor data.
+        
+        Expected JSON payload:
+        {
+            "sensor_id": "sensor_hardware_id",
+            "moisture_percentage": 8.5,
+            "temperature_celsius": 22.3  // optional
+        }
+        """
+        try:
+            data = json.loads(request.body)
+        except json.JSONDecodeError:
+            return JsonResponse(
+                {'error': 'Invalid JSON payload'},
+                status=400
+            )
+        
+        sensor_hardware_id = data.get('sensor_id')
+        moisture = data.get('moisture_percentage')
+        temperature = data.get('temperature_celsius')
+        
+        if not sensor_hardware_id or moisture is None:
+            return JsonResponse(
+                {'error': 'Missing required fields: sensor_id, moisture_percentage'},
+                status=400
+            )
+        
+        try:
+            moisture = float(moisture)
+        except (TypeError, ValueError):
+            return JsonResponse(
+                {'error': 'moisture_percentage must be a number'},
+                status=400
+            )
+        
+        # Get sensor and zone
+        try:
+            sensor = Sensor.objects.select_related('zone').get(
+                hardware_id=sensor_hardware_id,
+                is_active=True
+            )
+        except Sensor.DoesNotExist:
+            return JsonResponse(
+                {'error': f'Sensor {sensor_hardware_id} not found or inactive'},
+                status=404
+            )
+        
+        # REQUIREMENT 9: Use timezone.now() for UTC timestamps
+        current_time = timezone.now()
+        
+        # Create the sensor reading
+        reading = SensorReading.objects.create(
+            sensor=sensor,
+            zone=sensor.zone,
+            moisture_percentage=moisture,
+            temperature_celsius=temperature,
+            timestamp=current_time
+        )
+        
+        response_data: Dict[str, Any] = {
+            'status': 'recorded',
+            'reading_id': reading.id,
+            'timestamp': current_time.isoformat()
+        }
+        
+        # Check if moisture is below threshold
+        threshold = getattr(settings, 'MOISTURE_THRESHOLD', 10.0)
+        
+        if moisture < threshold:
+            logger.info(
+                f"Low moisture detected: {moisture}% (threshold: {threshold}%) "
+                f"from sensor {sensor_hardware_id}"
+            )
+            
+            # Attempt to activate pump with pessimistic locking
+            activation_result = self._try_activate_pump(
+                zone=sensor.zone,
+                reading=reading
+            )
+            response_data['pump_activation'] = activation_result
+        
+        return JsonResponse(response_data, status=201)
+    
+    def _try_activate_pump(
+        self,
+        zone: Zone,
+        reading: SensorReading
+    ) -> Dict[str, Any]:
+        """
+        Attempt to activate the pump for the given zone.
+        
+        Uses pessimistic locking to prevent race conditions from
+        concurrent sensor reports (thundering herd problem).
+        
+        REQUIREMENT 1: Uses transaction.atomic() and select_for_update()
+        REQUIREMENT 2: Checks last_activation_time for cooldown
+        REQUIREMENT 6: Only one task queued during cooldown window
+        REQUIREMENT 8: Status update and task scheduling in same transaction
+        """
+        cooldown_minutes = getattr(settings, 'PUMP_COOLDOWN_MINUTES', 15)
+        max_runtime = getattr(settings, 'PUMP_MAX_RUNTIME_SECONDS', 30)
+        
+        try:
+            # REQUIREMENT 1: Pessimistic locking with transaction.atomic()
+            with transaction.atomic():
+                # REQUIREMENT 1: select_for_update() acquires row lock
+                # This blocks other concurrent requests from reading the pump
+                # until this transaction completes
+                # PostgreSQL will block other transactions trying to lock this row
+                try:
+                    pump = Pump.objects.select_for_update(nowait=False).get(
+                        zone=zone
+                    )
+                except Pump.DoesNotExist:
+                    logger.warning(f"No pump configured for zone {zone.name}")
+                    return {
+                        'status': 'error',
+                        'reason': 'no_pump_configured'
+                    }
+                
+                # REQUIREMENT 2: Check cooldown period
+                if pump.is_in_cooldown(cooldown_minutes):
+                    time_remaining = None
+                    if pump.last_activation_time:
+                        elapsed = timezone.now() - pump.last_activation_time
+                        remaining_seconds = (cooldown_minutes * 60) - elapsed.total_seconds()
+                        time_remaining = max(0, int(remaining_seconds))
+                    
+                    logger.info(
+                        f"Pump {pump.hardware_id} in cooldown, "
+                        f"{time_remaining}s remaining"
+                    )
+                    return {
+                        'status': 'cooldown',
+                        'reason': 'pump_in_cooldown_period',
+                        'cooldown_remaining_seconds': time_remaining
+                    }
+                
+                # Check if pump is already running
+                if pump.status == Pump.Status.RUNNING:
+                    logger.info(f"Pump {pump.hardware_id} already running")
+                    return {
+                        'status': 'already_running',
+                        'reason': 'pump_currently_active'
+                    }
+                
+                # Check if pump is in error state
+                if pump.status == Pump.Status.ERROR:
+                    logger.warning(f"Pump {pump.hardware_id} is in error state")
+                    return {
+                        'status': 'error',
+                        'reason': 'pump_in_error_state'
+                    }
+                
+                # REQUIREMENT 8: Update pump status within the same transaction
+                # This ensures the task is only scheduled if the status update succeeds
+                pump.status = Pump.Status.RUNNING
+                pump.last_activation_time = timezone.now()
+                pump.save(update_fields=['status', 'last_activation_time', 'updated_at'])
+                
+                # REQUIREMENT 5 & 8: Queue Celery task within the transaction
+                # The task will be sent when the transaction commits
+                task = activate_pump_task.delay(
+                    pump_id=pump.id,
+                    triggering_reading_id=reading.id,
+                    duration_seconds=max_runtime
+                )
+                
+                logger.info(
+                    f"Pump activation task queued: {task.id} "
+                    f"for pump {pump.hardware_id}"
+                )
+                
+                return {
+                    'status': 'activated',
+                    'task_id': str(task.id) if task.id else 'eager-mode',
+                    'pump_id': pump.id,
+                    'duration_seconds': max_runtime
+                }
+        
+        except Exception as exc:
+            logger.exception(f"Error activating pump for zone {zone.name}: {exc}")
+            return {
+                'status': 'error',
+                'reason': str(exc)
+            }
+
+
+class ZoneHourlyAverageView(View):
+    """
+    API endpoint for retrieving average hourly moisture for a zone.
+    
+    GET /api/zones/<zone_id>/hourly-average/
+    
+    REQUIREMENT 4: Uses Django ORM aggregation (TruncHour, Avg)
+    to perform calculation entirely within the database engine (PostgreSQL).
+    NO Python loops for data processing.
+    
+    REQUIREMENT 7: Relies on database index (zone, timestamp) for performance.
+    """
+    
+    def get(self, request, zone_id: int, *args, **kwargs) -> JsonResponse:
+        """
+        Get average hourly moisture for the last 7 days.
+        
+        The query uses TruncHour and Avg aggregation functions,
+        performing all calculations in PostgreSQL.
+        """
+        try:
+            zone = Zone.objects.get(id=zone_id)
+        except Zone.DoesNotExist:
+            return JsonResponse(
+                {'error': f'Zone {zone_id} not found'},
+                status=404
+            )
+        
+        # REQUIREMENT 9: Use timezone.now() for UTC
+        end_time = timezone.now()
+        start_time = end_time - timedelta(days=7)
+        
+        # Optional query parameters
+        days = request.GET.get('days')
+        if days:
+            try:
+                days = int(days)
+                start_time = end_time - timedelta(days=days)
+            except ValueError:
+                pass
+        
+        # REQUIREMENT 4: SQL Aggregation using TruncHour and Avg
+        # This query is executed entirely in PostgreSQL
+        # REQUIREMENT 7: Uses index on (zone, timestamp)
+        hourly_averages = (
+            SensorReading.objects
+            .filter(
+                zone=zone,
+                timestamp__gte=start_time,
+                timestamp__lte=end_time,
+                is_valid=True
+            )
+            .annotate(hour=TruncHour('timestamp'))  # REQUIREMENT 4: TruncHour
+            .values('hour')
+            .annotate(avg_moisture=Avg('moisture_percentage'))  # REQUIREMENT 4: Avg
+            .order_by('hour')
+        )
+        
+        # Format response - note: we do NOT iterate over individual readings
+        # The aggregation is done in PostgreSQL, we only process aggregated results
+        result = []
+        for entry in hourly_averages:
+            result.append({
+                'hour': entry['hour'].isoformat() if entry['hour'] else None,
+                'average_moisture_percentage': round(entry['avg_moisture'], 2) if entry['avg_moisture'] else None
+            })
+        
+        return JsonResponse({
+            'zone_id': zone.id,
+            'zone_name': zone.name,
+            'period_start': start_time.isoformat(),
+            'period_end': end_time.isoformat(),
+            'hourly_averages': result,
+            'total_hours': len(result)
+        })
+
+
+class PumpStatusView(View):
+    """
+    API endpoint for checking pump status.
+    
+    GET /api/pumps/<pump_id>/status/
+    """
+    
+    def get(self, request, pump_id: int, *args, **kwargs) -> JsonResponse:
+        """Get current pump status."""
+        try:
+            pump = Pump.objects.select_related('zone').get(id=pump_id)
+        except Pump.DoesNotExist:
+            return JsonResponse(
+                {'error': f'Pump {pump_id} not found'},
+                status=404
+            )
+        
+        cooldown_minutes = getattr(settings, 'PUMP_COOLDOWN_MINUTES', 15)
+        
+        cooldown_remaining = None
+        if pump.last_activation_time:
+            elapsed = timezone.now() - pump.last_activation_time
+            remaining = (cooldown_minutes * 60) - elapsed.total_seconds()
+            if remaining > 0:
+                cooldown_remaining = int(remaining)
+        
+        return JsonResponse({
+            'pump_id': pump.id,
+            'hardware_id': pump.hardware_id,
+            'zone': pump.zone.name,
+            'status': pump.status,
+            'last_activation': pump.last_activation_time.isoformat() if pump.last_activation_time else None,
+            'is_in_cooldown': pump.is_in_cooldown(cooldown_minutes),
+            'cooldown_remaining_seconds': cooldown_remaining,
+            'total_activations': pump.total_activations
+        })
+
+
+@method_decorator(csrf_exempt, name='dispatch')
+class ManualPumpActivationView(View):
+    """
+    API endpoint for manually activating a pump.
+    
+    POST /api/pumps/<pump_id>/activate/
+    
+    Uses the same locking mechanism as automatic activation.
+    """
+    
+    def post(self, request, pump_id: int, *args, **kwargs) -> JsonResponse:
+        """Manually activate a pump."""
+        try:
+            data = json.loads(request.body) if request.body else {}
+        except json.JSONDecodeError:
+            data = {}
+        
+        duration = data.get('duration_seconds')
+        
+        cooldown_minutes = getattr(settings, 'PUMP_COOLDOWN_MINUTES', 15)
+        max_runtime = getattr(settings, 'PUMP_MAX_RUNTIME_SECONDS', 30)
+        
+        if duration:
+            try:
+                duration = min(int(duration), max_runtime)
+            except (TypeError, ValueError):
+                duration = max_runtime
+        else:
+            duration = max_runtime
+        
+        try:
+            with transaction.atomic():
+                pump = Pump.objects.select_for_update().get(id=pump_id)
+                
+                if pump.is_in_cooldown(cooldown_minutes):
+                    return JsonResponse({
+                        'status': 'error',
+                        'reason': 'pump_in_cooldown'
+                    }, status=400)
+                
+                if pump.status == Pump.Status.RUNNING:
+                    return JsonResponse({
+                        'status': 'error',
+                        'reason': 'pump_already_running'
+                    }, status=400)
+                
+                pump.status = Pump.Status.RUNNING
+                pump.last_activation_time = timezone.now()
+                pump.save(update_fields=['status', 'last_activation_time', 'updated_at'])
+                
+                task = activate_pump_task.delay(
+                    pump_id=pump.id,
+                    duration_seconds=duration
+                )
+                
+                return JsonResponse({
+                    'status': 'activated',
+                    'task_id': str(task.id) if task.id else 'eager-mode',
+                    'duration_seconds': duration
+                })
+        
+        except Pump.DoesNotExist:
+            return JsonResponse(
+                {'error': f'Pump {pump_id} not found'},
+                status=404
+            )
+
+
+class HealthCheckView(View):
+    """Simple health check endpoint."""
+    
+    def get(self, request, *args, **kwargs) -> JsonResponse:
+        return JsonResponse({
+            'status': 'healthy',
+            'timestamp': timezone.now().isoformat()
+        })
\ No newline at end of file
