diff --git a/repository_before/main.py b/repository_after/data_processor.py
index 55bb5e1..3a567d9 100644
--- a/repository_before/main.py
+++ b/repository_after/data_processor.py
@@ -1,103 +1,101 @@
 from typing import List, Dict, Any, Optional, Callable
-from datetime import datetime
+from collections import defaultdict
+from itertools import filterfalse
 
 class DataProcessor:
 
     def __init__(self, records: List[Dict[str, Any]]):
         self.records = records
+        self._indexes: Dict[str, Dict[Any, List[Dict[str, Any]]]] = {}
+
+    def _get_index(self, field: str) -> Dict[Any, List[Dict[str, Any]]]:
+        """Lazy index creation."""
+        if field not in self._indexes:
+            index = defaultdict(list)
+            for record in self.records:
+                if field in record:
+                    index[record[field]].append(record)
+            self._indexes[field] = index
+        return self._indexes[field]
 
     def filter_by_field(self, field: str, value: Any) -> List[Dict[str, Any]]:
-        results = []
-        for record in self.records:
-            if field in record and record[field] == value:
-                results.append(record)
-        return results
+        """O(1) lookup using hash index."""
+        index = self._get_index(field)
+        return list(index.get(value, []))
 
     def filter_by_fields(self, criteria: Dict[str, Any]) -> List[Dict[str, Any]]:
-        results = []
-        for record in self.records:
-            matches = True
-            for field, value in criteria.items():
-                if field not in record or record[field] != value:
-                    matches = False
-                    break
-            if matches:
-                results.append(record)
-        return results
+        """Multi-field filtering using the most selective index first."""
+        if not criteria:
+            return list(self.records)
+        
+        # Optimization: Pick the field that has an existing index, or just the first one
+        # To keep it consistent with "exactly identical", we must maintain original record order.
+        # If we use an index, we get records in their original order because the index 
+        # lists were built by iterating over self.records.
+        
+        # Let's find if any criteria field is already indexed
+        best_field = next((f for f in criteria if f in self._indexes), list(criteria.keys())[0])
+        initial_matches = self.filter_by_field(best_field, criteria[best_field])
+        
+        other_criteria = {f: v for f, v in criteria.items() if f != best_field}
+        if not other_criteria:
+            return initial_matches
+            
+        return [
+            record for record in initial_matches
+            if all(f in record and record[f] == v for f, v in other_criteria.items())
+        ]
 
     def filter_by_values(self, field: str, values: List[Any]) -> List[Dict[str, Any]]:
-        results = []
-        for record in self.records:
-            if field in record:
-                if record[field] in values:
-                    results.append(record)
-        return results
+        """Set-based membership check, preserving original order."""
+        value_set = set(values)
+        # Use filter with generator for lazy evaluation, then materialize
+        filtered = filter(lambda r: field in r and r[field] in value_set, self.records)
+        return list(filtered)
 
     def filter_by_range(self, field: str, min_val: Any, max_val: Any) -> List[Dict[str, Any]]:
-        results = []
-        for record in self.records:
-            if field in record:
-                val = record[field]
-                if val >= min_val and val <= max_val:
-                    results.append(record)
-        return results
+        """Generator-based range filtering using filter()."""
+        # Use filter with generator for lazy evaluation, then materialize
+        filtered = filter(
+            lambda r: field in r and min_val <= r[field] <= max_val,
+            self.records
+        )
+        return list(filtered)
 
     def filter_by_predicate(self, predicate: Callable[[Dict], bool]) -> List[Dict[str, Any]]:
-        results = []
-        for record in self.records:
-            if predicate(record):
-                results.append(record)
-        return results
+        """Filtering with arbitrary predicate using filter()."""
+        # Use filter() for lazy evaluation, then materialize
+        filtered = filter(predicate, self.records)
+        return list(filtered)
 
     def get_unique_values(self, field: str) -> List[Any]:
-        unique = []
-        for record in self.records:
-            if field in record:
-                value = record[field]
-                if value not in unique:
-                    unique.append(value)
-        return unique
+        """O(N) unique value extraction using hash index keys."""
+        index = self._get_index(field)
+        return list(index.keys())
 
     def count_by_field(self, field: str) -> Dict[Any, int]:
-        counts = {}
-        for record in self.records:
-            if field in record:
-                value = record[field]
-                if value in counts:
-                    counts[value] = counts[value] + 1
-                else:
-                    counts[value] = 1
-        return counts
+        """O(N) frequency count using hash index."""
+        index = self._get_index(field)
+        return {val: len(recs) for val, recs in index.items()}
 
     def sum_field(self, field: str, filter_criteria: Optional[Dict[str, Any]] = None) -> float:
-        total = 0.0
-        if filter_criteria:
-            records = self.filter_by_fields(filter_criteria)
-        else:
-            records = self.records
-        for record in records:
-            if field in record:
-                total = total + record[field]
-        return total
+        """Single-pass sum using built-in sum()."""
+        records = self.filter_by_fields(filter_criteria) if filter_criteria else self.records
+        return float(sum(record[field] for record in records if field in record))
 
     def average_field(self, field: str, filter_criteria: Optional[Dict[str, Any]] = None) -> float:
+        """Single-pass average calculation."""
+        records = self.filter_by_fields(filter_criteria) if filter_criteria else self.records
         total = 0.0
         count = 0
-        if filter_criteria:
-            records = self.filter_by_fields(filter_criteria)
-        else:
-            records = self.records
         for record in records:
             if field in record:
-                total = total + record[field]
-        for record in records:
-            if field in record:
-                count = count + 1
-        if count == 0:
-            return 0.0
-        return total / count
+                total += record[field]
+                count += 1
+        return total / count if count > 0 else 0.0
 
     def min_max_field(self, field: str) -> Dict[str, Any]:
+        """Single-pass min/max calculation."""
         min_val = None
         max_val = None
         for record in self.records:
@@ -105,79 +103,50 @@ class DataProcessor:
                 val = record[field]
                 if min_val is None or val < min_val:
                     min_val = val
-        for record in self.records:
-            if field in record:
-                val = record[field]
                 if max_val is None or val > max_val:
                     max_val = val
         return {'min': min_val, 'max': max_val}
 
     def top_n(self, field: str, n: int, descending: bool = True) -> List[Dict[str, Any]]:
-        valid_records = []
-        for record in self.records:
-            if field in record:
-                valid_records.append(record)
-        sorted_records = valid_records.copy()
-        for i in range(len(sorted_records)):
-            for j in range(i + 1, len(sorted_records)):
-                if descending:
-                    if sorted_records[j][field] > sorted_records[i][field]:
-                        temp = sorted_records[i]
-                        sorted_records[i] = sorted_records[j]
-                        sorted_records[j] = temp
-                else:
-                    if sorted_records[j][field] < sorted_records[i][field]:
-                        temp = sorted_records[i]
-                        sorted_records[i] = sorted_records[j]
-                        sorted_records[j] = temp
-        result = []
-        for i in range(min(n, len(sorted_records))):
-            result.append(sorted_records[i])
-        return result
+        """Sorting using built-in sorted() with key."""
+        valid_records = (r for r in self.records if field in r)
+        return sorted(valid_records, key=lambda r: r[field], reverse=descending)[:n]
 
     def group_by(self, field: str) -> Dict[Any, List[Dict[str, Any]]]:
-        groups = {}
-        for record in self.records:
-            if field in record:
-                key = record[field]
-                if key not in groups:
-                    groups[key] = []
-                groups[key].append(record)
-        return groups
+        """O(N) grouping using hash index."""
+        index = self._get_index(field)
+        return {k: list(v) for k, v in index.items()}
 
     def find_duplicates(self, field: str) -> List[Dict[str, Any]]:
-        value_counts = {}
-        for record in self.records:
-            if field in record:
-                val = record[field]
-                if val in value_counts:
-                    value_counts[val] = value_counts[val] + 1
-                else:
-                    value_counts[val] = 1
-        duplicate_values = []
-        for val, count in value_counts.items():
-            if count > 1:
-                duplicate_values.append(val)
-        duplicates = []
-        for record in self.records:
-            if field in record:
-                if record[field] in duplicate_values:
-                    duplicates.append(record)
-        return duplicates
+        """Duplicate detection using hash index and set-based filtering."""
+        index = self._get_index(field)
+        duplicate_values = {val for val, recs in index.items() if len(recs) > 1}
+        if not duplicate_values:
+            return []
+        # Use filter() for lazy evaluation, then materialize
+        filtered = filter(
+            lambda r: field in r and r[field] in duplicate_values,
+            self.records
+        )
+        return list(filtered)
 
     def join_on(self, other_records: List[Dict[str, Any]],
                 this_field: str, other_field: str) -> List[Dict[str, Any]]:
+        """Hash join O(N + M) implementation."""
+        other_index = defaultdict(list)
+        for other in other_records:
+            if other_field in other:
+                other_index[other[other_field]].append(other)
+        
         results = []
         for record in self.records:
             if this_field in record:
-                for other in other_records:
-                    if other_field in other:
-                        if record[this_field] == other[other_field]:
-                            merged = {}
-                            for k, v in record.items():
+                val = record[this_field]
+                if val in other_index:
+                    for other in other_index[val]:
+                        merged = record.copy()
+                        for k, v in other.items():
+                            if k not in merged:
                                 merged[k] = v
-                            for k, v in other.items():
-                                if k not in merged:
-                                    merged[k] = v
-                            results.append(merged)
+                        results.append(merged)
         return results
